<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[mysql explain中的type类型]]></title>
      <url>https://binecy.coding.me/mysql-explain-type/</url>
      <content type="html"><![CDATA[<p>mysql中常使用explain查看sql进行计划，而type类型是非常重要的。这里主要描述一下type的几种类型和意义。</p>
<p>先创建两个简单的表，用于测试。</p>
<pre><code>CREATE TABLE `author` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `sort` int(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

CREATE TABLE `blog` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) NOT NULL,
  `author_id` int(10) unsigned DEFAULT NULL,
  `author_sort` int(20) DEFAULT NULL,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `author_id` (`author_id`),
  KEY `title` (`title`) USING BTREE,
  KEY `author_sort` (`author_sort`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
</code></pre><p>type列很重要，是用来说明表与表之间是如何进行关联操作的，有没有使用索引。MySQL中“关联”一词比一般意义上的要宽泛，MySQL认为任何一次查询都是一次“关联”，并不仅仅是一个查询需要两张表才叫关联，所以也可以理解MySQL是如何访问表的。主要有下面几种类别。</p>
<p><strong>system</strong><br>该表（系统表）只有一行，是const的一种特例</p>
<p><strong>const</strong><br>单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。<br>const查询非常快，因为只读取一次</p>
<p>const 在使用主键或唯一索引查询时出现</p>
<p><img src="/mysql-explain-type/1.png" alt=""></p>
<p><strong>eq_ref</strong><br>使用 <code>=</code> 关联表，对于前一个表的每一记录，所关联的表都仅有一条数据匹配。<br>通常使用主键或唯一索引进行表关联时，会出现eq_ref。eq_ref对唯一性的索引B+树进行检索。<br>对于eq_ref，innobd和MyISAM表现不一致</p>
<p>Innodb在数组量小的表现如下<br><img src="/mysql-explain-type/2.png" alt=""></p>
<p>为了测试MyISAM的情况，先创建对于MyISAM的表</p>
<pre><code>CREATE TABLE `blog2` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `title` varchar(200) NOT NULL,
  `author_id` int(10) unsigned DEFAULT NULL,
  `author_sort` int(20) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `author_id` (`author_id`),
  KEY `author_sort` (`author_sort`) USING BTREE
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;


CREATE TABLE `author2` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `birthday` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `sort` int(20) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
</code></pre><p>MyISAM表现如下<br><img src="/mysql-explain-type/3.png" alt=""></p>
<p><strong>ref</strong><br>使用普通索引（只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY）进行查询或关联操作只使用了普通索引<br>ref可以用于使用=或&lt;=&gt;操作符的带索引的列。eq_ref对普通的索引B+树进行检索。</p>
<p><img src="/mysql-explain-type/4.png" alt=""></p>
<p><img src="/mysql-explain-type/5.png" alt=""></p>
<p><img src="/mysql-explain-type/6.png" alt=""></p>
<p><strong>fulltext</strong><br>fulltext是使用全文索引进行的。一般我们用到的索引都是B树，这里就不举例说明了。</p>
<p><strong>ref_or_null</strong><br>该类型和ref类似。但是MySQL会做一个额外的搜索包含NULL列的操作。在解决子查询中经常使用该联接类型的优化<br>对于ref_or_null，innobd和MyISAM在小数据量的情况下（大数据量待测试）表现也不一致</p>
<p>innodb<br><img src="/mysql-explain-type/7.png" alt=""></p>
<p>MyISAM:<br><img src="/mysql-explain-type/8.png" alt=""></p>
<p><strong>unique_subquery</strong></p>
<p>该类型替换了下面形式的IN子查询的ref：</p>
<pre><code>value IN (SELECT primary_key FROM single_table WHERE some_expr)
</code></pre><p>unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。</p>
<p><strong>index_subquery</strong></p>
<p>该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：</p>
<pre><code>value IN (SELECT key_column FROM single_table WHERE some_expr)
</code></pre><p><strong>range</strong><br>对索引进行给定范围内的检索，<br>当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN或者IN操作符，用常量比较关键字列时，可以使用range:<br>我的测试中：只有查询字段是主键或唯一索引时type才会为range。<br><img src="/mysql-explain-type/9.png" alt=""></p>
<p><img src="/mysql-explain-type/10.png" alt=""></p>
<p><img src="/mysql-explain-type/11.png" alt=""></p>
<p><strong>index</strong><br>对索引树进行全扫描，但通常比ALL快，因为索引文件通常比数据文件小。这个类型通常的作用是告诉我们查询是否使用索引进行排序操作。<br>常见于用id排序，如<br><img src="/mysql-explain-type/12.png" alt=""></p>
<p><strong>all</strong><br>最慢的一种方式，即全表扫描。</p>
<p>对于exists和in效率，不能简单地判定哪一个效率更高，比较如下查询：</p>
<p><img src="/mysql-explain-type/6.png" alt=""></p>
<p><img src="/mysql-explain-type/13.png" alt=""></p>
<p>使用in查询，对author表进行了全表查询，如果author表数据量较小，则in查询更快。</p>
<p>使用exists查询，对blog表进行了全表查询，如果blog表数据量较小，则exists查询更快。</p>
<p>水平有限，如有错漏，还望指出。</p>
<p>参考：<br><a href="http://www.cnblogs.com/zhanjindong/p/3439042.html#type" target="_blank" rel="external">MySQL优化—工欲善其事，必先利其器之EXPLAIN</a><br><a href="https://segmentfault.com/p/1210000009243739/read#top" target="_blank" rel="external">MySQL 处理海量数据时的一些优化查询速度方法</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[2017面试总结]]></title>
      <url>https://binecy.coding.me/interview-summary/</url>
      <content type="html"><![CDATA[<p>不到两年的工作经验，面试了一个多月，也找到工作了，记录一下面试遇到的题目及遇到的坑吧。<br>问题有点杂，很多是根据简历问的</p>
<p>nio为什么比bio好  面向buffer，非阻塞<br>synchronized与reentrantlock区别<br>synchronized静态方法和synchronized实例方法的区别<br>AtomicInteger与Interger区别<br>nio基于系统的什么机制？ epoll 多路复用<br>threadlocal实现<br>class类加载过程<br>线程池的实现<br>线程join的作用/一个任务等其他任务执行完后再执行,怎么处理<br>java对象的生命周期（在哪里创建/什么时候回收/什么时候进入老年区）<br>新生区什么时候触发回收？老年区呢？</p>
<p>redis实现乐观锁，分布式锁<br>redis怎么做消息系统<br>跳表是什么结构？redis用在哪里<br>redis持久化的方式？aof如果超出文件限制了，怎么处理<br>redis有几种数据格式    </p>
<p>简述一下https<br>http，tcp区别  tcp全双工，属于传输层 http请求响应，属于内容层<br>tcp，http特点</p>
<p>mysql中for update是行锁还是表锁？ 列锁<br>简述一下mysql的乐观锁  mvcc<br>like可以使用索引吗<br>分表分库的路由算法<br>mysql MyIsam和Innodb引擎有什么区别<br>mysql 左外连接、右外连接、内连接、全连接区别<br>mysql事务隔离级别<br>mysql中!=可以使用索引吗？这样优化，使之可以使用索引<br>mysql 分表分库怎样做关联和事务</p>
<p>spring有几种注入方式<br>spring中aop，ioc的实现原理<br>mybatis中${}和#{}区别<br>组合mybatis中的typehandler，说说组合模式，组合(dom4j)加载xml节点，说说访问者模式<br>netty中handler是单例吗</p>
<p>thrift集群，怎么做负载均衡    nginx<br>thrfit怎样解决不断重连问题   长连接<br>thrif怎样向后兼容<br>rpc(dubbo)的调用过程<br>dubbo的实现（有什么组件，一次请求的过程）<br>dubbo有什么协议<br>spring cloud有哪些组件?有什么作用</p>
<p>zk注册中心的作用<br>zookeeper的用途</p>
<p>简述一下kafka<br>kafka 怎么按时间查询<br>kafka基于磁盘， 为什么吞吐量这么高<br>kafka中topic是什么</p>
<p>怎样查看linux中进程/线程占用资源的情况    top -h<br>awk使用</p>
<p>docker有那些网络模式/docker虚拟网络有什么缺点<br>了解哪些跨域攻击</p>
<p><strong>一些场景题</strong><br>分布式session怎么实现<br>用户操作日记，一天1000W记录，需要按时间或用户进行搜索，用mysql存储有什么问题，使用其他什么组件更好<br>cpu过高，应用反应过慢，怎么排查<br>5千万排行榜，实时刷新，怎么实现<br>怎样测试tcp长连接并发数<br>设计一个抢购活动，要注意哪些问题</p>
<p><strong>非技术问题</strong><br>个人目标/职业规划<br>工作中遇到问题，解决方案<br>对加班怎么看<br>为什么从上家公司离职</p>
<p><strong>一些想法</strong><br>关于裸辞<br>裸辞会导致压力增大，面试谈薪资等方面也不利，慎行之。</p>
<p>这次找工作经历两个阶段。一阶段是自己没准备好，技能知识或面试技巧没准备好，建议面试前多看看面经（学习理解而不是背），对于一些经常问的非技术问题，心里先确定自己的想法。二阶段是自己投错了公司，不同行业（或公司）对技术要求是不同的，特别是一些行业对技术是不太重视的，就算是海投，也要选择合适自己的职位，不然就是浪费时间。</p>
<p>参考：<br><a href="http://www.importnew.com/12773.html" target="_blank" rel="external">Java线程面试题 Top 50</a><br><a href="http://www.jianshu.com/p/f5dee1306d0d" target="_blank" rel="external">年底啦，java后台面试题整理</a><br><a href="http://www.jianshu.com/p/1b2f63a45476" target="_blank" rel="external">关于Java面试，你应该准备这些知识点</a><br><a href="https://segmentfault.com/a/1190000004716061" target="_blank" rel="external">近期Java高级工程师面试总结</a><br><a href="https://yq.aliyun.com/articles/38181" target="_blank" rel="external">数据库和MySQL相关面试题目</a><br><a href="http://www.jianshu.com/p/1bc003884232" target="_blank" rel="external">java服务器后台面试题整理</a><br><a href="http://jeffzzf.github.io/2015/07/04/Java%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/" target="_blank" rel="external">Java并发面试题整理</a><br><a href="http://www.3023.com/6316/391446829072641.html" target="_blank" rel="external">你掌握以下50道题目，我包你进BAT任何一家公司</a></p>
<p><a href="http://www.cnblogs.com/xrq730/p/5260294.html#3650335" target="_blank" rel="external">面试感悟—-一名3年工作经验的程序员应该具备的技能</a><br><a href="http://www.importnew.com/22056.html" target="_blank" rel="external">阿里面试回来，想和Java程序员谈一谈</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[spring-support]]></title>
      <url>https://binecy.coding.me/spring-support/</url>
      <content type="html"><![CDATA[<p>在<a href="/java-spring-get-bean/" title="spring获取bean - 源码简析">spring获取bean - 源码简析</a> 中简单描述了spring创建bean的过程。</p>
<p>下面，通过自定义BeanPostProcessor，在bean创建前后自定义自己的操作。</p>
<pre><code>public class MyBeanProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;BeforeInitialization : &quot; + beanName + &quot; , &quot; + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;AfterInitialization : &quot; + beanName + &quot; , &quot; + bean);
        return bean;
    }
}
</code></pre><p>非常简单，仅仅是输出一些信息。</p>
<p>spring.xml配置:</p>
<pre><code>&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;spring.processor.MyBeanProcessor&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;blog&quot; class=&quot;spring.bean.Blog&quot; &gt;
    &lt;property name=&quot;title&quot; value=&quot;hello spring&quot; &gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>使用<a href="/java-spring-load-config/" title="spring加载配置-源码简析">spring加载配置-源码简析</a>中的测试方法</p>
<pre><code>@Test
public void test() {
    BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;spring.xml&quot;));
    Blog bean = (Blog)beanFactory.getBean(&quot;blog&quot;);
    Assert.assertEquals(bean.getTitle(), &quot;hello spring&quot;);
}
</code></pre><p>这时并没有输出MyBeanProcessor中定义的信息，而把测试方法修改为如下：</p>
<pre><code>@Test
public void test() {
    ClassPathXmlApplicationContext beanFactory = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Blog bean = (Blog)beanFactory.getBean(&quot;blog&quot;);
    Assert.assertEquals(bean.getTitle(), &quot;hello spring&quot;);
}
</code></pre><p>这时可以看到程序输出了MyBeanProcessor中定义的信息。</p>
<p>org.springframework.context.support.ClassPathXmlApplicationContext是spring support中的类。下面简单看一下它做了哪些工作。</p>
<pre><code>public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh,
    ApplicationContext parent) throws BeansException {

    super(parent);
    setConfigLocations(configLocations);
    if (refresh) {
        refresh();
    }
}
</code></pre><p>核心方法为refresh():</p>
<pre><code>public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // 准备刷新上下文环境
        prepareRefresh();

        // 初始化BeanFactory，并进行xml文件读取
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 对beanFacotry进行各种功能填充
        prepareBeanFactory(beanFactory);

        try {
            // 提供给子类覆盖方法做额外处理
            postProcessBeanFactory(beanFactory);

            // 激活BeanFactoryPostProcessors
            invokeBeanFactoryPostProcessors(beanFactory);

            // 注册拦截Bean创建的Bean处理器(这里只是注册,真正调用在getBean的时候)
            registerBeanPostProcessors(beanFactory);

            // 初始化应用消息广播器,即不同语言的消息体,国际化处理
            initMessageSource();

            // 初始化广播器,并放到上下文中    
            initApplicationEventMulticaster();

            // 提供给子类初始化其他的Bean
            onRefresh();

            // 在所有注册的bean中查找Listener bean,注册到消息广播中
            registerListeners();

            // 初始化剩下的单实例(InitializingBean,DisposableBean, Aware对象等)
            finishBeanFactoryInitialization(beanFactory);

            // 完成刷新过程,通知生命周期处理器
            finishRefresh();
        }

        ...

        finally {
            // Reset common introspection caches in Spring&#39;s core, since we
            // might not ever need metadata for singleton beans anymore...
            resetCommonCaches();
        }
    }
}
</code></pre><h2 id="初始化BeanFactory"><a href="#初始化BeanFactory" class="headerlink" title="初始化BeanFactory"></a>初始化BeanFactory</h2><p>ClassPathXmlApplicationContext的继承层次很深:<br>ClassPathXmlApplicationContext -&gt; AbstractXmlApplicationContext -&gt; AbstractRefreshableConfigApplicationContext -&gt; AbstractRefreshableApplicationContext -&gt; AbstractApplicationContext<br>而AbstractApplicationContext -&gt; ConfigurableApplicationContext -&gt; ApplicationContext -&gt; ListableBeanFactory,HierarchicalBeanFactory -&gt; BeanFactory</p>
<p>可以看到 ClassPathXmlApplicationContext实现了BeanFactory接口，而调用方法<code>getBean</code>将执行到AbstractApplicationContext.getBean:</p>
<pre><code>public Object getBean(String name) throws BeansException {
    assertBeanFactoryActive();    // 判断BeanFactory是否为Active
    return getBeanFactory().getBean(name);    // 通过getBeanFactory()获取beanFactory，并使用beanFactory生成bean
}
</code></pre><p>getBeanFactory在AbstractRefreshableApplicationContext中实现</p>
<pre><code>@Override
public final ConfigurableListableBeanFactory getBeanFactory() {
    synchronized (this.beanFactoryMonitor) {
        if (this.beanFactory == null) {
            throw new IllegalStateException(&quot;BeanFactory not initialized or already closed - &quot; +
                    &quot;call &#39;refresh&#39; before accessing beans via the ApplicationContext&quot;);
        }
        return this.beanFactory;
    }
}
</code></pre><p>同步方法，方法返回了beanFactory属性，beanFactory属性的刷新要通过如下方法：</p>
<pre><code>protected final void refreshBeanFactory() throws BeansException {
    if (hasBeanFactory()) {     // 销毁已存在的beanFactory
        destroyBeans();
        closeBeanFactory();
    }

    ...
    DefaultListableBeanFactory beanFactory = createBeanFactory();    // 创建beanFactory

}

protected DefaultListableBeanFactory createBeanFactory() {
    return new DefaultListableBeanFactory(getInternalParentBeanFactory());
}
</code></pre><p>回到refresh()方法,refresh()中通过<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code>获取beanFactory。</p>
<pre><code>protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    refreshBeanFactory();
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    ...
    return beanFactory;
}
</code></pre><p>可以看到该方法先调用了<code>refreshBeanFactory();</code>来刷新beanFactory，再通过<code>getBeanFactory()</code>获取beanFactory。</p>
<h2 id="激活BeanFactoryPostProcessors"><a href="#激活BeanFactoryPostProcessors" class="headerlink" title="激活BeanFactoryPostProcessors"></a>激活BeanFactoryPostProcessors</h2><p>通过BeanFactoryPostProcessor，可以对beanFactory进行处理，如修改其他BeanDefinition的配置。<br>refresh()中通过<code>invokeBeanFactoryPostProcessors(beanFactory);</code>激活BeanFactoryPostProcessors。</p>
<pre><code>protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
}
</code></pre><p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法支持周期性的，一次性的和优先级的Processor，下面仅摘录部分示意代码</p>
<pre><code>public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
    ...
    String[] postProcessorNames =
                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }                

    // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
    invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
}
</code></pre><h2 id="注册BeanPostProcessors处理器"><a href="#注册BeanPostProcessors处理器" class="headerlink" title="注册BeanPostProcessors处理器"></a>注册BeanPostProcessors处理器</h2><p>通过BeanPostProcessors，可以在bean创建过程中执行自定义操作，如重写<code>postProcessBeforeInitialization</code>方法并返回非null值，那spring将直接使用该返回值给bean赋值。<br>refresh()中通过<code>registerBeanPostProcessors(beanFactory);</code>注册BeanPostProcessors处理器</p>
<pre><code>protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
}
</code></pre><p>PostProcessorRegistrationDelegate.registerBeanPostProcessors中也是获取xml配置中的BeanPostProcessor处理器，并注册到beanFactory中，在spring创建bean时，将获取beanFactory中的BeanPostProcessor并调用。</p>
<pre><code>public static void registerBeanPostProcessors(
        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {
    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

    // First, register the BeanPostProcessors that implement PriorityOrdered.
    sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
    ...
}
</code></pre><h2 id="初始化事件广播器"><a href="#初始化事件广播器" class="headerlink" title="初始化事件广播器"></a>初始化事件广播器</h2><p>Spring事件体系包括三个组件：事件，事件监听器，事件广播器。事件广播器负责将事件广播给监听器。<br><code>initApplicationEventMulticaster</code>将初始化广播器,并放到beanFactory中  </p>
<pre><code>protected void initApplicationEventMulticaster() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    // beanFactory中包含了事件广播器
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {    
        this.applicationEventMulticaster =
                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
    }
    else {    // 使用默认的事件广播器
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
    }
}
</code></pre><h2 id="初始化事件监听器"><a href="#初始化事件监听器" class="headerlink" title="初始化事件监听器"></a>初始化事件监听器</h2><p>事件监听器负责监听事件，并做出处理。<br>registerListeners将初始化事件监听器，并添加到事件广播器上。</p>
<pre><code>protected void registerListeners() {
    // Register statically specified listeners first.
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    // Publish early application events now that we finally have a multicaster...
    ...
}
</code></pre><h2 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h2><pre><code>protected void finishRefresh() {
    // Initialize lifecycle processor for this context.
    initLifecycleProcessor();

    // Propagate refresh to lifecycle processor first.
    getLifecycleProcessor().onRefresh();

    // Publish the final event.
    publishEvent(new ContextRefreshedEvent(this));

    // Participate in LiveBeansView MBean, if active.
    LiveBeansView.registerApplicationContext(this);
}
</code></pre><p>LifecycleProcessor是spring生命周期的管理。可以定义spring启动start，停止stop，或刷新onRefresh等操作。</p>
<pre><code>protected void initLifecycleProcessor() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {
        this.lifecycleProcessor =
                beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);
    }
    else {    // 使用默认的LifecycleProcessor
        DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();
        defaultProcessor.setBeanFactory(beanFactory);
        this.lifecycleProcessor = defaultProcessor;
        beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);
    }
}
</code></pre>]]></content>
      
        
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[docker上整合kafka和flume]]></title>
      <url>https://binecy.coding.me/docker-kafka-flume/</url>
      <content type="html"><![CDATA[<p>docker上运行这些系统确是很方便。记录一下在docker上运行整合kakfa，flume的过程，以做备忘</p>
<p><strong>运行zookeeper</strong></p>
<pre><code># docker pull wurstmeister/zookeeper
# docker run --name zookeeper -p 2181:2181 -t -d wurstmeister/zookeeper 
# docker ps -a
CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                                                NAMES
3b9d2029c1b6        wurstmeister/zookeeper   &quot;/bin/sh -c &#39;/usr/sbi&quot;   57 seconds ago      Up 56 seconds       22/tcp, 2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp   zookeeper
</code></pre><p>我是在aws上运行的，所以pull速度很快  </p>
<p><strong>运行kafka</strong></p>
<pre><code># docker pull wurstmeister/kafka
# docker run -id --name kafka  -e KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms128M&quot; -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://52.37.134.248:9092 -e KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092  -e KAFKA_BROKER_ID=1 -e ZK=zk -p 9092:9092 --link zookeeper:zk   wurstmeister/kafka
# docker ps -a
CONTAINER ID        IMAGE                    COMMAND                  CREATED             STATUS              PORTS                                                NAMES
877992e80d14        wurstmeister/kafka       &quot;start-kafka.sh&quot;         6 seconds ago       Up 5 seconds        0.0.0.0:9092-&gt;9092/tcp                               kafka
</code></pre><p>由于在aws上运行，内存只有1G，所以run时指定了内存大小<code>KAFKA_HEAP_OPTS=&quot;-Xmx256M -Xms128M&quot;</code><br>为了方便外网访问kafka，启动时也指定了LISTENERS参数<code>KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://52.37.134.248:9092</code>和<code>KAFKA_LISTENERS=PLAINTEXT://0.0.0.0:9092</code>(52.37.134.248为宿主机器ip)</p>
<p>创建topic</p>
<pre><code># docker exec -it kafka /bin/bash
bash-4.3# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/opt/jdk/bin:/opt/kafka/bin
bash-4.3# cd /opt/kafka
bash-4.3# bin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic flume
Created topic &quot;flume&quot;.
bash-4.3# bin/kafka-topics.sh --list --zookeeper zookeeper:2181
flume
</code></pre><p>通过exec进入容器，输出PATH可以查看kafka位置。</p>
<p>运行flume<br>flume比较麻烦的是，docker hub上没有最新的flume镜像，所以只好自己构造了。<br>编写Dockerfile，内容为</p>
<pre><code>FROM openjdk:8u121-jre
MAINTAINER bin

RUN apt-get update &amp;&amp; apt-get install -q -y --no-install-recommends wget



RUN mkdir /opt/flume
RUN wget -qO- http://archive.apache.org/dist/flume/1.7.0/apache-flume-1.7.0-bin.tar.gz \
  | tar zxvf - -C /opt/flume --strip 1

ADD start-flume.sh /opt/flume/bin/start-flume

ENV PATH /opt/flume/bin:$PATH
</code></pre><p>非常简单，就是下载flume，解压，及添加解压路径到PATH</p>
<p>构造镜像</p>
<pre><code># docker build -t  bin/flume .
# docker images
REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE
bin/flume                latest              74c8cd29dd1b        46 minutes ago      404.3 MB
openjdk                  8u121-jre           a4d689e63201        2 days ago          309.2 MB
</code></pre><p>编写flume配置文件flume.conf</p>
<pre><code>#指定agent的组件名称
a1.sources = r1
a1.sinks = k1
a1.channels = c1

# 指定Flume source(要监听的路径)
a1.sources.r1.type = spooldir
a1.sources.r1.spoolDir = /var/tmp/flume_log
a1.sources.r1.ignorePattern = ^(.)*\\.tmp|(.)*\\.COMPLETED$

# 指定Flume sink
#a1.sinks.k1.type = logger
#a1.sinks.k1.type = file_roll
#a1.sinks.k1.sink.directory = /var/tmp/flume_out/
a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink
a1.sinks.k1.kafka.topic = flume
a1.sinks.k1.kafka.bootstrap.servers = kafka:9092
a1.sinks.k1.kafka.flumeBatchSize = 20
a1.sinks.k1.kafka.producer.acks = 1
a1.sinks.k1.kafka.producer.linger.ms = 1
a1.sinks.ki.kafka.producer.compression.type = snappy

# 指定Flume channel
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100

# 绑定source和sink到channel上
a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1
</code></pre><p>运行flume镜像</p>
<pre><code># docker run -v /home/ec2-user/docker/flume/flume.conf:/opt/flume/conf/flume.conf -v /home/ec2-user/docker/flume/flume_log:/var/tmp/flume_log   --link zookeeper:zk  --link kafka:kafka --name flume -it  bin/flume
</code></pre><p>注意，这时映射了conf文件，及监听路径flume_log(注意路径正确)，同时link了kafka。<br>运行成功后，当前的命令行已经是容器内的命令，运行flume就行</p>
<pre><code>root@29f5c8a54f13:/opt/flume# bin/flume-ng agent --conf conf --conf-file conf/flume.conf --name a1 -Dflume.root.logger=INFO,console
</code></pre><p>退出容器(ctrl+p ctrl+q)，然后进入宿主机器的flume.conf，输出一个测试内容</p>
<pre><code># echo &quot;hello&quot; &gt;&gt; 1.log
</code></pre><p>进入kafka容器，使用<code>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic flume --from-beginning</code>可以查看到已经接收到hello字符串了。</p>
<p>本想加上elasticsearch，kibana的，但aws已经跑不起来，所以暂且这样了。</p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[netty启动过程源码简析]]></title>
      <url>https://binecy.coding.me/netty-start/</url>
      <content type="html"><![CDATA[<p>一个小栗子</p>
<pre><code>EventLoopGroup parentGroup = new NioEventLoopGroup();
EventLoopGroup childGroup = new NioEventLoopGroup();
ServerBootstrap b = new ServerBootstrap();
b.group(parentGroup, 与childGroup)
    .channel(NioServerSocketChannel.class)
    .childHandler(...);

// Start the server.
ChannelFuture f = b.bind(PORT).sync();

// Wait until the server socket is closed.
f.channel().closeFuture().sync();
</code></pre><p>栗子中创建了    parentGroup和childGroup，<br>parentGroup负责处理请求的accept事件， 类似于reactor模式中的acceptor<br>childGroup负责接收请求的read、write事件，并分发给对应的处理器，类似于reactor模式中的reactor对象。<br><img src="/netty-start/1.png" alt=""></p>
<p><strong>创建NioEventLoopGroup</strong><br>NioEventLoopGroup实现了EventLoopGroup接口，负责对EventLoop进行管理。 NioEventLoopGroup的构造过程主要在MultithreadEventExecutorGroup构造方法中</p>
<pre><code>protected MultithreadEventExecutorGroup(int nThreads, Executor executor,EventExecutorChooserFactory chooserFactory, Object... args) {                                    
    // 执行器
    executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
    children = new EventExecutor[nThreads];
    // 选择器
    chooser = chooserFactory.newChooser(children);    
    // 创建EventLoop    
    for (int i = 0; i &lt; nThreads; i ++) {
        children[i] = newChild(threadFactory, args);
    }
}

protected EventExecutor newChild(  
            ThreadFactory threadFactory, Object... args) throws Exception {  
      return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0]);  
}
</code></pre><p><strong>启动</strong></p>
<pre><code>private ChannelFuture doBind(final SocketAddress localAddress) {
    final ChannelFuture regFuture = initAndRegister();

    if (regFuture.isDone()) {
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        ...
    }
}
</code></pre><p>initAndRegister中创建并注册了Channel。</p>
<pre><code>final ChannelFuture initAndRegister() {
    Channel channel = null;
    channel = channelFactory.newChannel();
    init(channel);

    ChannelFuture regFuture = config().group().register(channel);
}
</code></pre><p><code>channelFactory.newChannel()</code>中的channelFactory为ReflectiveChannelFactory对象，这时通过反射生成NioServerSocketChannel对象（通过ServerBootstrap.channel(NioServerSocketChannel.class)设置）</p>
<p>NioServerSocketChannel是对java.nio.channels.ServerSocketChannel的封装,实现了io.netty.channel.Channel接口。</p>
<p><strong>创建NioServerSocketChannel</strong><br><img src="/netty-start/2.png" alt=""></p>
<pre><code>public NioServerSocketChannel() {
    this(newSocket(DEFAULT_SELECTOR_PROVIDER));
}
</code></pre><p>DEFAULT_SELECTOR_PROVIDER为java.nio.channels.spi.SelectorProvider,<br><code>newSocket(DEFAULT_SELECTOR_PROVIDER)</code>将创建一个ServerSocketChannel。</p>
<pre><code>public NioServerSocketChannel(ServerSocketChannel channel) {
    super(null, channel, SelectionKey.OP_ACCEPT);    
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}

protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    super(parent);
    this.ch = ch;
    // 该readInterestOp即为NioServerSocketChannel构造方法中的SelectionKey.OP_ACCEPT
    this.readInterestOp = readInterestOp;    

    ch.configureBlocking(false);    // 设置channel为非阻塞
}

protected AbstractChannel(Channel parent) {
    this.parent = parent;
    id = newId();
    unsafe = newUnsafe();    // 初始化unsafe
    pipeline = newChannelPipeline();    // 初始化pipeline
}
</code></pre><p>AbstractChannel构造时创建了两个关键的属性：<br>unsafe为NioMessageUnsafe，通过AbstractNioMessageChannel重写的<code>newUnsafe()</code>创建<br>unsafe负责真正的操作，如register，bind，read等操作<br>pipeline则创建了DefaultChannelPipeline</p>
<p><strong>创建pipeline</strong></p>
<pre><code>protected DefaultChannelPipeline(Channel channel) {
    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);
    succeededFuture = new SucceededChannelFuture(channel, null);
    voidPromise =  new VoidChannelPromise(channel, true);

    tail = new TailContext(this);
    head = new HeadContext(this);

    head.next = tail;
    tail.prev = head;
}
</code></pre><p>pipeline是一个链表，链表中的结点为ChannelHandlerContext，ChannelHandlerContext是包含ChannelHandler的上下文。</p>
<p>需要注意，DefaultChannelPipeline创建后，就已经包括了head，tail两个结点。</p>
<p><strong>初始化channel</strong><br>到此，channel已经成功创建，<code>init(channel)</code>将初始化channel</p>
<pre><code>void init(Channel channel) {
    // 初始化options和attr
    ...

    p.addLast(new ChannelInitializer&lt;Channel&gt;() {    // 添加ChannelInitializer handler
            @Override
            public void initChannel(Channel ch) throws Exception {
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();

                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
}
</code></pre><p>这时添加了一个ChannelInitializer handler了，注意，addLast不是将handler添加到最后结点，而是倒数第二结点，tail总是最后一个结点。</p>
<p><strong>注册channel</strong><br><code>config().group().register(channel)</code>进行了注册操作<br>注意config().group()返回的是parent EventLoopGroup</p>
<p>EventLoop继承自java.util.concurrent.ScheduledExecutorService，是一个任务执行器，可以将任务提交给它，则它来执行。</p>
<p>SingleThreadEventLoop实现了EventLoop，并继承自SingleThreadEventExecutor，Executor封装了任务执行细节。<br>nioEventLoop继承了SingleThreadEventLoop，并封装了java.nio.channels.Selector，响应其中的事件。</p>
<p>注册过程<br>MultithreadEventLoopGroup</p>
<pre><code>public ChannelFuture register(Channel channel) {
    return next().register(channel);    // 通过选择器选择一个合适的EventLoop
}
</code></pre><p>SingleThreadEventLoop</p>
<pre><code>public ChannelFuture register(Channel channel) {
    return register(new DefaultChannelPromise(channel, this));
}

public ChannelFuture register(final ChannelPromise promise) {
    promise.channel().unsafe().register(this, promise);
    return promise;
}
</code></pre><p>上面已经说了，channel中的unsafe对应为AbstractUnsafe，查看其register</p>
<pre><code>public final void register(EventLoop eventLoop, final ChannelPromise promise) {
    ...
    if (eventLoop.inEventLoop()) {
        register0(promise);
    } else {

        eventLoop.execute(new Runnable() {
            @Override
            public void run() {
                register0(promise);
            }
        });
    }
}
</code></pre><p>如果当前线程是eventLoop的执行线程，则直接在当前线程执行<code>register0</code>，否则将提交一个新任务到eventLoop中。</p>
<p>注意：调用<code>eventLoop.execute</code>时，如果eventLoop没有启动，将调用eventLoop。</p>
<pre><code>private void register0(ChannelPromise promise) {
    doRegister();
    ...
    // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
    // user may already fire events through the pipeline in the ChannelFutureListener.
    pipeline.invokeHandlerAddedIfNeeded();

// Only fire a channelActive if the channel has never been registered. This prevents firing
    // multiple channel actives if the channel is deregistered and re-registered.
    pipeline.fireChannelRegistered();

    if (isActive()) {
        if (firstRegistration) {
            pipeline.fireChannelActive();
        } else if (config().isAutoRead()) {
            // This channel was registered before and autoRead() is set. This means we need to begin read
            // again so that we process inbound data.
            //
            // See https://github.com/netty/netty/issues/4805
            beginRead();
        }
    }

}
</code></pre><p><code>doRegister</code>将调用到AbstractNioChannel.doRegister</p>
<pre><code>protected void doRegister() throws Exception {
    selectionKey = javaChannel().register(eventLoop().selector, 0, this);
    return;    
}
</code></pre><p>需要注意，register中的ops参数为0，这时只是把select注册到channel上,将没有监听任何事件。</p>
<p>监听事件在<code>beginRead()</code>方法中实现，该方法将调用到AbstractNioChannel.doBeginRead</p>
<pre><code>protected void doBeginRead() throws Exception {
    ...
    final int interestOps = selectionKey.interestOps();
    if ((interestOps &amp; readInterestOp) == 0) {
        selectionKey.interestOps(interestOps | readInterestOp);
    }
}
</code></pre><p>interestOps为0,readInterestOp在NioServerSocketChannel创建时已经被赋值为SelectionKey.OP_ACCEPT,所以<code>interestOps | readInterestOp</code>为SelectionKey.OP_ACCEPT，这时成功设置事件监听。</p>
<p><strong>绑定端口</strong><br>启动的最后一步，就是绑定端口，在AbstractBootstrap.doBind0中实现</p>
<pre><code>private static void doBind0(
        final ChannelFuture regFuture, final Channel channel,
        final SocketAddress localAddress, final ChannelPromise promise) {

    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up
    // the pipeline in its channelRegistered() implementation.
    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (regFuture.isSuccess()) {
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            } else {
                promise.setFailure(regFuture.cause());
            }
        }
    });
}
</code></pre><p>DefaultChannelPipeline.bind</p>
<pre><code>public final ChannelFuture bind(SocketAddress localAddress) {
    return tail.bind(localAddress);
}
</code></pre><p>HeadContext.bind</p>
<pre><code>public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) {
    final AbstractChannelHandlerContext next = findContextOutbound();
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            next.invokeBind(localAddress, promise);
        } else {
            safeExecute(executor, new Runnable() {
                @Override
                public void run() {
                    next.invokeBind(localAddress, promise);
                }
            }, promise, null);
        }
        return promise;
}
</code></pre><p><code>findContextOutbound()</code>将找到HeadContext，HeadContext.bind</p>
<pre><code>unsafe.bind(localAddress, promise);
</code></pre><p>NioMessageUnsafe.bind将调用外部类的<code>doBind(localAddress)</code>方法，最终调用NioServerSocketChannel.doBind</p>
<pre><code>protected void doBind(SocketAddress localAddress) throws Exception {
    if (PlatformDependent.javaVersion() &gt;= 7) {
        javaChannel().bind(localAddress, config.getBacklog());
    } else {
        javaChannel().socket().bind(localAddress, config.getBacklog());
    }
}
</code></pre><p>到此,启动完成。</p>
]]></content>
      
        
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ConcurrentHashMap实现]]></title>
      <url>https://binecy.coding.me/concurrentHashMap/</url>
      <content type="html"><![CDATA[<p>本文简单描述jdk7下ConcurrentHashMap的实现。</p>
<p>文章主要关注以下问题<br>1.同步<br>ConcurrentHashMap是线程安全的，那么如何解决线程冲突问题<br>2.扩容<br>如果当前容器已经接收新元素，将如何扩容<br>3.hash冲突<br>当出现hash冲突（不同hash值映射到同一位置）时，如何解决</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><pre><code>public ConcurrentHashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
}


public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    ...

    // 计算一个大于concurrencyLevel的2的幂指数作为实际并发度
    int sshift = 0;
    int ssize = 1;
    while (ssize &lt; concurrencyLevel) {
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    // segmentShift,segmentMask用于计算Segment位置
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    // 根据计算的并发度，计算每一个Segment的容量
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap &lt; c)
        cap &lt;&lt;= 1;

    // 创建Segments数组和Segment[0]
    Segment&lt;K,V&gt; s0 =
        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
</code></pre><p>UNSAFE是jdk提供的，用于直接操作内存，是不安全的操作。<br>关于UNSAFE，可参考: <a href="http://www.jianshu.com/p/a16d638bc921" target="_blank" rel="external">java中的Unsafe</a></p>
<p>Segment是ConcurrentHashMap的内部静态类</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {
    transient volatile HashEntry&lt;K,V&gt;[] table;
    transient int count;

}
</code></pre><p>HashEntry数组是真正的存储元素的数组，<br>Segment继承自ReentrantLock，所以带有锁的功能。</p>
<p>HashEntry也是ConcurrentHashMap的内部静态类</p>
<pre><code>static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}
</code></pre><p>HashEntry中有next属性，指向下一个HashEntry元素，实际上HashEntry为一个链表，当hash冲突时，可以存储不同的值。（解决hash冲突的问题）</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><pre><code>public V put(K key, V value) {
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    // 计算hash值
    int hash = hash(key);
    // 计算Segment下标
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    // 查找Segment
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    // put操作
    return s.put(key, hash, value, false);
}
</code></pre><p><strong>计算hash值</strong></p>
<pre><code>private int hash(Object k) {
    int h = hashSeed;

    if ((0 != h) &amp;&amp; (k instanceof String)) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();


    h += (h &lt;&lt;  15) ^ 0xffffcd7d;
    h ^= (h &gt;&gt;&gt; 10);
    h += (h &lt;&lt;   3);
    h ^= (h &gt;&gt;&gt;  6);
    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
    return h ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>这时将对hash值使用Wang/Jenkins hash算法。</p>
<p><strong>计算Segment下标</strong></p>
<pre><code>int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
</code></pre><p>运行时通过将key的高n位（n = 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。<br>为什么是32呢，因为int只有32位（其中一位表示符号）。</p>
<p><strong>创建Segment</strong><br>由于支持并发操作，当segments[j]为空时,必须重复检查操作,</p>
<pre><code>private Segment&lt;K,V&gt; ensureSegment(int k) {
    final Segment&lt;K,V&gt;[] ss = this.segments;
    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset
    Segment&lt;K,V&gt; seg;
    // 重复检查
    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {
        // 使用ss[0]的属性构造新的Segment
        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype
        int cap = proto.table.length;
        float lf = proto.loadFactor;
        int threshold = (int)(cap * lf);
        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];
        // 再次检查
        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
            == null) { // recheck
            // 构造新的Segment
            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);
            // cas操作
            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
                   == null) {
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}
</code></pre><p>这时进行了两次重复检查，并使用cas操作添加新的Segment</p>
<p>cas操作即比较交换操作，只有当ss[u]为null时，才进行赋值操作，否则将直接返回，而且操作是原子性的。这样就可以保证在并发的情况下，构造Segment的是安全的。</p>
<p><strong>Segment.put</strong></p>
<pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 加锁
    HashEntry&lt;K,V&gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&lt;K,V&gt;[] tab = table;
        // 计算元素所在数组下标
        int index = (tab.length - 1) &amp; hash;
        // 查询对应的HashEntry
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);

        for (HashEntry&lt;K,V&gt; e = first;;) {
            // 如果当前HashEntry不空，则遍历链表，如果hash相同的，则使用新值替换
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {    // 如果HashEntry为空,则创建新的HashEntry
                // 新HashEntry的next指向first
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                // 如果put元素后容量将超过临界值，则扩容
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        // 释放锁
        unlock();
    }
    return oldValue;
}
</code></pre><p>ConcurrentHashMap中的put操作，在Segment范围内进行了加锁操作，而ConcurrentHashMap中将根据并发度创建多个Segment（默认为16），put操作时如果put到不同的Segment，就不需要竞争锁了，可以提高操作速度。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><pre><code>private void rehash(HashEntry&lt;K,V&gt; node) {
    HashEntry&lt;K,V&gt;[] oldTable = table;
    int oldCapacity = oldTable.length;
    int newCapacity = oldCapacity &lt;&lt; 1;    // 容量翻倍
    threshold = (int)(newCapacity * loadFactor);    // 新扩容临界值
    HashEntry&lt;K,V&gt;[] newTable =
        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];    // 创建新数组
    int sizeMask = newCapacity - 1;
    // 遍历原数组，放到新数组中
    for (int i = 0; i &lt; oldCapacity ; i++) {    
        HashEntry&lt;K,V&gt; e = oldTable[i];
        if (e != null) {
            HashEntry&lt;K,V&gt; next = e.next;
            int idx = e.hash &amp; sizeMask;
            // 单一元素，直接移动
            if (next == null)   
                newTable[idx] = e;
            else {
                // 
                HashEntry&lt;K,V&gt; lastRun = e;
                int lastIdx = idx;
                for (HashEntry&lt;K,V&gt; last = next;
                     last != null;
                     last = last.next) {
                    int k = last.hash &amp; sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {
                    V v = p.value;
                    int h = p.hash;
                    int k = h &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n = newTable[k];
                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);
                }
            }
        }
    }
    int nodeIndex = node.hash &amp; sizeMask; // 添加新元素
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
}
</code></pre><p>由于HashEntry长度都是2的倍数，而且扩展都是翻倍扩展，所以在长度oldLen的数组第i位的元素，扩展后的位置只可以为i或oldLen+i，所以这时做了一个简单的优化，以免创建过多的元素。当一个HashEntry为数组时，找到最后一段下标不变的数组，直接放到新的位置，然后遍历前面的元素，创建新的元素并放到适当位置</p>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>调用size方法时，需要遍历所有的Segment，并且需要并发情况下保持Segment长度不变，下面看看实现：</p>
<ol>
<li><p>连续两次求所有Segment的modcount和， 如果相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p>
</li>
<li><p>如果两次和不相等，则需要对所有的Segment依次进行加锁，获取统一的值后再依次解锁。</p>
<pre><code>public int size() {
 // Try a few times to get accurate count. On failure due to
 // continuous async changes in table, resort to locking.
 final Segment&lt;K,V&gt;[] segments = this.segments;
 int size;
 boolean overflow; // true if size overflows 32 bits
 long sum;         // sum of modCounts
 long last = 0L;   // previous sum
 int retries = -1; // first iteration isn&#39;t retry
 try {
     for (;;) {
         if (retries++ == RETRIES_BEFORE_LOCK) {
             for (int j = 0; j &lt; segments.length; ++j)
                 ensureSegment(j).lock(); // force creation
         }
         sum = 0L;
         size = 0;
         overflow = false;
         for (int j = 0; j &lt; segments.length; ++j) {
             Segment&lt;K,V&gt; seg = segmentAt(segments, j);
             if (seg != null) {
                 sum += seg.modCount;
                 int c = seg.count;
                 if (c &lt; 0 || (size += c) &lt; 0)
                     overflow = true;
             }
         }
         if (sum == last)
             break;
         last = sum;
     }
 } finally {
     if (retries &gt; RETRIES_BEFORE_LOCK) {
         for (int j = 0; j &lt; segments.length; ++j)
             segmentAt(segments, j).unlock();
     }
 }
 return overflow ? Integer.MAX_VALUE : size;
}
</code></pre></li>
</ol>
<p>错误之处，还望指出</p>
<p>参考：<br><a href="http://www.jianshu.com/p/4806633fcc55" target="_blank" rel="external">Concurrency of ConcurrentHashMap</a><br><a href="http://www.jianshu.com/p/e694f1e868ec" target="_blank" rel="external">谈谈ConcurrentHashMap1.7和1.8的不同实现</a><br><a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java序列化过程简析]]></title>
      <url>https://binecy.coding.me/java-serializable/</url>
      <content type="html"><![CDATA[<p>文章通过一个简单的小栗子，简单分析了java序列化的过程</p>
<h2 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h2><pre><code>public class User implements Serializable{
    private static final long serialVersionUID = -8327620862083656937L;


    private String name;

    // getter and setter

}
</code></pre><p>序列化</p>
<pre><code>public void serialize() {
    User user = new User();
    user.setName(&quot;bin&quot;);
    FileOutputStream fileOut = new  FileOutputStream(&quot;user.ser&quot;);
    ObjectOutputStream out = new ObjectOutputStream(fileOut);
    out.writeObject(user);
    out.close();
    fileOut.close();
}
</code></pre><p>可以看到相对目录下生成了user.ser文件，内容如下<br><img src="/java-serializable/1.png" alt=""></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>简单记录一下该栗子中ObjectOutputStream生成文件的过程。</p>
<pre><code>public ObjectOutputStream(OutputStream out) ... {
    ...
    writeStreamHeader();    // 
}

protected void writeStreamHeader() ... {
    bout.writeShort(STREAM_MAGIC);    // 魔法数0xac ed
    bout.writeShort(STREAM_VERSION);    // 版本0x00 05
}
</code></pre><p>FileOutputStream.writeObject</p>
<pre><code>public final void writeObject(Object obj)... {
    ...
    writeObject0(obj, false);
}

private void writeObject0(Object obj, boolean unshared) {
    ...
    ObjectStreamClass desc;
    desc = ObjectStreamClass.lookup(cl, true);

    if (obj instanceof String) {
        writeString((String) obj, unshared);
    } else if (cl.isArray()) {
        writeArray(obj, desc, unshared);
    } else if (obj instanceof Enum) {
        writeEnum((Enum&lt;?&gt;) obj, desc, unshared);
    } else if (obj instanceof Serializable) { // 序列化对象必须实现Serializable接口
        writeOrdinaryObject(obj, desc, unshared);
    } else {
        ...
    }
}
</code></pre><p>ObjectStreamClass用于存储一些Class解析结果，如是否继承了Serializable， 是否为enum，字段信息等。<code>ObjectStreamClass.lookup</code>通过反射获取到这些方法，存储在ObjectStreamClass中。</p>
<pre><code>private void writeOrdinaryObject(Object obj,ObjectStreamClass desc,boolean unshared) {
    ...
    bout.writeByte(TC_OBJECT);    // new object标志:0x73            
    writeClassDesc(desc, false); // 记录class描述

    writeSerialData(obj, desc);    // 记录字段内容
}
</code></pre><h3 id="记录class描述"><a href="#记录class描述" class="headerlink" title="记录class描述"></a>记录class描述</h3><pre><code>private void writeClassDesc(ObjectStreamClass desc, boolean unshared) ... {
    int handle;
    if (desc == null) {
        writeNull();
    } else if (!unshared &amp;&amp; (handle = handles.lookup(desc)) != -1) {
        writeHandle(handle);
    } else if (desc.isProxy()) {
        writeProxyDesc(desc, unshared);
    } else {
        writeNonProxyDesc(desc, unshared);
    }
}

private void writeNonProxyDesc(ObjectStreamClass desc, boolean unshared) {
    bout.writeByte(TC_CLASSDESC);    // new Class Descriptor:0x72
    ...
    writeClassDescriptor(desc);    // class描述信息

    bout.writeByte(TC_ENDBLOCKDATA); // object结束标志:0x78

    writeClassDesc(desc.getSuperDesc(), false);    // 记录父类描述: 0x70

}

protected void writeClassDescriptor(ObjectStreamClass desc)
    throws IOException
{
    desc.writeNonProxy(this);
}

void writeNonProxy(ObjectOutputStream out) {
    // 记录class name:serialize.User (000E73657269616C697A652E55736572)
    out.writeUTF(name);    
    // 记录VersionUID(8C6E58F2935F1317)
    out.writeLong(getSerialVersionUID());    

    byte flags = 0;
    ... 
    out.writeByte(flags);    // 相关标志:0x02
    out.writeShort(fields.length);    // 0x0001

    // 记录所有字段的描述
    for (int i = 0; i &lt; fields.length; i++) {
            ObjectStreamField f = fields[i];
            out.writeByte(f.getTypeCode());    // L:4C
            // 字段名name:0004 6E 61 6D 65(0004是字节个数)
            out.writeUTF(f.getName());    
            if (!f.isPrimitive()) {
                // 字段描述Ljava/lang/String;
                //  74 0012 4C6A6176612F6C616E672F537472696E673B
                // 0x74为string标志 0x0012为字节个数
                out.writeTypeString(f.getTypeString());    
            }
        }

}
</code></pre><h3 id="记录字段内容"><a href="#记录字段内容" class="headerlink" title="记录字段内容"></a>记录字段内容</h3><pre><code>private void writeSerialData(Object obj, ObjectStreamClass desc) {
    if (slotDesc.hasWriteObjectMethod()) {
        slotDesc.invokeWriteObject(obj, this);
    } else {
        defaultWriteFields(obj, slotDesc);
    }    
}

private void defaultWriteFields(Object obj, ObjectStreamClass desc) {
    desc.getPrimFieldValues(obj, primVals);    // 原始数据，如int，double
    bout.write(primVals, 0, primDataSize, false);

    // 处理非原始对象，如String，数组，Object
    desc.getObjFieldValues(obj, objVals);    
    // 记录bin的字段值bin: 0003 62 69 6E
    writeObject0(objVals[i], fields[numPrimFields + i].isUnshared());    
}
</code></pre><p>需要注意的,<code>writeSerialData()</code>中,会通过<code>slotDesc.hasWriteObjectMethod()</code>检查被序列化的对象是否实现了签名为<code>private void writeObject(ObjectOutputStream out)</code>的方法， 如果有该方法，将直接调用该方法。该方法可以提供给用户自定义字段内容的存储格式，如密码的加密存储。</p>
<p>同样，ObjectInputStream.readObject时，也会检查反序列化对象是否实现了签名为<code>private void readObject(ObjectInputStream in)</code>的方法，如果有该方法， 将直接该方法反序列化。该方法可实现反序列化时单例的需求。</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[innodb中的锁]]></title>
      <url>https://binecy.coding.me/innodb-lock/</url>
      <content type="html"><![CDATA[<h2 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h2><blockquote>
<p>何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
</blockquote>
<p>通过行多版本控制（multi versioning）的方式来读取当前执行时间数据库中行的数据。如果读取的行正在执行delete或update操作，这时读取操作不会因此去等待行上锁的释放。相反，InnoDB存储引擎会读取行的一个快照数据。快照数据指该行的之前版本的数据，该实现是通过undo段来完成，而undo用来在事务中回滚数据，因此快照数据本身没有额外的开销。</p>
<p>每行记录可能有多个版本。</p>
<p>在read committed和repeatable read级别下，InnoDB存储引擎使用非锁定的一致性读。在read committed级别下，总是读取被锁定行的最新一份快照数据。而repeatable read级别下，读取事务开始时的行数据版本。</p>
<h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><h3 id="Shared-and-Exclusive-Locks"><a href="#Shared-and-Exclusive-Locks" class="headerlink" title="Shared and Exclusive Locks"></a>Shared and Exclusive Locks</h3><p>共享锁（S lock）：允许事务读一行数据<br>排他锁（X lock）：允许事务删除或更新一行数据</p>
<p>用户显式对数据库读取操作加锁以保证数据逻辑的一致性。<br>InnoDB存储引擎对于select语句支持两种一致性的锁定读操作：<br>select … for update<br>select … lock in share mode<br>select … for update对读取的行记录加一个X锁，其他事务不能对已锁定的行加任何锁。select … lock in share mode对读取的行记录加一个S锁，其他事务可以向被锁定的行S锁，但如果加X锁，则被阻塞。<br>上述两个语句必须在一个事务中，事务提交了，锁就释放了。</p>
<h3 id="Phantom-problem"><a href="#Phantom-problem" class="headerlink" title="Phantom problem"></a>Phantom problem</h3><p>Phantom problem（幻读）是指同一事务下，连续执行两次同样的sql语句可能导致不同的结果，每二次的sql语句可能返回之前不存在的行。</p>
<p>record lock:  单行记录上的锁<br>gap lock: 间隙锁，锁定一个范围，但不包含记录本身<br>next-key lock: gap lock+record lock,锁定一个范围，并且锁定记录本身。next-key lock是索引记录锁加上前一间隙上的间隙锁。</p>
<p>一个小栗子</p>
<pre><code>create table t(a int, b int, primary key(a), key(b));
insert into t select 1,1;
insert into t select 3,3;
insert into t select 5,5;
insert into t select 7,7;
insert into t select 9,9;
</code></pre><table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from t where a = 5 for update;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>insert into t select 4,4;(阻塞)</td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td>(insert成功)</td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>commit;</td>
</tr>
</tbody>
</table>
<p>可以看到，会话B中的insert语句将被阻塞。</p>
<p>sql语句通过索引列b进行查询，innodb将使用next-key locking技术加锁，innodb还会对辅助索引下一个键值加上gap lock。<br>在执行insert语句前，如<code>insert into t select 4,4;</code>,会检查b的间隙(3,5)这个区间是否存在gap锁，如果存在，则阻塞。<br>使用<code>SHOW ENGINE INNODB STATUS\G</code>查询状态，可以看到</p>
<pre><code>TRANSACTIONS
------------
Trx id counter 7454
Purge done for trx&#39;s n:o &lt; 7444 undo n:o &lt; 0 state: running but idle
History list length 21
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 7453, ACTIVE 6 sec inserting
mysql tables in use 1, locked 1
LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1
MySQL thread id 16, OS thread handle 5208, query id 115 localhost ::1 root executing
insert into t select 4,4
------- TRX HAS BEEN WAITING 6 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 39 page no 4 n bits 80 index b of table `hello`.`t` trx id 7453 lock_mode X locks gap before rec insert intention waiting
Record lock, heap no 4 PHYSICAL RECORD: n_fields 2; compact format; info bits 0
 0: len 4; hex 80000005; asc     ;;
 1: len 4; hex 80000005; asc     ;;
</code></pre><p>gap lock的作用是为了阻止多个事务将记录插入到同一范围，避免Phantom problem问题。在上一栗子中，会话A已经锁定了b=5的记录，如果没有gap lock锁定b间隙(3, 5),则插入记录[4, 5]成功，就会发生Phantom problem问题。</p>
<p>但在唯一索引上，next-key lock会降级为record lock。如锁住了a=5的记录，不需要a间隙(3, 5),因为a是唯一索引，不能再插入一个a=5的记录。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话A</th>
<th>会话B</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>begin;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>select * from t where a = 5 for update;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>begin;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>insert into t select 4,4;(不阻塞,成功)</td>
</tr>
<tr>
<td>5</td>
<td>commit;</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>commit;</td>
</tr>
</tbody>
</table>
<p>删除时也不能删除有行锁的记录。</p>
<p>innodb支持如下锁：</p>
<ul>
<li>Shared and Exclusive Locks    共享锁和排他锁</li>
<li>Intention Locks    意向锁</li>
<li>Record Locks    行锁</li>
<li>Gap Locks        间隙锁</li>
<li>Next-Key Locks    Next-Key锁</li>
<li>Insert Intention Locks    </li>
<li>AUTO-INC Locks </li>
</ul>
<p>详细可见：<a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html" target="_blank" rel="external">InnoDB Locking</a></p>
<p>写得比较简单，如有错误，还望指教。</p>
<p>参考：<br><a href="https://book.douban.com/subject/24708143/" target="_blank" rel="external">MySQL技术内幕</a><br><a href="http://hedengcheng.com/?p=771" target="_blank" rel="external">何登成的技术博客-MySQL 加锁处理分析</a></p>
]]></content>
      
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql索引]]></title>
      <url>https://binecy.coding.me/mysql-index/</url>
      <content type="html"><![CDATA[<p>MYSQL目前提供了一下4种索引。</p>
<ul>
<li>B-Tree 索引：最常见的索引类型，大部分引擎都支持B树索引。</li>
<li>HASH 索引：只有Memory引擎支持，使用场景简单。</li>
<li>R-Tree 索引(空间索引)：空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型。</li>
<li>Full-text (全文索引)：全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li>
</ul>
<p>下面简单记录一下innodb中的索引，主要来自<a href="https://book.douban.com/subject/24708143/" target="_blank" rel="external">MySQL技术内幕</a>。</p>
<h2 id="聚集索引（clustered-index）"><a href="#聚集索引（clustered-index）" class="headerlink" title="聚集索引（clustered index）"></a>聚集索引（clustered index）</h2><p>InnoDb存储引擎表是索引组织表，即表中数据按照主键顺序存放。<br>聚集索引就是按照每张表的主键构造一个B+树，同时叶子节点中存放行记录数据（叶子节点也称数据页）。聚集索引这个特性决定索引组织表中数据也是索引的一部分。</p>
<p>非数据页存放键值和指向数据页的偏移量。</p>
<p>每个数据页通过一个双向链表进行链接。<br>每个表只能拥有一个聚集索引。</p>
<h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><p><strong>非聚集索引（Secondary Index）</strong><br>叶子节点并不包含行记录的全部数据。叶子节点除了包含键值以外，还包含一个书签（bookmark）。该书签用来告诉InnoDb存储引擎哪里可以找到与索引相对应的行数据。实际上就是相应行数据的聚集索引键。</p>
<p>当通过辅助索引索引来寻找数据时，InnoDD存储引擎会遍历索引并通过叶级别的指针获得指向主键索引的主键，然后再通过主键来找到一个完整的行记录。比如在一个高度为3的辅助索引树中查找数据，需要对这棵辅助索引树遍历3次找到指定主键，如果聚集索引树高度同样为3，还需要对聚集索引树进行3次查找，最终找到一个完整的行数据所在页。</p>
<p><strong>唯一索引</strong><br>表示唯一的，不允许重复的索引，如果该字段信息保证不会重复例如身份证号用作索引时，可设置为unique</p>
<p><strong>联合索引</strong><br>对表上多个列进行索引。<br>联合索引也是一棵B+树，但联合索引的键值所索引列的值。</p>
<pre><code>create table t (
    a int,
    b int,
    primary key (a),
    key idx_a_b (a, b)
)
</code></pre><p><img src="/mysql-index/1.png" alt=""></p>
<p>从上图，可以看到键值都是排序的。即(1, 1),(1, 2),(2, 1), (2, 4), (3, 1), (3, 2)。索引按(a, b) 的顺序进行存放。</p>
<p><code>select * from table where a=XXX and b=XXX</code> 可以使用联合索引，<br><code>select * from table where a=XXX</code> 也可以。<br><code>select * from table where  b=XXX</code> 不能使用联合索引。因为叶子节点的b值为1,2,1,4,1,2，是不排序。</p>
<p><strong>聚集索引和辅助索引都是B-Tree 索引</strong></p>
<h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>InnoDb存储引擎会监控对表上各索引页的查询。如果观察到建立哈希索引可以提升速度，则建立哈希索引。<br>自适应哈希索引是InnoDB存储引擎自己控制的。无法干预。</p>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>全文索引通过将文档进行分词，并在辅助表中存储单词与单词自身所在一个或多个文档所在位置之间的映射来进行索引。</p>
<p>非dba， 写得比较简单</p>
<p>一些优秀的博文：<br><a href="https://segmentfault.com/a/1190000003072424#articleHeader3" target="_blank" rel="external">MYSQL-索引</a><br><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">MySQL索引背后的数据结构及算法原理</a><br><a href="http://tech.meituan.com/mysql-index.html" target="_blank" rel="external">MySQL索引原理及慢查询优化</a> - 推荐</p>
]]></content>
      
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jvm字节码执行]]></title>
      <url>https://binecy.coding.me/jvm-byteCode/</url>
      <content type="html"><![CDATA[<h2 id="栈桢"><a href="#栈桢" class="headerlink" title="栈桢"></a>栈桢</h2><p>Java虚拟机栈是线程运行时的数据结构。而栈桢（Stack Frame）是虚拟机栈的栈元素，用于支持虚拟机进行方法调用和执行。一个方法开始执行时，jvm都会创建一个栈桢并添加到虚拟机栈顶，而方法执行完成或抛出异常后将移除该栈桢。<br>每一个栈桢都包含如下元素：  </p>
<ul>
<li>局部变量表</li>
<li>方法返回地址</li>
<li>操作数栈</li>
<li>动态连接</li>
</ul>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表是一组变量值存储空间，包含了在方法执行时使用的所有的变量。包括<code>this</code>，所有的方法参数和方法内定义的局部变量。编译期间，局部变量表的最大容量就已经确定，存储在Class文件中方法的Code属性的max_locals数据项中。</p>
<p>局部变量与数组类似，通过索引来寻址。第一个局部变量的索引为零。实例方法中，第0个局部变量是<code>this</code></p>
<p>单个局部变量空间可以保存boolean，byte，char，short，int，float，reference或returnAddress类型的值。而long类型或double类型的值将占用两个连续的局部变量空间。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈是一个后入先出栈。编译期间，操作数栈的最大深度也确定，存储在Class文件中方法的Code属性的max_stacks数据项中。<br>执行字节码时，会不断操作数栈，类似于本地cpu使用通用寄存器。<br>操作数栈是一个后入先出栈。大多数JVM字节代码通过push, pop, duplicate, swap，执行产生或消耗值的操作来操作操作数。因此，在字节代码中非常频繁地在局部变量数组和操作数堆栈之间移动值。 例如，简单的变量初始化导致与操作数栈交互的两个字节代码。<br><code>int i = 0;</code><br>该代码将会被编译为如下byte code：</p>
<pre><code> 0:    iconst_0    // Push 0 to top of the operand stack
 1:    istore_1    // Pop value from top of operand stack and store as local variable 1
</code></pre><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法退出后，都需要回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用于帮助恢复它的上层方法的执行状态。一般，方法正常退出，调用者的PC计数器的值可以作为返回地址，栈帧中很可能保存这种值。而方法异常退出时，返回地址是通过异常处理器确定的，栈帧一般不会保存这部分信息。<br>方法退出的过程实际是等于把当前栈帧出栈，因些退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>C/C ++代码通常编译为object文件，然后将多个object文件链接在一起，产生可用文件，如exe或dll。在链接阶段期间，每个目标文件中的符号引用被替换为实际存储器地址。 但在Java中，这个链接阶段可以在编译或运行时完成。  </p>
<p>当编译Java类时，变量和方法引用都作为符号引用存储在类的常量池中。符号引用是逻辑引用，而不是指向实际物理内存位置的直接引用。JVM实现可以选择何时解析符号引用，它可以发生在类加载后的类文件验证期间（静态解析），或符号引用第一次使用时（延迟解析）。<br>除了invokedynamic指令外，虚拟机会对符号引用第一次解析结果进行缓存，以后的引用可以直接使用缓存的结果 。</p>
<h2 id="解析-分派"><a href="#解析-分派" class="headerlink" title="解析/分派"></a>解析/分派</h2><p>Java虚拟机中提供了5条方法调用字节码指令：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用实例构造器<init>方法，私有方法和父类方法</init></li>
<li>invokevirtual：调用所有的虚方法</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现该接口的对象。  </li>
<li>invokedynamic: 先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ul>
<h3 id="静态解析"><a href="#静态解析" class="headerlink" title="静态解析"></a>静态解析</h3><p>在类加载的解析阶段，会将一部分符号引用转化为直接引用，这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期不可改变。也就是，调用目标在程序代码写好，编译器进行编译时必须确定下来。主要包括静态方法和私有方法两大类。静态方法与类型直接关联，私有方法在外部不可访问。它们不可能通过继承或重写其他版本。<br>只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段确定唯一的调用版本，包括静态方法，私有方法，实例构造器，父类方法，它们在类加载时间就会把符号引用解析为该方法的直接引用。这些方法称为非虚方法。其他方法则为虚方法。而final方法虽然使用invokevirtual，但它无法被覆盖，也是一种非虚方法。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>一个小栗子</p>
<pre><code>public class Dispatch {
    public void printTime(java.util.Date date) {
        System.out.println(&quot;date : &quot; + date.toString());
    }

    public  void printTime(java.sql.Time time) {
        System.out.println(&quot;time : &quot; + time.toString());
    }

    public static void main(String[] args) {
        Dispatch dispatch = new Dispatch();
        java.util.Date date = new java.util.Date();
        java.util.Date time = new java.sql.Time(date.getTime());
        dispatch.printTime(date);
        dispatch.printTime(time);
    }
}
</code></pre><p>输入结果：</p>
<pre><code>date : Thu Jan 12 10:57:22 GMT+08:00 2017
date : 10:57:22
</code></pre><p>我们都知道，java.sql.Time time继承了java.util.Date。可以看到，上述代码中两次<code>printTime</code>都调用了重载方法<code>printTime(java.util.Date date)</code>, 而方法中<code>date.toString()</code>则分别调用到<code>Date.toString()</code>和<code>Time.toString()</code>方法。</p>
<p>在<code>java.util.Date time = new java.sql.Time(date.getTime());</code>这个变量定义语句中，java.util.Date为变量的<strong>静态类型</strong>或外观类型，而java.sql.Time为变量的<strong>实际类型</strong>。变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知。而实际类型在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<p><strong>因为静态类型是编译期可知的，虚拟机（准确来说是编译器）在重载时通过参数的静态类型而不是实际类型作为判定依据的，来决定使用哪个重载方法。这是静态分派。</strong><br><strong>而对于重写方法的调用，虚拟机需要在运行期间确认调用者的实际类型，如果实际类型中找不到方法定义，则按继承关系从下往上对其父类进行查找。这是动态分派。</strong></p>
<p>通过<code>javap -v Dispatch.class</code>可以查看class中方法字节码，可以看到main方法中如下代码</p>
<pre><code>        dispatch.printTime(date);
        dispatch.printTime(time);
</code></pre><p>被编译为如下字节码</p>
<pre><code>aload_1        
aload_2
invokevirtual #19                 // Method printTime:(Ljava/util/Date;)V
aload_1
aload_3
invokevirtual #19                 // Method printTime:(Ljava/util/Date;)V
return
</code></pre><p>可以看到，编译期间，已经决定了这两行代码将调用重载方法<code>printTime(java.util.Date date)</code>。</p>
<p>而<code>printTime(java.util.Date date)</code>方法中的<code>date.toString()</code>调用将编译为如下字节码：</p>
<pre><code>aload_1
invokevirtual #7                  // Method java/util/Date.toString:()Ljava/lang/String;
</code></pre><p>invokevirtual指令执行时会先确定接收者的实际类型，所以两次调用invokevirtual指令会将把常量池方法符号引用解析到了不同的直接引用。</p>
<h2 id="字节码执行"><a href="#字节码执行" class="headerlink" title="字节码执行"></a>字节码执行</h2><p>java编译器输入的指令流，基本上是一种基于栈的指令集架构，指令流中指令大部分都是零地址指令，它们依赖操作数栈进行工作。<br>一个坏味道的小栗子</p>
<pre><code>public class FinallyDemo {

    public static int getVal() {
        int i = 0;
        try {
            i = i + 1;
            return i;
        } finally {
            i = 2;
        }
    }

    public static void main(String[] args) {
        System.out.println(getVal());
    }
}
</code></pre><p>上述代码中finally的语句是一定执行的，也就是i会被赋值为2，但程序最终输出结果是1。</p>
<p>通过javap解析class文件，查看到getVal方法解析结果如下：</p>
<pre><code>  public static int getVal();
    descriptor: ()I        // 方法描述
    flags: ACC_PUBLIC, ACC_STATIC    // 方法标识:public 
    Code:    // 字节码
      stack=2, locals=3, args_size=0    // 操作数栈深度为2, 局部变量容量为3 方法个数为0
         0: iconst_0    // push一个int常量（0）到操作栈顶
         1: istore_0    // 将操作栈顶int值存到第0个索引的局部变量(int i = 0;)
         2: iload_0        // 将第0个索引的局部变量加载到操作栈顶
         3: iconst_1    // push一个int常量（1）到操作栈顶
         4: iadd        // 从操作栈中pop出两个int值,执行add,并将结果push到操作栈顶
         5: istore_0    // 将操作栈顶int值存到第0个索引的局部变量(i = i + 1;)
         6: iload_0        // 将第0个索引的局部变量加载到操作栈顶
         7: istore_1    // 将操作栈顶int值存到第1个索引的局部变量(这里将i的值复制了一份存到第1个索引的局部变量)
         8: iconst_2    // push一个int常量（2）到操作栈顶
         9: istore_0    // 将操作栈顶int值存到第0个索引的局部变量(i = 2;)
        10: iload_1        // 将第1个索引的局部变量加载到操作栈顶
        11: ireturn        // pop操作栈顶的int值,并将其推入调用器的帧的操作数栈。(返回第1个索引的局部变量的值)
        12: astore_2    // 将异常reference存到第2个索引的局部变量(开始异常处理了)
        13: iconst_2    // push一个int常量（2）到操作栈顶
        14: istore_0    // 将操作栈顶int值存到第0个索引的局部变量(i = 2;)
        15: aload_2        // 将第2个索引的局部变量加载到操作栈顶
        16: athrow        // 通过athrow退出
      Exception table:    // 异常表
         from    to  target type        
             2     8    12   any    // 在#2到#7发生的所有异常，都跳转到#12开始处理。
      LineNumberTable:
        line 8: 0
        line 10: 2
        line 11: 6
        line 13: 8
        line 11: 10
        line 13: 12
      StackMapTable: number_of_entries = 1
        frame_type = 255 /* full_frame */
          offset_delta = 12
          locals = [ int ]
          stack = [ class java/lang/Throwable ]
</code></pre><p>可以看到finally 中的语句<code>i = 2;</code>被编译成了两份字节码，一份在正常执行的流程中，另一份在异常处理的流程，这样保证了无论是正常执行还是抛出异常，都能执行finally 中的语句。</p>
<pre><code>         6: iload_0        // 将第0个索引的局部变量加载到操作栈顶
         7: istore_1    // 将操作栈顶int值存到第1个索引的局部变量(这里将i的值复制了一份存到第1个索引的局部变量)
         8: iconst_2    // push一个int常量（2）到操作栈顶
         ...
         10: iload_1        // 将第1个索引的局部变量加载到操作栈顶
         11: ireturn        // pop操作栈顶的int值,并将其推入调用器的帧的操作数栈。(返回第1个索引的局部变量的值)
</code></pre><p>在上面代码中，可以看到jvm将i的值复制了一份，存放到另一个变量中，最后该变量的值返回,所以上面例子中最后返回的值是1。</p>
<p>错漏之处，还望指教。</p>
<p>参考：<br><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机（第2版）</a><br><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="external">The Java Virtual Machine Instruction Set </a></p>
]]></content>
      
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java nio知识整理]]></title>
      <url>https://binecy.coding.me/java-nio/</url>
      <content type="html"><![CDATA[<p>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</p>
<h2 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h2><p>服务端</p>
<pre><code>import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.util.Iterator;

public class TCPServer {
    //缓冲区的长度
    private static final int BUF_SIZE = 256;
    //select方法等待信道准备好的最长时间
    private static final int TIMEOUT = 3000;

    public static void main(String[] args) throws IOException {

        //创建一个选择器
        Selector selector = Selector.open();

        //实例化一个信道
        ServerSocketChannel listenChannel = ServerSocketChannel.open();
        //将该信道绑定到指定端口
        listenChannel.socket().bind(new InetSocketAddress(8881));
        //配置信道为非阻塞模式
        listenChannel.configureBlocking(false);
        //将选择器注册到各个信道
        listenChannel.register(selector, SelectionKey.OP_ACCEPT);

        //创建一个实现了协议接口的对象
        EchoProtocol protocol = new EchoProtocol(BUF_SIZE);
        //不断轮询select方法，获取准备好的信道所关联的Key集
        while (true){
            //一直等待,直至有信道准备好了I/O操作
            if (selector.select(TIMEOUT) == 0){
                //在等待信道准备的同时，也可以异步地执行其他任务，
                //这里只是简单地打印&quot;.&quot;
                System.out.print(&quot;.&quot;);
                continue;
            }
            //获取准备好的信道所关联的Key集合的iterator实例
            Iterator&lt;SelectionKey&gt; keyIter = selector.selectedKeys().iterator();
            //循环取得集合中的每个键值
            while (keyIter.hasNext()){
                SelectionKey key = keyIter.next();
                //如果服务端信道感兴趣的I/O操作为accept
                if (key.isAcceptable()){
                    protocol.handleAccept(key);
                }
                //如果客户端信道感兴趣的I/O操作为read
                if (key.isReadable()){
                    protocol.handleRead(key);
                }
                //如果该键值有效，并且其对应的客户端信道感兴趣的I/O操作为write
                if (key.isValid() &amp;&amp; key.isWritable()) {
                    protocol.handleWrite(key);
                }
                //这里需要手动从键集中移除当前的key
                keyIter.remove();
            }
        }
    }
}
</code></pre><p>实例简单的echo服务</p>
<pre><code>import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;

public class EchoProtocol  {
    private int bufSize; // 缓冲区的长度
    public EchoProtocol(int bufSize){
        this.bufSize = bufSize;
    }

    //服务端信道已经准备好了接收新的客户端连接
    public void handleAccept(SelectionKey key) throws IOException {
        SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
        clientChannel.configureBlocking(false);
        //将选择器注册到连接到的客户端信道，并指定该信道key值的属性为OP_READ，同时为该信道指定关联的附件
        clientChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(bufSize));
    }

    //客户端信道已经准备好了从信道中读取数据到缓冲区
    public void handleRead(SelectionKey key) throws IOException{
        SocketChannel clientChannel = (SocketChannel) key.channel();
        //获取该信道所关联的附件，这里为缓冲区
        ByteBuffer buf = (ByteBuffer) key.attachment();
        long bytesRead = clientChannel.read(buf);
        //如果read（）方法返回-1，说明客户端关闭了连接，那么客户端已经接收到了与自己发送字节数相等的数据，可以安全地关闭
        if (bytesRead == -1){
            clientChannel.close();
        }else if(bytesRead &gt; 0){
            //如果缓冲区总读入了数据，则将该信道感兴趣的操作设置为为可读可写
            key.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
        }
    }

    //客户端信道已经准备好了将数据从缓冲区写入信道
    public void handleWrite(SelectionKey key) throws IOException {
        //获取与该信道关联的缓冲区，里面有之前读取到的数据
        ByteBuffer buf = (ByteBuffer) key.attachment();
        //重置缓冲区，准备将数据写入信道
        buf.flip();
        SocketChannel clientChannel = (SocketChannel) key.channel();
        //将数据写入到信道中
        clientChannel.write(buf);
        if (!buf.hasRemaining()){
            //如果缓冲区中的数据已经全部写入了信道，则将该信道感兴趣的操作设置为可读
            key.interestOps(SelectionKey.OP_READ);
        }
        //为读入更多的数据腾出空间
        buf.compact();
    }
}
</code></pre><p>客户端</p>
<pre><code>import java.net.InetSocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.channels.SocketChannel;

public class TCPClient {
    public static void main(String args[]) throws Exception{
        String server = &quot;127.0.0.1&quot;;
        int serverPort = 8881;
        byte[] sendBytes = &quot;hello&quot;.getBytes();

        //创建一个信道，并设为非阻塞模式
        SocketChannel clientChannel = SocketChannel.open();
        clientChannel.configureBlocking(false);
        //向服务端发起连接
        if (!clientChannel.connect(new InetSocketAddress(server, serverPort))){
            //不断地轮询连接状态，直到完成连接
            while (!clientChannel.finishConnect()){
                //在等待连接的时间里，可以执行其他任务，以充分发挥非阻塞IO的异步特性
                //这里为了演示该方法的使用，只是一直打印&quot;.&quot;
                System.out.print(&quot;.&quot;);
            }
        }
        //为了与后面打印的&quot;.&quot;区别开来，这里输出换行符
        System.out.print(&quot;\n&quot;);
        //分别实例化用来读写的缓冲区
        ByteBuffer writeBuf = ByteBuffer.wrap(sendBytes);
        ByteBuffer readBuf = ByteBuffer.allocate(sendBytes.length);
        //接收到的总的字节数
        int totalBytesReceived = 0;
        //每一次调用read（）方法接收到的字节数
        int bytesReceived;
        //循环执行，直到接收到的字节数与发送的字符串的字节数相等
        while (totalBytesReceived &lt; sendBytes.length){
            //如果用来向通道中写数据的缓冲区中还有剩余的字节，则继续将数据写入信道
            if (writeBuf.hasRemaining()){
                clientChannel.write(writeBuf);
            }
            //如果read（）接收到-1，表明服务端关闭，抛出异常
            if ((bytesReceived = clientChannel.read(readBuf)) == -1){
                throw new SocketException(&quot;Connection closed prematurely&quot;);
            }
            //计算接收到的总字节数
            totalBytesReceived += bytesReceived;
            //在等待通信完成的过程中，程序可以执行其他任务，以体现非阻塞IO的异步特性
            //这里为了演示该方法的使用，同样只是一直打印&quot;.&quot;
            System.out.print(&quot;.&quot;);
        }
        //打印出接收到的数据
        System.out.println(&quot;Received: &quot; +  new String(readBuf.array(), 0, totalBytesReceived));
        //关闭信道
        clientChannel.close();
    }
}
</code></pre><h2 id="NIO优势"><a href="#NIO优势" class="headerlink" title="NIO优势"></a>NIO优势</h2><p>下图是几种常见I/O模型的对比：<br><img src="/java-nio/1.png" alt=""><br>所有的系统I/O都分为两个阶段：等待就绪和操作。例如，读函数，分为等待系统可读和真正的读；同理，写函数分为等待网卡可以写和真正的写。</p>
<p>等待就绪的阻塞是不使用CPU的，是在“空等”；而真正的读写操作的阻塞是使用CPU的，真正在”干活”，而且这个过程非常快，属于memory copy，带宽通常在1GB/s级别以上，可以理解为基本不耗时。<br>以socket.read()为例子：</p>
<p>传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，进程会一直阻塞，直到收到数据，返回读到的数据。</p>
<p>而对于NIO，即上图的io复用，需要使用selector角色。一个selector角色可以负责多个socket。当用户进程调用了selector.select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。<br><img src="/java-nio/2.png" alt=""></p>
<blockquote>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
</blockquote>
<p>select，poll，epoll都是IO多路复用的机制。它们本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写 </p>
<p>最新的AIO(Async I/O)则更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。它不需要应用过程负责读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p>
<h2 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h2><p>为了提高并发量，nio常与多线程结合使用。reactor是事件通知机制，有助于优雅地使用nio和多线程。</p>
<p>reactor模式中定义了reactor角色，它不断等待和循环，接收系统IO就绪事件，IO就绪后就将IO事件分派给指定handler进行处理。</p>
<p>标准/典型的Reactor：<br>步骤1：等待事件到来（Reactor负责）。<br>步骤2：将读就绪事件分发给用户定义的处理器（Reactor负责）。<br>步骤3：读数据（用户处理器负责）。<br>步骤4：处理数据（用户处理器负责）。</p>
<p><img src="/java-nio/3.png" alt=""><br>reactor</p>
<pre><code>import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Set;

public class Reactor implements Runnable{
    final Selector selector;
    final ServerSocketChannel serverSocket;

    public static void main(String[] args) throws IOException {
        Reactor reactor = new Reactor(8881);
        new Thread(reactor).start();
        System.out.println(&quot;server start...&quot;);
    }

    Reactor(int port) throws IOException {
        selector = Selector.open();
        serverSocket = ServerSocketChannel.open();
        serverSocket.socket().bind(new InetSocketAddress(port));
        serverSocket.configureBlocking(false);
        SelectionKey sk = serverSocket.register(selector, SelectionKey.OP_ACCEPT);
        sk.attach(new Acceptor());
    }

    public void run() {  // normally in a new Thread    事件分派
        try {
            while (!Thread.interrupted()) {
                selector.select();
                Set selected = selector.selectedKeys();
                Iterator it = selected.iterator();
                while (it.hasNext())
                    dispatch((SelectionKey)(it.next()));
                selected.clear();
            }
        } catch (IOException ex) { ex.printStackTrace(); }
    }

    void dispatch(SelectionKey k) {
        Runnable r = (Runnable)(k.attachment());
        if (r != null)
            r.run();
    }

    class  Acceptor  implements Runnable {
        public void run() {
            try {
                SocketChannel c = serverSocket.accept();
                if (c != null)
                    new Handler(selector, c);
            }
            catch(IOException ex) { ex.printStackTrace(); }
        }
    }
}
</code></pre><p>Handler</p>
<pre><code>import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;

public class Handler implements Runnable {
    private static  final  int MAXIN = 1024;

    final SocketChannel socket;
    final SelectionKey sk;
    ByteBuffer input = ByteBuffer.allocate(MAXIN);

    static final int READING = 0, SENDING = 1;
    int state = READING;

    Handler(Selector sel , SocketChannel c) throws IOException {
        socket = c; c.configureBlocking(false);
        // Optionally try first read now
        sk = socket.register(sel, 0);
        sk.interestOps(SelectionKey.OP_READ);

        sk.attach(this);
        sel.wakeup();
    }

    boolean inputIsComplete()  {  return true; }
    boolean outputIsComplete() {  return true; }
    void process()             { /* ... */
        input.flip();
    }

    // class Handler continued
    public void run() {
        try {
            if (state == READING)
                read();
            else if (state == SENDING)
                send();
        } catch (IOException ex) { ex.printStackTrace(); }
    }

    void read() throws IOException {
        socket.read(input);
        if (inputIsComplete()) {
            process();
            state = SENDING ;
            // Normally also do first write now
            sk.interestOps(SelectionKey.OP_WRITE);
        }
    }
    void send() throws IOException {
        socket.write(input);
        if (outputIsComplete())
            sk.cancel();
    }
}
</code></pre><p>上述代码仍然存在问题，每个IO事件处理都创建了一个线程，线程的创建和销毁都极耗费cpu，所以这里应用使用线程池。<br>更多Reactor模式请参考Doug Lea的<a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="external">《Scalable IO in Java》</a></p>
<p>参考：<br><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="external">Linux IO模式及 select、poll、epoll详解</a><br><a href="http://tech.meituan.com/nio.html" target="_blank" rel="external">Java NIO浅析</a><br><a href="http://www.codeceo.com/article/java-nio-nodejs.html" target="_blank" rel="external">支撑 Java NIO 与 NodeJS 的底层技术</a><br><a href="http://www.importnew.com/20188.html" target="_blank" rel="external">【Java TCP/IP Socket】基于NIO的TCP通信（含代码）</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper入门]]></title>
      <url>https://binecy.coding.me/zookeeper-first/</url>
      <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.<a href="http://zookeeper.apache.org/" target="_blank" rel="external">官网</a>下载，解压</p>
<pre><code># wget -c http://mirrors.cnnic.cn/apache/zookeeper/stable/zookeeper-3.4.9.tar.gz
# tar -xvz -f zookeeper-3.4.9.tar.gz
# cd zookeeper-3.4.9
</code></pre><p>我下载的是最新的稳定版本3.4.9</p>
<p>2.添加配置<br>conf目录下默认提供了一个简单的配置文件zoo_sample.cfg作为参考<br>创建文件conf/zoo.cfg，内容为</p>
<pre><code>tickTime=2000
initLimit=10
syncLimit=5
dataDir=/usr/local/my/zookeeper-3.4.9/serviceData
clientPort=2181
</code></pre><p>注意先创建dataDir</p>
<p>3.启动</p>
<pre><code># bin/zkServer.sh start
# jps
5156 QuorumPeerMain
6120 Jps
</code></pre><p>默认将使用conf/zoo.cfg作为配置文件启动zookeeper。<br>jps可以看到QuorumPeerMain进程正在运行。</p>
<p>4.连接<br>zkCli是zookeeper提供的客户端。</p>
<pre><code># bin/zkCli.sh -server 127.0.0.1:2181
[zk: 127.0.0.1:2181(CONNECTED) 1] ls /
[zookeeper]
[zk: 127.0.0.1:2181(CONNECTED) 2] quit    
#
</code></pre><p>5.关闭</p>
<pre><code># bin/zkServer.sh stop
ZooKeeper JMX enabled by default
Using config: /usr/local/my/zookeeper-3.4.9/bin/../conf/zoo.cfg
Stopping zookeeper ... STOPPED
</code></pre><h2 id="单机伪集群配置"><a href="#单机伪集群配置" class="headerlink" title="单机伪集群配置"></a>单机伪集群配置</h2><p>1.创建dataDir：server0和server1，这两个目录下创建myid文件，内容分别为0,1</p>
<pre><code># cat server0/myid
0
# cat server1/myid
1
</code></pre><p>myid中的数字表示服务器id</p>
<p>2.创建两个配置文件conf/zoo0.cfg和conf/zoo1.cfg，内容为</p>
<pre><code>#conf/zoo0.cfg
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/usr/local/my/zookeeper-3.4.9/server0
clientPort=2180

server.0=127.0.0.1:2880:3880
server.1=127.0.0.1:2881:3881

#conf/zoo1.cfg
tickTime=2000
initLimit=10
syncLimit=5
dataDir=/usr/local/my/zookeeper-3.4.9/server1
clientPort=2181

server.0=127.0.0.1:2880:3880
server.1=127.0.0.1:2881:3881
</code></pre><p>server.A=B：C：D:其中 A 是一个数字，就是myid里的那个数字，表示这个是第几号服务器；B 是这个服务器的 ip 地址,C和D是两个端口。</p>
<p>两个端口的作用，官网描述如下：</p>
<blockquote>
<p>Finally, note the two port numbers after each server name: “ 2888” and “3888”. Peers use the former port to connect to other peers. Such a connection is necessary so that peers can communicate, for example, to agree upon the order of updates. More specifically, a ZooKeeper server uses this port to connect followers to the leader. When a new leader arises, a follower opens a TCP connection to the leader using this port. Because the default leader election also uses TCP, we currently require another port for leader election. This is the second port in the server entry.</p>
</blockquote>
<p>简单来说，第一个端口用来集群成员的信息交换以及与集群中的Leader 服务器交换信息，第二个端口是在leader挂掉时专门用来进行选举leader所用。</p>
<p>因为是伪分布式，所以dataDir,clientPort也不一样，同时C,D两个端口也不能相同。</p>
<p>3.启动</p>
<pre><code># bin/zkServer.sh start zoo0.cfg
# bin/zkServer.sh start zoo1.cfg
# jps
17759 Jps
17701 QuorumPeerMain
17664 QuorumPeerMain
</code></pre><p>可以看到两个QuorumPeerMain进程进行运行</p>
<p>4.查看节点状态</p>
<pre><code># bin/zkServer.sh status zoo0.cfg
ZooKeeper JMX enabled by default
Using config: /usr/local/my/zookeeper-3.4.9/bin/../conf/zoo0.cfg
Mode: follower
# bin/zkServer.sh status zoo1.cfg
ZooKeeper JMX enabled by default
Using config: /usr/local/my/zookeeper-3.4.9/bin/../conf/zoo1.cfg
Mode: leader
</code></pre><p>5.同步操作</p>
<pre><code># bin/zkCli.sh -server 127.0.0.1:2180
[zk: 127.0.0.1:2180(CONNECTED) 0] ls /
[zookeeper]
[zk: 127.0.0.1:2180(CONNECTED) 1] ls
[zk: 127.0.0.1:2180(CONNECTED) 2] create /hello &quot;hello&quot;
Created /hello
[zk: 127.0.0.1:2180(CONNECTED) 3] ls /
[hello, zookeeper]
[zk: 127.0.0.1:2180(CONNECTED) 4] quit
Quitting...
# bin/zkCli.sh -server 127.0.0.1:2181
[zk: 127.0.0.1:2181(CONNECTED) 0] ls /
[hello, zookeeper]
</code></pre><p>可以看到zookeeper主从同步成功了。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>ZooKeeper 支持某些特定的命令与linux进行交互。它们大多是查询命令，用来获取 ZooKeeper 服务的当前状态及相关信息。</p>
<table>
<thead>
<tr>
<th>ZooKeeper 四字命令</th>
<th>功能描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td>conf</td>
<td>输出相关服务配置的详细信息。</td>
</tr>
<tr>
<td>cons</td>
<td>列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。包括“接受 / 发送”的包数量、会话 id 、操作延迟、最后的操作执行等等信息。</td>
</tr>
<tr>
<td>dump</td>
<td>列出未经处理的会话和临时节点。</td>
</tr>
<tr>
<td>envi</td>
<td>输出关于服务环境的详细信息（区别于 conf 命令）。</td>
</tr>
<tr>
<td>reqs</td>
<td>列出未经处理的请求</td>
</tr>
<tr>
<td>ruok</td>
<td>测试服务是否处于正确状态。如果确实如此，那么服务返回“ imok ”，否则不做任何相应。</td>
</tr>
<tr>
<td>stat</td>
<td>输出关于性能和连接的客户端的列表。</td>
</tr>
<tr>
<td>wchs</td>
<td>列出服务器 watch 的详细信息。</td>
</tr>
<tr>
<td>wchc</td>
<td>通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表。</td>
</tr>
<tr>
<td>wchp</td>
<td>通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径。</td>
</tr>
</tbody>
</table>
<pre><code>$ echo conf | nc 127.0.0.1 2181
clientPort=2181
dataDir=/usr/local/my/zookeeper-3.4.9/server1/version-2
dataLogDir=/usr/local/my/zookeeper-3.4.9/server1/version-2
tickTime=2000
maxClientCnxns=60
minSessionTimeout=4000
maxSessionTimeout=40000
serverId=1
initLimit=10
syncLimit=5
electionAlg=3
electionPort=3881
quorumPort=2881
peerType=0
</code></pre><p>zkCli客户端也提供了丰富的操作命令</p>
<pre><code>$ bin\zkCli.sh -server 127.0.0.1:2181
[zk: 127.0.0.1:2181(CONNECTED) 1] help
ZooKeeper -server host:port cmd args
        stat path [watch]    # 获取znode属性，并且监听其是否存在
        set path data [version]    # 设置znode数据
        ls path [watch] # 查看子znode
        delquota [-n|-b] path # 删除quota设置
        ls2 path [watch] # 查看znode详细信息
        setAcl path acl    # 设置权限
        setquota -n|-b val path    # 设置quota配置
        history    # 查看历史
        redo cmdno    # 重做命令
        printwatches on|off    # 
        delete path [version] #删除znode
        sync path # 同步znode
        listquota path    
        rmr path # 递归删除节点及子znode
        get path [watch] # 
        create [-s] [-e] path data acl    # 创建znode
        addauth scheme auth    # 
        quit
        getAcl path
        close
        connect host:port
</code></pre><p>使用get可以查看node详细信息</p>
<pre><code>[zk: localhost:2181(CONNECTED) 1] get /zookeeper

cZxid = 0x0    # 节点创建时的zxid
ctime = Thu Jan 01 08:00:00 GMT+08:00 1970    # 节点创建时的时间戳
mZxid = 0x0    # 节点最新一次更新发生时的zxid    
mtime = Thu Jan 01 08:00:00 GMT+08:00 1970    # 节点最新一次更新发生时的时间戳
pZxid = 0x0
cversion = -1    # 子版本号
dataVersion = 0       # 数据版本号
aclVersion = 0    # 权限版本号
ephemeralOwner = 0x0    # 如果该节点为ephemeral节点, ephemeralOwner值表示与该节点绑定的session id. 否则, 该值为0
dataLength = 0    # 节点数据的字节数
numChildren = 1    # 子节点个数
</code></pre><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>zookeeper中权限通常表示为scheme:id:permissions<br>1.scheme: scheme对应于采用哪种方案来进行权限管理，zookeeper实现了一个pluggable的ACL方案，可以通过扩展scheme，来扩展ACL的机制。zookeeper-3.4.4缺省支持下面几种scheme:</p>
<ul>
<li>world: 它下面只有一个id, 叫anyone, world:anyone代表任何人，zookeeper中对所有人有权限的结点就是属于world:anyone的</li>
<li>auth: 它不需要id, 只要是通过authentication的user都有权限（zookeeper支持通过kerberos来进行authencation, 也支持username/password形式的authentication)</li>
<li>digest: 它对应的id为username:BASE64(SHA1(password))，它需要先通过username:password形式的authentication</li>
<li>ip: 它对应的id为客户机的IP地址，设置的时候可以设置一个ip段，比如ip:192.168.1.0/16, 表示匹配前16个bit的IP段</li>
<li>super: 在这种scheme情况下，对应的id拥有超级权限，可以做任何事情(cdrwa)</li>
<li>另外，zookeeper-3.4.4的代码中还提供了对sasl的支持，不过缺省是没有开启的，需要配置才能启用。<br>sasl: sasl的对应的id，是一个通过sasl authentication用户的id，zookeeper-3.4.4中的sasl authentication是通过kerberos来实现的，也就是说用户只有通过了kerberos认证，才能访问它有权限的node.</li>
</ul>
<p>2.id: id与scheme是紧密相关的，具体的情况在上面介绍scheme的过程都已介绍，这里不再赘述。</p>
<p>3.permission: zookeeper目前支持下面一些权限：</p>
<ul>
<li>CREATE(c): 创建权限，可以在当前node下创建child node</li>
<li>DELETE(d): 删除权限，可以删除当前的node下的child node</li>
<li>READ(r): 读权限，可以获取当前node的数据，可以list当前node所有的child nodes</li>
<li>WRITE(w): 写权限，可以向当前node写数据</li>
<li>ADMIN(a): 管理权限，可以设置当前node的permission</li>
</ul>
<h2 id="java客户端"><a href="#java客户端" class="headerlink" title="java客户端"></a>java客户端</h2><p>zookeeper提供了java客户端</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
    &lt;version&gt;3.4.9&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>一个小栗子</p>
<pre><code>    @Test
    public void helloZookeeper() throws IOException, KeeperException, InterruptedException, NoSuchAlgorithmException {
        Watcher basicWatcher = new Watcher() {
            public void process(WatchedEvent event) {
                System.out.println(event.getPath() + &quot; processed event : &quot; + event.getType() );
            }
        };

        // 连接ZooKeeper
        ZooKeeper zk = new ZooKeeper(&quot;localhost:2181&quot;,5000, basicWatcher);


        // 权限管理
        List&lt;ACL&gt; acls = new ArrayList&lt;ACL&gt;();
        Id id = new Id(&quot;digest&quot;,DigestAuthenticationProvider.generateDigest(&quot;admin:admin&quot;));
        acls.add(new ACL(ZooDefs.Perms.ALL, id));
        // 为会话添加身份
        zk.addAuthInfo(&quot;digest&quot;, &quot;admin:admin&quot;.getBytes());

        // 创建一个目录节点
        zk.create(&quot;/hello&quot;, &quot;hello,zookeeper&quot;.getBytes(), acls,
                CreateMode.PERSISTENT);



        // 获取子node，最后一个参数为true，将使用basicWatcher监听/hello
        zk.getChildren(&quot;/hello&quot;, true);

        // 创建一个子目录节点
        zk.create(&quot;/hello/node1&quot;, null,
                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);

        // 修改子目录节点数据,最后一个参数为dataVersion，在并发情况下可以实现乐观锁，用-1匹配所有版本
        zk.setData(&quot;/hello/node1&quot;, &quot;first&quot;.getBytes(), 0);
        zk.setData(&quot;/hello/node1&quot;, &quot;second&quot;.getBytes(), 1);

        // 删除node
        zk.delete(&quot;/hello/node1&quot;, 2);
        zk.delete(&quot;/hello&quot;, 0);
    }
</code></pre><p>参考：<br><a href="http://www.wuzesheng.com/?p=2438" target="_blank" rel="external">说说Zookeeper中的ACL</a><br><a href="http://yingshin.github.io/c/cpp/2016/09/24/zkcli-introduction" target="_blank" rel="external">zookeeper之zkCli的使用</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java keystore知识简记]]></title>
      <url>https://binecy.coding.me/java-keystore/</url>
      <content type="html"><![CDATA[<p>本文简单记录keystore里的定义及java中如何加载keystore。<br><a id="more"></a></p>
<p>密钥库是存储加密密钥和证书的存储设备。 它们最常用于SSL通信，用来证明服务器和客户端的身份。 三种条目可以存储在密钥库中。</p>
<p>PrivateKey：用于非对称加密的密钥条目。因为它很敏感，所以常用密码保护，它也常用于加密数字签名<br>Certificate ：证书，证书中常包含公钥。它通常用于验证服务器的身份。<br>SecretKey：用于对称加密的密钥条目。</p>
<p>Java中有几种不同类型的密钥库：JKS，JCEKS，PKCS12，PKCS11和DKS。 您可以在Oracle的Java Cryptography Architecture描述中找到这些密钥库的介绍。</p>
<p>KeyStore 是java定义的密钥库，可以存储PrivateKey和Certificate，但不能存储SecretKey。KeyStore可以使用KeyStore Explorer 查看。</p>
<p>可以使用keytool工具生成了server.keystore:</p>
<pre><code>&gt;keytool -genkey -alias server  -keyalg RSA  -keystore server.keystore
输入密钥库口令:
再次输入新口令:
您的名字与姓氏是什么?
  [Unknown] :   a
您的组织单位名称是什么?
  [Unknown] :  a
您的组织名称是什么?
  [Unknown] :  a
您所在的城市或区域名称是什么?
  [Unknown] :  a
您所在的省/市/自治区名称是什么?
  [Unknown] :  a
该单位的双字母国家/地区代码是什么?
  [Unknown] :  a
CN=a, OU=a, O=a, L=a, ST=a, C=a是否正确?
  [否]:  y

输入 &lt;server&gt; 的密钥口令
        (如果和密钥库口令相同, 按回车):
再次输入新口令:
</code></pre><p>命令执行完后，当前目录会生成server.keystore， server.keystore中包含了PrivateKey和Certificate。<br><strong>上面输入了密钥库口令和密钥口令，密钥库口令用于打开密钥库，而密钥口令用于在java中加载PrivateKey</strong><br>alias用于区分密钥库的不同条目。</p>
<p>如果客户需要我们的证书，那我们可以从server.keystore导出cer类型的证书：</p>
<pre><code>&gt;keytool -export -file server.cer -alias server -keystore server.keystore
输入密钥库口令:
存储在文件 &lt;server.cer&gt; 中的证书
</code></pre><p>执行上述命令，可以看到当前目录已经导出了server.cer</p>
<p>如果我们获取得了客户的证书，并信任客户证书，就可以将客户证书导入到server.keystore中。</p>
<pre><code>&gt;keytool -import -keystore server.keystore -file client.cer -alias  client
输入密钥库口令:
所有者: CN=b, OU=b, O=b, L=b, ST=b, C=b
发布者: CN=b, OU=b, O=b, L=b, ST=b, C=b
序列号: 49b9bb52
有效期开始日期: Wed Dec 14 14:12:26 GMT+08:00 2016, 截止日期: Tue Mar 14 14:12:2
6 GMT+08:00 2017
证书指纹:
         MD5: 00:A4:8E:2B:EA:2A:61:18:0A:D1:0F:2F:AB:99:E8:25
         SHA1: 1B:F4:46:73:21:27:95:CE:2A:07:B8:16:52:A5:78:09:B3:84:EC:D4
         SHA256: E7:1B:D0:D4:35:9A:7C:58:11:F5:25:C6:D7:F3:E7:96:93:C4:45:AF:49:
12:9E:A5:B7:3E:F1:84:9D:CA:D1:EB
         签名算法名称: SHA256withRSA
         版本: 3

扩展:

#1: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 87 9C 8D 23 16 AA 95 87   D9 12 F1 89 B7 71 E1 84  ...#.........q..
0010: 93 5B 37 CE                                        .[7.
]
]
</code></pre><p>使用KeyStore Explorer 打开server.keystore<br><img src="/java-keystore/1.png" alt=""><br>可以看到当前密钥库中存在两个条目，一个是client的证书，另一个是server的密钥对，可以使用密钥对导出证书。</p>
<p>java中定义了java.security.KeyStore，javax.net.ssl.KeyManagerFactory，javax.net.ssl.TrustManagerFactory这几个类来处理KeyStore，PrivateKey，Certificate。</p>
<p>在java程序中<code>trustManagerFactory.init(null);</code>加载证时，java会按如下顺序查找keystore  </p>
<ol>
<li>如果定义了system property:javax.net.ssl.trustStore,则加载该属性指定文件。<br>如果还定义了javax.net.ssl.trustStore属性，则其值将用于打开信任库之前检查其中的数据的完整性。  </li>
<li>如果<java-home>/lib/security/jssecacerts存在，则使用该文件。  </java-home></li>
<li>如果<java-home>/lib/security/cacerts 存在，则使用该文件。  </java-home></li>
</ol>
<p>也可以通过如下代码自行加载keystore：</p>
<pre><code>public static SSLContext loadSSLContext(String jksPath, String publicPassword, String privatePassword)
            throws Exception {
        // 加载KeyStore
        InputStream in = new FileInputStream(jksPath);
        KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());
        ks.load(in, publicPassword.toCharArray());    // 密钥库口令
        in.close();

        // 加载密钥
        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
        kmf.init(ks, privatePassword.toCharArray());    // 密钥口令

        // 加载信任证书
        TrustManagerFactory trustManagerFactory = TrustManagerFactory
                .getInstance(TrustManagerFactory.getDefaultAlgorithm());
        trustManagerFactory.init(ks);


        // 加载SSLContext
        SSLContext sslContext = null;
        sslContext = SSLContext.getInstance(&quot;TLSv1&quot;);   //TLSv1为目前常用协议
        sslContext.init(kmf.getKeyManagers(), trustManagerFactory.getTrustManagers(), new java.security.SecureRandom());
        return sslContext;
    }
</code></pre><p>参考：<br><a href="http://www.aneasystone.com/archives/2016/04/java-and-https.html" target="_blank" rel="external">Java 和 HTTP 的那些事（四） HTTPS 和 证书</a><br><a href="http://www.pixelstech.net/article/1408345768-Different-types-of-keystore-in-Java----Overview" target="_blank" rel="external">Different types of keystore in Java</a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jvm类加载过程]]></title>
      <url>https://binecy.coding.me/jvm-class-load/</url>
      <content type="html"><![CDATA[<p>类从加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading），验证（Verification），准备（Preparation），解析（Resolution）， 初始化（Initiallization），使用（Using）和卸载（Unloading），其中验证，准备，解析3个部分统称为连接（Linking）<br><a id="more"></a></p>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>在加载阶段，虚拟机需要完成如下操作：</p>
<blockquote>
<ol>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行数据结构</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
</blockquote>
<p>虚拟机不仅可以从Class文件获取类的二进制流， 还可以从ZIP包中读取（jar，ear，war格式），从网络中获取（Applet应用），运行时计算生成（动态代理技术），或由其他文件生成（如Jsp）。  </p>
<p>加载阶段可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员可以通过自定义类加载器去控制字节流的获取方式（即重写一个类加载器的loadClass()方法）</p>
<p>但数组类本身不通过类加载器创建，而是由Java虚拟机直接创建，不过数组类的元素类型（ElementType，指数组去掉所有维度的类型）最终还是需要类加载器创建。</p>
<p>加载阶段完成后，二进制字节流就按照虚拟机所需的格式存储在方法区中，方法区中的数据存储格式由虚拟机实现自定义。然后在内存中实例化一个java.lang.Class类的对象。这个对象将作为程序访问方法区这些类型数据的外部接口。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这个阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p>class文件并不一定要求用Java源码编译而来，可以通过任何途径产生，所以虚拟机必须检查输入的字节流，否则可能因为载入了有害的字节流而导致系统崩溃。</p>
<p>验证阶段大致完成下面4个阶段的检验动作：文件格式验证，元数验证，字节码验证，符号引用验证  </p>
<ol>
<li>文件格式验证<br>验证字节是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。  </li>
<li>元数据验证<br>对字节码描述进行语义分析，以保证其描述的信息符合Java语言规范的要求。<br>这阶段的主要目的是对类的元数据进行语义校验，保证不存在不符合Java语言规范的元数据信息。  </li>
<li>字节码验证<br>通过数据流和控制流分析， 确定程序语义是合法的，符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。    </li>
<li>符号引用验证<br>该阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看做对类自身外（常量池中的各种符号引用）的信息进行匹配性校验。<br>符号引用验证的目的是确保解析动作能正常执行，如果无法通过符号引用验证，就会抛出一个java.lang.IncompatibleClassChangeError异常的子类，如java.lang.IllegalAccessError，java.lang.NoSuchMethodError,java.lang.NoSuchFieldError等。</li>
</ol>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段， 这些变量所使用的内存都将在方法区中进行分配。  </p>
<p>这时进行内存分配的仅包括类变量（被static修改的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。其次，初始值通常指数据类型的零值。如类变量<code>public static int value = 123</code>，准备阶段后value初始值为0而不是123， 因为这时尚未开始执行任何Java方法，而把value赋值为123的putstatic指令是程序被编译后，存放在类构造器<clinit>()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。</clinit></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。  </p>
<p>符号引用：以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，但使用前必须先无歧义地定位到目标。符号引用与虚拟机实现的内存布局无关，引用的目标并一定已经加载到内存中。在Class文件中以CONSTANT_Class_info，CONSTANT_Fieldref_info等常量形式出现。<br>直接引用：可以是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不相同。如果有了直接引用，那引用的目标必定已经在内存中存在。  </p>
<p>解析动作主要针对类或接口，字段，类方法，接口方法，方法类型，方法句柄和调用点限定符7类符号引用进行，对应常量池中的CONSTANT_Class_info，CONSTANT_Fieldref_info，CONSTANT_Methodref_info，CONSTANT_InterfaceMethodref_info，CONSTANT_MethodType_info，CONSTANT_MethodHandle_info和CONSTANT_InvokeDynamic_info 7种常量类型。</p>
<p>虚拟机规范并未规定解析阶段发生的具体时间，只要求在执行anewarray, checkcase, getfield, getstatic, instanceof, invokeddynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield和putstatic这16个用于操作符引用的字节码之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来判断是在类被加载器加载时就对常量池的符号引用进行解析，还是等到一个符号引用将要使用前才去解析它。  </p>
<p>除invokedynamic指令外，虚拟机可以对第一次解析结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义加载器参与外， 其他动作完成由虚拟机主导和控制。到了初始化阶段，才真正开始执行类定义中的Java程序代码。<br>在准备阶段，类变量已经赋过一次初始值，而在初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者说：执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。</p>
<p><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定。<br><code>&lt;clinit&gt;()</code>方法与类的构造函数（实例构造器<code>&lt;init&gt;()</code>方法）不同，它不需要显形调用父类的构造器，虚拟机会保证子类的<code>&lt;clinit&gt;()</code>方法执行前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。所以父类中定义的静态语句块要优先于子类的变量赋值操作。</p>
<p>接口中不能使用静态语句块，但仍然有变量初始化赋值操作，因此接口与类一样都会生成<code>&lt;clinit&gt;()</code>方法，但与类不同，执行接口的<code>&lt;clinit&gt;()</code>方法不需要执行父接口的<code>&lt;clinit&gt;()</code>方法，只有当父接口中定义的变量使用时，父接口才初始化，另外，接口的实现类在初始化时也不会执行接口的<code>&lt;clinit&gt;()</code>方法。</p>
<p>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确地加锁，同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;()</code>方法中耗时很长，可能造成多个线程阻塞。  </p>
<p>虚拟机规范严格规定 <strong>有且只有</strong> 5种情况必须立即对类进行初始化  </p>
<ol>
<li>遇到new，getstatic，putstatic或invokestatic这4条字节码指令时，如果类没有进行初始化，需要先触发其初始化。生成这4条指令最常见的Java代码场景：使用new实例化对象，读取或设置一个类的静态字段（被final修饰，已在编译期把结果放到常量池的静态字段除外），调用一个类的静态方法。   </li>
<li>使用java.lang.refrect包的方法对类进行反射调用的时候，如果类没有进行初始化，则先触发其初始化。  </li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。  </li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。  </li>
<li>当使用JDK 1.7 的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStitic，REF_putStatic，REF_invokeStatic的方法句柄，并且方法句柄对应的类没有进行初始化，则先触发其初始化。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring获取bean - 源码简析]]></title>
      <url>https://binecy.coding.me/java-spring-get-bean/</url>
      <content type="html"><![CDATA[<p>在<a href="/java-spring-load-config/" title="spring加载配置-源码简析">spring加载配置-源码简析</a>中简单描述了spring加载配置文件的过程，现在再来分析一下spring获取bean的过程。<br><a id="more"></a></p>
<pre><code class="java">    Blog bean = (Blog)xmlBeanFactory.getBean(&quot;blog&quot;);
</code></pre>
<p>XmlBeanFactory继承了AbstractBeanFactory，<code>getBean</code>将调用AbstractBeanFactory.doGetBean方法。该方法是读取bean的实现。</p>
<p>AbstractBeanFactory.doGetBean：</p>
<pre><code class="java">protected &lt;T&gt; T doGetBean(
        final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) ... {
    final String beanName = transformedBeanName(name);    // 处理别名

    Object sharedInstance = getSingleton(beanName);        // 从单例缓存中获取

    // 父Factory
    BeanFactory parentBeanFactory = getParentBeanFactory();

    // 配置文件
    final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);


    // 处理依赖
    String[] dependsOn = mbd.getDependsOn();

    // bean范围为Singleton
    if (mbd.isSingleton()) {

        sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() {

                    public Object getObject() throws BeansException {
                        ...
                        return createBean(beanName, mbd, args);        // 真正创建bean

                    }
                });
                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
    } else if() {    // 其他处理
        ...
    }        
}
</code></pre>
<p><code>getObjectForBeanInstance</code>方法会根据参数beanInstance进行处理，如果beanInstance是FactoryBean会创建bean，返回直接返回beanInstance。</p>
<p>需要注意，这里调用了两个重载方法 <code>getSingleton(String beanName)</code>和<code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code>  </p>
<p>重载方法一<code>getSingleton(beanName)</code>从容器中获取单例bean。<br>DefaultSingletonBeanRegistry.getSingleton:</p>
<pre><code class="java">    protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        ...
        Object singletonObject = this.singletonObjects.get(beanName);    

                singletonObject = this.earlySingletonObjects.get(beanName);

        }
        return (singletonObject != NULL_OBJECT ? singletonObject : null);
    }
</code></pre>
<p>singletonObject用于缓存单例的bean<br>earlySingletonObjects则缓存正在创建的bean</p>
<p>重载方法二<code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</code>会通过ObjectFactory创建一个单例bean。<br>DefaultSingletonBeanRegistry.getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory):</p>
<pre><code>public Object getSingleton(String beanName, ObjectFactory&lt;?&gt; singletonFactory) {
    beforeSingletonCreation(beanName);    // 错误检查,子类可扩展

    singletonObject = singletonFactory.getObject();        // 创建bean
    newSingleton = true;

    afterSingletonCreation(beanName);

    if (newSingleton) {
        addSingleton(beanName, singletonObject);    // 将bean加入到singletonObject等缓存中
    }

}
</code></pre><p>bean创建过程在<code>return createBean(beanName, mbd, args);</code>代码，<br><code>createBean</code>方法由AbstractAutowireCapableBeanFactory实现：</p>
<pre><code class="java">protected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) ... {

    // 解析class
    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);

    // 注意，如果resolveBeforeInstantiation返回非null对象，这里将直接返回
    Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
    if (bean != null) {
        return bean;
    }

    // 创建bean
    Object beanInstance = doCreateBean(beanName, mbdToUse, args);

    return beanInstance;
}

protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
    bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);

    if (bean != null) {
        bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
    }

}
</code></pre>
<p><code>resolveBeforeInstantiation</code>会调用前置处理方法InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation,如果InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation返回非null对象,createBean将直接返回该对象,所以用户可以通过实现InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation自定义bean对象。</p>
<p>AbstractAutowireCapableBeanFactory.doCreateBean:</p>
<pre><code>protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) {
    BeanWrapper instanceWrapper = null;

    // 创建属性为空的bean
    instanceWrapper = createBeanInstance(beanName, mbd, args);

    // processor处理
    if (!mbd.postProcessed) {
        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
        mbd.postProcessed = true;
    }

    Object exposedObject = bean;
    // 注入属性
    populateBean(beanName, mbd, instanceWrapper);

    // 调用init方法
    if (exposedObject != null) {
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    }

    // 注册
    registerDisposableBeanIfNecessary(beanName, bean, mbd);
}

protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
    // 调用BeanNameAware,BeanClassLoaderAware,BeanFactoryAware的set方法
    invokeAwareMethods(beanName, bean);    

    // ProcessorsBeforeInitialization方法
    wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    

    // 调用init-method方法
    invokeInitMethods()    

    // 调用后处理器BeanPostProcessorsAfterInitialization.postProcessAfterInitialization 
    wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    

}
</code></pre><p>看一下beanWrapper的创建过程</p>
<pre><code>protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {
    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);

    ...
    // BeanPostProcessors是否指定构造方法
    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    if (ctors != null ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
        return autowireConstructor(beanName, mbd, ctors, args);
    }

    // 没有指定，直接调用无参构造方法
    return instantiateBean(beanName, mbd);

}
</code></pre><p><code>autowireConstructor</code>逻辑非常复杂，这里不展开。</p>
<pre><code>protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
    ...
    Object beanInstance;

    beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);    // 创建bena
    BeanWrapper bw = new BeanWrapperImpl(beanInstance);    // 创建beanWrapper
    initBeanWrapper(bw);    // 注册用户自定义的处理器
    return bw;

}
</code></pre><p><code>getInstantiationStrategy()</code>返回CglibSubclassingInstantiationStrategy，CglibSubclassingInstantiationStrategy继承 SimpleInstantiationStrategy,<code>getInstantiationStrategy().instantiate</code>调用到<br>SimpleInstantiationStrategy.instantiate:</p>
<pre><code>public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {
    constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;


        final Class&lt;?&gt; clazz = bd.getBeanClass();

        constructorToUse =    clazz.getDeclaredConstructor((Class[]) null);    // 获取构造方法

        return BeanUtils.instantiateClass(constructorToUse); // 返回实例
}

public static &lt;T&gt; T instantiateClass(Constructor&lt;T&gt; ctor, Object... args)... {
    ReflectionUtils.makeAccessible(ctor);
    return ctor.newInstance(args);    // 返回实例
}
</code></pre><p>在读取配置时，已经将属性的propername，type等基本消息读取存放到PropertyValues中，<br><code>populateBean</code>解析属性的值，并注入到bean中。</p>
<pre><code>protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
    PropertyValues pvs = mbd.getPropertyValues();    // 已从配置中读取的属性信息

    ...

    if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

        // 通过bean name自动注入
        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
            autowireByName(beanName, mbd, bw, newPvs);
        }

        // 通过bean type自动注入
        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
            autowireByType(beanName, mbd, bw, newPvs);
        }

        pvs = newPvs;
    }


    boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
    // 根据需要进行postProcesst处理
    for (BeanPostProcessor bp : getBeanPostProcessors()) {
        if (bp instanceof InstantiationAwareBeanPostProcessor) {
            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
            if (pvs == null) {
                return;
            }
        }
    }

    // 将值注到bean中
    applyPropertyValues(beanName, mbd, bw, pvs);
}
</code></pre><p>查看一下通过bean name获取属性值</p>
<pre><code>protected void autowireByName(
            String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {
    for (String propertyName : propertyNames) {
        Object bean = getBean(propertyName);    // 获取bean
        pvs.add(propertyName, bean);    // 将bean添加到属性中
        registerDependentBean(propertyName, beanName);    // 声明依赖
    }            
}
</code></pre><p>属性的注入也是比较复杂的过程，这里不再展开了…</p>
]]></content>
      
        
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring加载配置-源码简析]]></title>
      <url>https://binecy.coding.me/java-spring-load-config/</url>
      <content type="html"><![CDATA[<p>本文通过阅读源码，分析spring加载配置文件的过程<br><a id="more"></a></p>
<p>bean类</p>
<pre><code class="java">public class Blog {
    private String title;

    ... getter and settter
}
</code></pre>
<p>spring.xml配置  </p>
<pre><code class="java">    &lt;bean id=&quot;blog&quot; class=&quot;spring.bean.Blog&quot;&gt;
        &lt;property name=&quot;title&quot; value=&quot;hello spring&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
</code></pre>
<p>测试方法</p>
<pre><code class="java">    @Test
    public void test() {
        BeanFactory xmlBeanFactory = new XmlBeanFactory(new ClassPathResource(&quot;spring.xml&quot;));
        Blog bean = (Blog)xmlBeanFactory.getBean(&quot;blog&quot;);

        Assert.assertEquals(bean.getTitle(), &quot;hello spring&quot;);
    }
</code></pre>
<p> <code>XmlBeanFactory</code>继承于<code>DefaultListableBeanFactory</code>，<code>DefaultListableBeanFactory</code>是整个bean加载的核心部分，是Spring注册及加载的bean的默认实现。 <code>XmlBeanFactory</code>只是使用了自定义的XML读取器<code>XmlBeanDefinitionReader</code></p>
<pre><code class="java">BeanFactory bf = new XmlBeanFactory(new ClassPathResource(&quot;spring.xml&quot;));
</code></pre>
<p>加载过程大致示意图<br><img src="http://www.plantuml.com/plantuml/png/fOsn3i8m44FtVWLZ6V837JAWm8mwTJqbfegKvj3bEl3tfA9Ba418ZBQVxMb99r2-a5UMXx7JIplSOeuQEO-W01aEYIcqIUa5XLVnE7RTXvwnrQ4rQHiwzkk2hFjuu15pB0fvVmWxM1z-63AsJQya1UAGC9DYk6-o9Su9MxslIBturlvl-ma0" alt="@startuml
XmlBeanFactory-&gt;XmlBeanDefinitionReader: loadBeanDefinitions(resource)
XmlBeanDefinitionReader-&gt;DefaultBeanDefinitionDocumentReader:doRegisterBeanDefinitions(document)
DefaultBeanDefinitionDocumentReader-&gt;BeanDefinitionParserDelegate:parseBeanDefinitionElement(ele)
BeanDefinitionParserDelegate-&gt;BeanDefinitionParserDelegate:parseBeanDefinitionElement(ele)
@enduml"></p>
<p>跟踪<code>XmlBeanFactory</code>的构造方法，</p>
<pre><code class="java">    public XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) ... {
        super(parentBeanFactory);
        this.reader.loadBeanDefinitions(resource);    // 注:this.reader为XmlBeanDefinitionReader
    }
</code></pre>
<p>XmlBeanDefinitionReader.loadBeanDefinitions：</p>
<pre><code class="java">public int loadBeanDefinitions(Resource resource) ... {
    return loadBeanDefinitions(new EncodedResource(resource));
}

public int loadBeanDefinitions(EncodedResource encodedResource) ... {
    ...

    //获取配置文件的InputStream
    InputStream inputStream = encodedResource.getResource().getInputStream();    
    // 构造InputSource
       InputSource inputSource = new InputSource(inputStream);    
    // 解析InputSource
    return doLoadBeanDefinitions(inputSource, encodedResource.getResource());    
}

protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)     ... {
    // 获取Document对象
    Document doc = doLoadDocument(inputSource, resource);    
    // 解析Document
    return registerBeanDefinitions(doc, resource);    
}  

public int registerBeanDefinitions(Document doc, Resource resource) ... {
    ...
    // 创建DefaultBeanDefinitionDocumentReader对象
    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();    
    // 解析documentReader 注:createReaderContext()创建XmlReaderContext对象    
    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));    
}
</code></pre>
<p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions:</p>
<pre><code class="java">public void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) {
    ...
    // 获取root元素
    Element root = doc.getDocumentElement();    
    // 解析root元素
    doRegisterBeanDefinitions(root);    
}

protected void doRegisterBeanDefinitions(Element root) {
    ...
    // 创建BeanDefinitionParserDelegate对象
    this.delegate = createDelegate(getReaderContext(), root, parent);    
    preProcessXml(root);    // 模板方法，提供给子类扩展
    parseBeanDefinitions(root, this.delegate);        // 解析root元素
    postProcessXml(root);    // 模板方法，提供给子类扩展
}

protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
    if (delegate.isDefaultNamespace(root)) {
        NodeList nl = root.getChildNodes();
        for (int i = 0; i &lt; nl.getLength(); i++) {
            Node node = nl.item(i);
            if (node instanceof Element) {
                Element ele = (Element) node;
                if (delegate.isDefaultNamespace(ele)) {
                    parseDefaultElement(ele, delegate);    // 解析node结点
                }
                else {
                    delegate.parseCustomElement(ele);
                }
            }
        }
    }
    else {
        delegate.parseCustomElement(root);
    }
}
</code></pre>
<p>上述方法根据Namespace Uri判断node是否为Spring定义的元素，如果是，则调用parseDefaultElement方法解析元素。<br>用户可以自定义标签及标签解析器。</p>
<pre><code class="java">    private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
        if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {    // 解析import标签
            importBeanDefinitionResource(ele);
        }
        else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {    // 解析alias标签
            processAliasRegistration(ele);
        }
        else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {    // 解析bean标签
            processBeanDefinition(ele, delegate);
        }
        else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {    // 解析beans标签
            doRegisterBeanDefinitions(ele);
        }
    }
</code></pre>
<p><code>parseDefaultElement</code>方法对import，alias，bean，beans标签进行了解析，这里主要看bean的解析过程：</p>
<pre><code>protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
    // 解析元素,解析结果为BeanDefinitionHolder对象
    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);    
    if (bdHolder != null) {
        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);    // 装饰模式

        // 注册BeanDefinition，即将解析结果存储在registry对象中.
        BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder,getReaderContext().getRegistry());    

        // 发送事件
        getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
    }
}
</code></pre><p>BeanDefinitionHolder中包含了BeanDefinition实例。<br>BeanDefinition是配置文件中<code>&lt;bean&gt;</code>标签在容器中的内部表示形式。<br>BeanDefinition存在子类RootBeanDefinition和ChildBeanDefinition。ChildBeanDefinition表示子<code>&lt;bean&gt;</code>,而<br>RootBeanDefinition表示父<code>&lt;bean&gt;</code>和没有父<code>&lt;bean&gt;</code>的bean，是最常用的实现类。<br>spring将配置文件中<bean>配置信息转化为beanDefinition对象，并注册到容器中。</bean></p>
<p><code>delegate.parseBeanDefinitionElement</code>将调用BeanDefinitionParserDelegate.parseBeanDefinitionElement方法:</p>
<pre><code>public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
    // 解析bean元素
    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);

    String beanClassName = beanDefinition.getBeanClassName();

    String[] aliasesArray = StringUtils.toStringArray(aliases);
    return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
}

public AbstractBeanDefinition parseBeanDefinitionElement(Element ele, String beanName, BeanDefinition containingBean) {

    ...
    className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); // 解析className

    parent = ele.getAttribute(PARENT_ATTRIBUTE);


    AbstractBeanDefinition bd = createBeanDefinition(className, parent);

    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);    // 解析&quot;scope&quot;,&quot;scope&quot;等属性
    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

    parseMetaElements(ele, bd);    // 解析meta属性
    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());    // 处理lookup-method元素
    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());    // 处理replaced-method元素

    parseConstructorArgElements(ele, bd);    // 解析constructor-arg构造方法参数
    parsePropertyElements(ele, bd);    // 解析property元素
    parseQualifierElements(ele, bd);    //解析qualifier元素

    bd.setResource(this.readerContext.getResource());
    bd.setSource(extractSource(ele));

    return bd;
}
</code></pre><p>看一下属性的解析过程<code>parsePropertyElements</code></p>
<pre><code>    public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
        NodeList nl = beanEle.getChildNodes();
        for (int i = 0; i &lt; nl.getLength(); i++) {
            Node node = nl.item(i);
            if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {
                parsePropertyElement((Element) node, bd);
            }
        }
    }
</code></pre><p>遍历所有的子元素，如果是property节点，则进行处理</p>
<pre><code>public void parsePropertyElement(Element ele, BeanDefinition bd) {
    ...
    Object val = parsePropertyValue(ele, bd, propertyName);
    PropertyValue pv = new PropertyValue(propertyName, val);
    parseMetaElements(ele, pv);
    pv.setSource(extractSource(ele));
    bd.getPropertyValues().addPropertyValue(pv);        
}
</code></pre><p>这里只是把属性的propername，type等基本消息读取存放到PropertyValues中，并没有解析属性的值。</p>
<p>最后看一下注册过程<code>BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</code><br>BeanDefinitionReaderUtils.registerBeanDefinition内容为：</p>
<pre><code>public static void registerBeanDefinition(
        BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) ...{

    // 为bean注册beanname
    String beanName = definitionHolder.getBeanName();
    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

    // 为bean注册别名
    String[] aliases = definitionHolder.getAliases();
    if (aliases != null) {
        for (String alias : aliases) {
            registry.registerAlias(beanName, alias);
        }
    }
}
</code></pre><p>最终将调用到DefaultListableBeanFactory.registerBeanDefinition方法:  </p>
<pre><code class="java">    @Override
    public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) ... {
        ...
        this.beanDefinitionMap.put(beanName, beanDefinition);

    }
</code></pre>
<p>最后，bean解析结果beanDefinition存储在DefaultListableBeanFactory的<code>Map&lt;String, BeanDefinition&gt; beanDefinitionMap</code>属性中。</p>
]]></content>
      
        
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis mapper动态代理实现]]></title>
      <url>https://binecy.coding.me/java-mybatis-mapper-proxy/</url>
      <content type="html"><![CDATA[<p>本文通过源码阅读，分析mybatis中mapper动态代理的实现。<br><a id="more"></a></p>
<h3 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h3><pre><code>Mapper接口
public interface BlogMapper {
    Blog selectBlog(long id);
}


@Test
public void test() throws IOException {
    String resource = &quot;mybatis-config.xml&quot;;
    InputStream inputStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory  = new SqlSessionFactoryBuilder().build(inputStream);

    SqlSession session = sqlSessionFactory.openSession();
    try {
        BlogMapper mapper = session.getMapper(BlogMapper.class);
        Blog blog = mapper.selectBlog(1);

        System.out.println(blog);
    } finally {
        session.close();
    }
}
</code></pre><p>我们都知道，通过<code>session.getMapper</code>可以获取mybatis生成的BlogMapper代理类，调用<code>mapper.selectBlog</code>方法将执行数据库查询，并将返回查询结果。</p>
<h3 id="mapper代理实现"><a href="#mapper代理实现" class="headerlink" title="mapper代理实现"></a>mapper代理实现</h3><p>跟踪<code>session.getMapper</code>方法，最终调用到<code>DefaultSqlSession.getMapper</code>方法</p>
<pre><code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type) {
      return configuration.&lt;T&gt;getMapper(type, this);
  }
</code></pre><p><code>Configuration.getMapper</code>内容如下</p>
<pre><code>  public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
      return mapperRegistry.getMapper(type, sqlSession);
  }
</code></pre><p>可以看到这里将调用mapperRegistry.getMapper生成代理类。</p>
<h3 id="mapperRegistry初始化"><a href="#mapperRegistry初始化" class="headerlink" title="mapperRegistry初始化"></a>mapperRegistry初始化</h3><p>先看一下mapperRegistry的初始化过程<br><code>SqlSessionFactoryBuilder().build(inputStream)</code>构造初始环境，并会调用到<code>mapperElement(root.evalNode(&quot;mappers&quot;))</code>方法，该方法会解析配置文件中的mappers标签配置。</p>
<pre><code>  private void mapperElement(XNode parent) throws Exception {
    if (parent != null) {
      for (XNode child : parent.getChildren()) {
        if (&quot;package&quot;.equals(child.getName())) {
          ...
        } else {
          String resource = child.getStringAttribute(&quot;resource&quot;);
          String url = child.getStringAttribute(&quot;url&quot;);
          String mapperClass = child.getStringAttribute(&quot;class&quot;);
          if (resource != null &amp;&amp; url == null &amp;&amp; mapperClass == null) {
            ...
          } else if (resource == null &amp;&amp; url != null &amp;&amp; mapperClass == null) {
            ...
          } else if (resource == null &amp;&amp; url == null &amp;&amp; mapperClass != null) {
            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);
            configuration.addMapper(mapperInterface);
          } else {
            throw new BuilderException(&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;);
          }
        }
      }
    }
  }
</code></pre><p>方法中对mappers标签配置的resource，url，class属性分别进行解析。而对class属性的解析<code>configuration.addMapper(mapperInterface);</code>会调用MapperRegistry.addMapper方法：</p>
<pre><code>public &lt;T&gt; void addMapper(Class&lt;T&gt; type) {
    ...
    knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));    // 添加代理生成工厂
    MapperAnnotationBuilder parser = new MapperAnnotationBuilder(config, type);    // 解析class
        parser.parse();
}
</code></pre><p>MapperAnnotationBuilder.parse</p>
<pre><code>  public void parse() {
    ...
      Method[] methods = type.getMethods();
      for (Method method : methods) {
        parseStatement(method);    // 解析方法

      }


  }
</code></pre><p><code>parseStatement(method)</code>会将class中的方法解析为MappedStatement对象,并存储在configuration.mappedStatements属性中。</p>
<h3 id="mapperRegistry生成代理"><a href="#mapperRegistry生成代理" class="headerlink" title="mapperRegistry生成代理"></a>mapperRegistry生成代理</h3><p>mapperRegistry.getMapper内容如下</p>
<pre><code>public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) {
final MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);
    ...
    return mapperProxyFactory.newInstance(sqlSession);
}
</code></pre><p>MapperProxyFactory.newInstance会创建一个代理对象</p>
<pre><code>  public T newInstance(SqlSession sqlSession) {
    final MapperProxy&lt;T&gt; mapperProxy = new MapperProxy&lt;T&gt;(sqlSession, mapperInterface, methodCache);
    return newInstance(mapperProxy);
  }

  protected T newInstance(MapperProxy&lt;T&gt; mapperProxy) {
    return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[] { mapperInterface }, mapperProxy);
  }
</code></pre><p><code>MapperProxy</code>即为动态代理类，实现了InvocationHandler接口，当调用mapper接口的方法时，将调用到MapperProxy的invoke方法：</p>
<pre><code>public class MapperProxy&lt;T&gt; implements InvocationHandler, Serializable {
    ...
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (Object.class.equals(method.getDeclaringClass())) {  // 
      try {
        return method.invoke(this, args);
      } catch (Throwable t) {
        throw ExceptionUtil.unwrapThrowable(t);
      }
    }
    final MapperMethod mapperMethod = cachedMapperMethod(method);
    return mapperMethod.execute(sqlSession, args);
    }
}
</code></pre><p>如果执行的方法不是Object方法，将执行<code>mapperMethod.execute</code>方法</p>
<pre><code>public Object execute(SqlSession sqlSession, Object[] args) {
    Object result;
    if (SqlCommandType.INSERT == command.getType()) {
      Object param = method.convertArgsToSqlCommandParam(args);
      result = rowCountResult(sqlSession.insert(command.getName(), param));
    } else if (SqlCommandType.UPDATE == command.getType()) {
      ...
    } else if (SqlCommandType.DELETE == command.getType()) {
      ...
    } else if (SqlCommandType.SELECT == command.getType()) {
      ...
    } else {
      throw new BindingException(&quot;Unknown execution method for: &quot; + command.getName());
    }
    ...
    return result;
  }
</code></pre><p><code>mapperMethod.execute</code>方法会转化参数，调用SqlSession进行insert/update/delete/select操作,最后处理结果并返回。</p>
]]></content>
      
        
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mybatis查询过程源码简析]]></title>
      <url>https://binecy.coding.me/java-mybatis-query-process/</url>
      <content type="html"><![CDATA[<p>本文通过阅读源码，分析mybatis中执行一个简单sql语句的过程，但不会涉及到关键实现。<br><a id="more"></a></p>
<h2 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h2><p>应用官网上一个简单的实例</p>
<p>mybatis-config.xml</p>
<pre><code>...
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            ...
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource=&quot;mapper/BlogMapper.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><p>BlogMapper.xml</p>
<pre><code>...
&lt;mapper namespace=&quot;mapper.blog.BlogMapper&quot;&gt;
    &lt;select id=&quot;selectBlog&quot; resultType=&quot;domain.blog.Blog&quot;&gt;
        select * from Blog where id = #{id}
    &lt;/select&gt;
&lt;/mapper&gt;
</code></pre><pre><code>BlogMapper.java
public interface BlogMapper {
    Blog selectBlog(long id);i
}


测试方法
@Test
public void  test() throws IOException {
    String resource = &quot;mybatis-config.xml&quot;;
    InputStream inputStream = Resources.getResourceAsStream(resource);
    SqlSessionFactory sqlSessionFactory  = new SqlSessionFactoryBuilder().build(inputStream);

    SqlSession session = sqlSessionFactory.openSession();
    try {
        Blog blog = session.selectOne(&quot;mapper.blog.BlogMapper.selectBlog&quot;, 1);

        Systet.out.println(blog);
    } finally {
        session.close();
    }
}
</code></pre><p>例子很简单。</p>
<p><strong>mybatis分层结构</strong>如下<br><img src="/java-mybatis-query-process/1.png" alt=""></p>
<p>下面简单看一下mybatis中sql查询的执行流程。</p>
<h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><p><code>new SqlSessionFactoryBuilder().build(inputStream)</code>会解析mybatis-config.xml配置文件，并构建SqlSessionFactory对象。</p>
<pre><code>public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {
    ...
    XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);
    return build(parser.parse());
}
</code></pre><p><code>parser.parse()</code>使用<code>XMLConfigBuilder</code>对mybatis-config.xml解析，会将解析结果将存放到XMLConfigBuilder父类BaseBuilder的<code>configuration</code>属性中，并返回<code>configuration</code>属性。</p>
<p>而<code>build(Configuration config)</code>则创建一个DefaultSqlSessionFactory对象</p>
<pre><code>public SqlSessionFactory build(Configuration config) {
    return new DefaultSqlSessionFactory(config);
}
</code></pre><p><code>XMLConfigBuilder</code>解析配置文件过程为</p>
<pre><code>public Configuration parse() {
    ...
    parseConfiguration(parser.evalNode(&quot;/configuration&quot;));
}


private void parseConfiguration(XNode root) {
    try {
      propertiesElement(root.evalNode(&quot;properties&quot;)); //issue #117 read properties first
      typeAliasesElement(root.evalNode(&quot;typeAliases&quot;));
      pluginElement(root.evalNode(&quot;plugins&quot;));
      objectFactoryElement(root.evalNode(&quot;objectFactory&quot;));
      objectWrapperFactoryElement(root.evalNode(&quot;objectWrapperFactory&quot;));
      settingsElement(root.evalNode(&quot;settings&quot;));
      environmentsElement(root.evalNode(&quot;environments&quot;)); // read it after objectFactory and objectWrapperFactory issue #631
      databaseIdProviderElement(root.evalNode(&quot;databaseIdProvider&quot;));
      typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));
      mapperElement(root.evalNode(&quot;mappers&quot;));
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing SQL Mapper Configuration. Cause: &quot; + e, e);
    }
}
</code></pre><p>可以看到方法中对mybatis-config.xml配置的内容逐一进行了解析，这里不再细说。</p>
<h2 id="获取SqlSession"><a href="#获取SqlSession" class="headerlink" title="获取SqlSession"></a>获取SqlSession</h2><pre><code>SqlSession session = sqlSessionFactory.openSession();
</code></pre><p><code>DefaultSqlSessionFactory.openSession()</code>将构造一个DefaultSqlSession对象</p>
<pre><code>public SqlSession openSession() {
    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);
}

private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
    ...
    final Environment environment = configuration.getEnvironment();
    final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);
    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
    final Executor executor = configuration.newExecutor(tx, execType);
    return new DefaultSqlSession(configuration, executor, autoCommit);
}
</code></pre><p>上述方法中创建了事务管理工厂，简单的执行器SimpleExecutor，并构造了DefaultSqlSession。</p>
<h2 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h2><pre><code>Blog blog = session.selectOne(&quot;mapper.blog.BlogMapper.selectBlog&quot;, 1);
</code></pre><p>跟踪<code>session.selectOne</code>调用过程，最终调用到<code>DefaultSqlSession.selectList()</code>方法</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
    ...
    MappedStatement ms = configuration.getMappedStatement(statement);
    List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
    return result;
}
</code></pre><p>MappedStatement是BlogMapper.xml的解析结果，解析过程在<code>XMLConfigBuilder.mapperElement(XNode parent)</code>方法。</p>
<p><code>executor.query</code>将调用SimpleExecutor父类BaseExecutor的<code>query</code>方法</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
    BoundSql boundSql = ms.getBoundSql(parameter);  // 生成sql语句
    ...
    return query(ms, parameter, rowBounds, resultHandler, key, boundSql);   // 执行查询
}

public &lt;E&gt; List&lt;E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ...
    // 从缓存中读取
    list = resultHandler == null ? (List&lt;E&gt;) localCache.getObject(key) : null;
    if (list != null) { // 存在缓存数据
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
    } else {    // 不存在缓存数据，从数据库中查询    
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);  
    }
}

private &lt;E&gt; List&lt;E&gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ... 
    list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
}
</code></pre><p><code>ms.getBoundSql(parameter)</code>是一个关键方法，负责生成sql语句。  </p>
<p><code>doQuery</code>由<code>SimpleExecutor</code>实现</p>
<pre><code>  public &lt;E&gt; List&lt;E&gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException {
    Statement stmt = null;
    try {
      Configuration configuration = ms.getConfiguration();    
      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);    // 生成StatementHandler
      stmt = prepareStatement(handler, ms.getStatementLog());    // 参数处理
      return handler.&lt;E&gt;query(stmt, resultHandler);    // 查询及处理结果
    } finally {
      closeStatement(stmt);
    }
  }
</code></pre><p>StatementHandler是一个关键的Handler接口，有如下方法</p>
<pre><code>public interface StatementHandler {
  Statement prepare(Connection connection) throws SQLException;

  void parameterize(Statement statement) throws SQLException;

  void batch(Statement statement) throws SQLException;

  int update(Statement statement) throws SQLException;

  &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException;

  BoundSql getBoundSql();

  ParameterHandler getParameterHandler();
}
</code></pre><p>这些方法负责对真实数据库进行处理。StatementHandler有如下实现类<br><img src="/java-mybatis-query-process/2.png" alt=""></p>
<p><code>configuration.newStatementHandler</code>将生成一个RoutingStatementHandler类，RoutingStatementHandler实际上是对PreparedStatementHandler，CallableStatementHandler，SimpleStatementHandler的路由处理，会根据MappedStatement.StatementType，将请求对应转发到这些类上。  </p>
<pre><code>public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
    StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
    statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); // 添加拦截器
    return statementHandler;
}
</code></pre><p>MappedStatement.StatementType默认为PREPARED，即使用PreparedStatementHandler。</p>
<p><code>prepareStatement(handler, ms.getStatementLog())</code>会创建Statement对象，并处理sql查询参数</p>
<pre><code>private Statement prepareStatement(StatementHandler handler, Log statementLog) throws SQLException {
    Statement stmt;
    Connection connection = getConnection(statementLog);    // 创建Statement对象
    stmt = handler.prepare(connection); // 处理sql查询参数
    handler.parameterize(stmt);
    return stmt;
}
</code></pre><p><code>handler.parameterize</code>会调用PreparedStatementHandler.parameterize方法：</p>
<pre><code>public void parameterize(Statement statement) throws SQLException {
    parameterHandler.setParameters((PreparedStatement) statement);
}
</code></pre><p>parameterHandler负责对参数进行处理。</p>
<p><code>handler.&lt;E&gt;query</code>则调用PreparedStatementHandler.query方法:</p>
<pre><code>public &lt;E&gt; List&lt;E&gt; query(Statement statement, ResultHandler resultHandler) throws SQLException {
    PreparedStatement ps = (PreparedStatement) statement;
    ps.execute();   // 执行sql语句
    return resultSetHandler.&lt;E&gt; handleResultSets(ps);   // 处理结果
}
</code></pre><p>resultSetHandler负责对结果进行处理。</p>
<p>上述只是简单记录了mybatis的sql查询的执行流程，并没有对核心的实现进行详细分析，如<br><strong>MappedStatement.getBoundSql</strong>解析sql语句<br><strong>ParameterHandler.setParameters</strong>处理查询参数<br><strong>resultSetHandler.handleResultSets</strong>处理查询结果<br><strong>连接管理</strong><br><strong>事务管理</strong><br><strong>缓存实现</strong></p>
]]></content>
      
        
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java class文件结构]]></title>
      <url>https://binecy.coding.me/java-class-format/</url>
      <content type="html"><![CDATA[<p>文章描述了class文件的结构，并解析一个简单的class文件的字节内容。<br><a id="more"></a></p>
<p><strong>语言无关</strong></p>
<p>除了Java语言， 其他语言也可以运行在Java虚拟机上。Java规范分为Java语言规范和Java虚拟机规范。 Java虚拟机不和包括Java在内的任何语言绑定， 它只与“Class文件”这种特定的二进制文件格式所关联。基于安全方面的考虑， Java虚拟机规范要求在Class文件中使用许多强制性的语法及结构化约束，但任何一门功能性语言， 只要可以把程序代码编译成能被Java虚拟机接受的有效的Class文件， 它就可以运行在Java虚拟机上。</p>
<h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p>Class文件中只有两种数据类型：无符号数和表</p>
<p>无符号数属于基本的数据类型， 以u1, u2, u4, u8分别表示1个字节， 2个字节， 4个字节和8个字节， 无符号数可以用来描述数字， 索引引用， 数量值或者按照UTF-8编码构成的字符串值。</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型， 所有表都习惯地以”_info”结构。表用于描述有层次关系的复合结构的数据， 整个Class文件本质上就是一张表：<br><img src="/java-class-format/1.png" alt=""><br>无论是无符号数还是表，当需要描述同一类型但数量不一定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式。</p>
<h3 id="魔数-版本号-magic-version"><a href="#魔数-版本号-magic-version" class="headerlink" title="魔数/版本号 magic/version"></a>魔数/版本号 magic/version</h3><p>每个Class文件中头4个字节称为魔数（magic）， 用于确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
<p>第5,6个字节是Class文件次版本号（minor_version）， 第7,8个字节是主版本号（major_version）。高版本的JKD向下兼容以前版本的Class文件， 但不能运行以后版本的Class文件，即使文件格式并末发生变化。</p>
<h3 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h3><p>constant_pool_count为常量池容量计数值，注意这个计数从1开始。假若该值为0x0016，即十进制的22，则表示常量池中有21项常量，索引值范围为1~21。Class文件结构中只有常量池容量计数是从1开始，其他集合类型，包括接口索引集合，字段表集合，方法表集合等容量计数是从0开始。</p>
<p>常量池（constant_pool）主要存放两大类常量：字面量和符号引用。</p>
<p>字面量比较接近Java语言层面的常量概念，如文本字符串， 声明为final的常量值等。</p>
<p>符号引用包括下面三类常量：</p>
<p>类和接口的全限定名</p>
<p>字段的名称和描述符</p>
<p>方法的名称和描述符</p>
<p>在Class文件中不会保存各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用不经过运行期转换无法得到真正的内存入口地址，也就是无法被虚拟机使用。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类创建时或运行时解析，翻译到具体的内存地址。</p>
<p>常量池中每一项常量都是一个表。在JDK1.7中有14种表， 表示14种常量类型。它们有一个共同的特点，表开始的第一位是一个u1类型的标志位tag， 代表当前常量属于哪种常量类型。</p>
<p>最常见的字符串类型CONSTANT_Utf8_info，结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody>
</table>
<p>length说明这个UTF-8编码的字符串长度是多少字节，它后面紧跟长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。<br>在Class文件中方法， 字段，类或接口都需要使用CONSTANT_Utf8_info型常量描述名称，所以它们的最大长度就是length的最大值， 就是u2所表表达的最大值65535。Java中的字符串字面量(string literals)，如“abc”、”123”之类写在代码中的字符串literals也是如此。</p>
<h3 id="访问标志-access-flags"><a href="#访问标志-access-flags" class="headerlink" title="访问标志 access_flags"></a>访问标志 access_flags</h3><p>access_flags为访问标志，标识一些类或接口层次的访问信息，如是否为public类型，是否为final类型。</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>acc_public</td>
<td>0x0001</td>
<td>是否为public类型</td>
</tr>
<tr>
<td>acc_final</td>
<td>0x0010</td>
<td>是否为final类型</td>
</tr>
<tr>
<td>acc_super</td>
<td>0x0020</td>
<td>是否允许使用invokespecial字节码指令的新语意，jdk1.0.2之后编译的类该标志必须为真</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="类索引-父索引-接口索引集合-this-class-super-class-interface"><a href="#类索引-父索引-接口索引集合-this-class-super-class-interface" class="headerlink" title="类索引/父索引/接口索引集合     this_class/super_class/interface"></a>类索引/父索引/接口索引集合     this_class/super_class/interface</h3><p>类索引（this_class），父类索引（super_class），接口索引集合（interface）确定这个类的继承关系。<br>类索引，父类索引都是u2类型的数据，分别指向一个类型为CONSTANT_Class_info的类描述符常量，从而可以找到CONSTANT_Utf8_info类型的全限定名字符串。全限定名，就是把类全名中的”.”替换成”/“， 如”java/lang/Object”<br>除java.lang.Object外，所有的Java类父类索引都不为0。<br>接口索引集合是一组u2类型的数据集合，描述这个类实现了哪些接口，那些被实现的接口将按implements语句顺序排列在接口索引集中。</p>
<h3 id="字段表集合-fields"><a href="#字段表集合-fields" class="headerlink" title="字段表集合 fields"></a>字段表集合 fields</h3><p>字符集（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量及实例级变量，但不包括方法内部声明的局部变量。<br>字符表结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes attributes_count</td>
</tr>
</tbody>
</table>
<p>access_flags表示字段是否为public，static，final，volatile，transient等信息。</p>
<p>name_index和descript_index都是对常量池的引用，分别代表字段的简单名称和描述符。<br>简单名称是指没有类型和参数修饰的字符名称， 如<code>private String title;</code>字段简单名称为”title”<br>描述符描述字段的数据类型，基本数据类型和代表无返回值的void类型都用一个大写字符表示，而对象类型则用字符L加对象的全限定名表示。<br><img src="/java-class-format/2.png" alt=""><br>对于数组类型，每一维度将使用一个前置的”[“字符来描述。如”java.lang.String[][]”表示为”[[Ljava/lang/String”，”int[]”被记录为”[I”  </p>
<p>attribute_info 表示一个属性表集合，包含若干属性表，用于存储一些额外的信息。</p>
<p><strong>字段表不会列出从超类或父接口中继承来的字段， 但可能列出原Java代码中不存在的字段， 如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</strong></p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>方法表与字段表类似， 结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量 </th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descript_index</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count    </td>
</tr>
</tbody>
</table>
<p>name_index和descript_index也表示方法的简单名称和描述符。<br>简单名称指没有类型和参数修饰的方法名，如<code>public void setTitle(String title)</code>方法简称为”setTitle”<br>描述符按先参数列表后返回值的顺序描述方法。参数列表按照参数的严格顺序放在一组小括号”()”之内。如方法<code>void inc()</code>描述符为”()V”，方法<code>int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetoffset, int targetCount, int fromIndex)</code>的描述符为”([CII[CIII)I”。</p>
<p><strong>如果没有重写父类的方法，那方法表中就不会出现来自父类的方法信息， 但可能会出现由编译器自动添加的方法，如类构造器”<clinit>“和实例构造器”<init>“方法。</init></clinit></strong></p>
<p>方法属性表存储一些额外的修改。如方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表中一个名为”Code”的属性里面。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>在Class文件， 字段表， 方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。<br>上述已经说过每个字段和方法最后都可以携带一个属性表集合，用于存储一些额外的信息。而类最后也会携带一个属性表集合，存储一些class文件的信息。</p>
<p>属性表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attributes_length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>info</td>
<td>attributes_length</td>
</tr>
</tbody>
</table>
<p>attribute_name_index引用一个CONSTANT_Utf8_info常量表示属性名称<br>attributes_length表示属性的值占字节长度。它后面紧跟长度为attributes_length字节的连续数据是属性具体的值。</p>
<p>一些常用的属性：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java代码编译成的字节码指令</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>InnerClasses</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类，方法表，字段表</td>
<td>被声明为deprecated的类，方法或字段</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>记录泛型中的相关信息</td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="解析class文件"><a href="#解析class文件" class="headerlink" title="解析class文件"></a>解析class文件</h2><p>下面解析一个class文件<br>java源码：</p>
<pre><code>package bean;

public class Blog
{
  private String title;

  public String getTitle()
  {
    return this.title;
  }

  public void setTitle(String title) {
    this.title = title;
  }
}
</code></pre><p>使用WinHex打开class文件<br><img src="/java-class-format/3.png" alt=""></p>
<p>根据上述的class类定义，解析这个class文件</p>
<table>
<thead>
<tr>
<th>16进制值</th>
<th>10进制值</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>ca fe ba be</td>
<td></td>
<td>魔法数</td>
</tr>
<tr>
<td>00 00</td>
<td></td>
<td>次版本  </td>
</tr>
<tr>
<td>00 34</td>
<td>52</td>
<td>主版本(使用jdk8编译)</td>
</tr>
<tr>
<td>00 18</td>
<td>24</td>
<td>常量数个数，该class文件中有23个常量，索引下标1~23</td>
</tr>
<tr>
<td><strong>常量池开始</strong></td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>0a</td>
<td>10</td>
<td><strong>常量#1</strong> 符号引用 CONSTANT_Methodref_info </td>
</tr>
<tr>
<td>00 04</td>
<td>4</td>
<td>指向常量#4</td>
</tr>
<tr>
<td>00 14</td>
<td>20</td>
<td>指向常量#20</td>
</tr>
<tr>
<td>09</td>
<td>9</td>
<td><strong>常量#2</strong>  符号引用 CONSTANT_Class_info </td>
</tr>
<tr>
<td>00 03</td>
<td>3</td>
<td>指向常量#3</td>
</tr>
<tr>
<td>00 15</td>
<td>21</td>
<td>指定索引#21</td>
</tr>
<tr>
<td>07</td>
<td>7</td>
<td><strong>常量#3</strong>  符号引用 CONSTANT_Fieldref_info </td>
</tr>
<tr>
<td>00 16</td>
<td>22</td>
<td>指向索引#22</td>
</tr>
<tr>
<td>07</td>
<td>7</td>
<td><strong>常量#4</strong> 符号引用 CONSTANT_Fieldref_info </td>
</tr>
<tr>
<td>00 17</td>
<td>23</td>
<td>指向#23</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#5</strong> 字符串常量</td>
</tr>
<tr>
<td>05</td>
<td>5</td>
<td>长度5</td>
</tr>
<tr>
<td>7469746c65</td>
<td></td>
<td>字符串值:title</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#6</strong> 字符串常量</td>
</tr>
<tr>
<td>00 12</td>
<td>18</td>
<td>长度18</td>
</tr>
<tr>
<td>4c6a6176612f6c616e672f537472696e673b</td>
<td></td>
<td>字符串值:Ljava/lang/String;</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#7</strong> 字符串常量</td>
</tr>
<tr>
<td>00 06</td>
<td>6</td>
<td>长度6</td>
</tr>
<tr>
<td>3c 69 6e 69 74 3e</td>
<td></td>
<td>字符串值: &lt;init&#62;</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#8</strong> 字符串常量</td>
</tr>
<tr>
<td>00 03</td>
<td>3</td>
<td>长度3</td>
</tr>
<tr>
<td>28 29 56</td>
<td></td>
<td>字符值:()V </td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#9</strong> 字符串常量</td>
</tr>
<tr>
<td>00 04</td>
<td>4</td>
<td>长度4 </td>
</tr>
<tr>
<td>43 6f 64 65</td>
<td></td>
<td>字符串值:code</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#10</strong> 字符串常量</td>
</tr>
<tr>
<td>00 0f</td>
<td>15</td>
<td>长度15</td>
</tr>
<tr>
<td>4C696E654E756D6265725461626C65</td>
<td></td>
<td>字符串值: LineNumberTable</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#11</strong> 字符串常量</td>
</tr>
<tr>
<td>00 12</td>
<td>18</td>
<td>长度18</td>
</tr>
<tr>
<td>4C6F63616C5661726961626C655461626C65</td>
<td></td>
<td>字符串值:LocalVariableTable</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#12</strong> 字符串常量</td>
</tr>
<tr>
<td>00 04</td>
<td>4</td>
<td>长度4</td>
</tr>
<tr>
<td>74686973</td>
<td></td>
<td>字符串值:this</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#13</strong> 字符串常量</td>
</tr>
<tr>
<td>00 0b len</td>
<td>11</td>
<td>长度11</td>
</tr>
<tr>
<td>4C6265616E2F426C6F673B</td>
<td></td>
<td>字符串值:Lbean/Blog;</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#14</strong> 字符串常量</td>
</tr>
<tr>
<td>00 08</td>
<td>8</td>
<td>长度8</td>
</tr>
<tr>
<td>6765745469746C65</td>
<td></td>
<td>字符串值:getTitle</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#15</strong> 字符串常量</td>
</tr>
<tr>
<td>00 14</td>
<td>20</td>
<td>长度20</td>
</tr>
<tr>
<td>28294C6A6176612F6C616E672F537472696E673B</td>
<td></td>
<td>字符串值:()Ljava/lang/String;</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#16</strong> 字符串常量</td>
</tr>
<tr>
<td>00 08</td>
<td>8</td>
<td>长度8</td>
</tr>
<tr>
<td>7365745469746C65</td>
<td></td>
<td>字符串值:setTitle</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#17</strong> 字符串常量</td>
</tr>
<tr>
<td>00 15</td>
<td>21</td>
<td>长度21</td>
</tr>
<tr>
<td>284C6A6176612F6C616E672F537472696E673B2956</td>
<td></td>
<td>字符串值:(Ljava/lang/String;)V</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#18</strong> 字符串常量</td>
</tr>
<tr>
<td>00 0a</td>
<td>10</td>
<td>长度10</td>
</tr>
<tr>
<td>536F7572636546696C65</td>
<td></td>
<td>字符串值:SourceFile</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#19</strong> 字符串常量</td>
</tr>
<tr>
<td>00 09</td>
<td>9</td>
<td>长度9</td>
</tr>
<tr>
<td>426C6F672E6A6176610C</td>
<td></td>
<td>字符串值:Blog.java</td>
</tr>
<tr>
<td>0c</td>
<td>12</td>
<td><strong>常量#20</strong> name_andtype_info</td>
</tr>
<tr>
<td>00 07</td>
<td>7</td>
<td>指向常量#7 </td>
</tr>
<tr>
<td>00 08</td>
<td>8</td>
<td>指向常量#8</td>
</tr>
<tr>
<td>0c</td>
<td>12</td>
<td><strong>常量#21</strong> </td>
</tr>
<tr>
<td>00 05</td>
<td>5</td>
<td>指向常量#5</td>
</tr>
<tr>
<td>00 06</td>
<td>6</td>
<td>指向常理#6</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#22</strong> 字符串常量</td>
</tr>
<tr>
<td>00 09</td>
<td>9</td>
<td>长度9</td>
</tr>
<tr>
<td>6265616E2F426C6F67</td>
<td></td>
<td>字符串值:bean/Blog</td>
</tr>
<tr>
<td>01</td>
<td>1</td>
<td><strong>常量#23</strong> 字符串常量</td>
</tr>
<tr>
<td>00 10</td>
<td>16</td>
<td>长度16</td>
</tr>
<tr>
<td>6A6176612F6C616E672F4F626A656374</td>
<td></td>
<td>字符串值:java/lang/Object</td>
</tr>
<tr>
<td><strong>常量池结束</strong></td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>00 21</td>
<td></td>
<td>access_flags : 0x0021表示public类而且允许使用invokespecial字节码</td>
</tr>
<tr>
<td>00 03</td>
<td>3</td>
<td>类索引，指向常量#3</td>
</tr>
<tr>
<td>00 04</td>
<td>4</td>
<td>父类索引，指向常量#4</td>
</tr>
<tr>
<td>00 00</td>
<td></td>
<td>接口索引，该class没有实现接口</td>
</tr>
<tr>
<td><strong>字段表开始</strong></td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td>1个字段  (位置110/8)</td>
</tr>
<tr>
<td>00 02</td>
<td>2</td>
<td>private字段</td>
</tr>
<tr>
<td>00 05</td>
<td>5</td>
<td>指向常量#5 -字符串值:title</td>
</tr>
<tr>
<td>00 06</td>
<td>6</td>
<td>指向常量#6 -字符串值:Ljava/lang/String;</td>
</tr>
<tr>
<td>00 00</td>
<td>0</td>
<td>该字段没有携带属性</td>
</tr>
<tr>
<td><strong>字段表结束</strong></td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td><strong>方法表集合开始</strong></td>
<td>–</td>
<td>– </td>
</tr>
<tr>
<td>00 03</td>
<td>3</td>
<td>3个方法(位置:120/0)</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td><strong>方法1</strong> public方法</td>
</tr>
<tr>
<td>00 07</td>
<td>7</td>
<td>指向常量#7 -字符串值:inti&lt;&gt;</td>
</tr>
<tr>
<td>00 08</td>
<td>8</td>
<td>指向常量#8 -字符串值:()V</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td>该方法携带1个属性 </td>
</tr>
<tr>
<td>00 09</td>
<td>9</td>
<td>属性名称 指向常量#9 -字符串值:code </td>
</tr>
<tr>
<td>00 00 00 2f</td>
<td>47</td>
<td>属性的值占47个字符</td>
</tr>
<tr>
<td>0001…(47个字节)</td>
<td></td>
<td>属性的值</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td><strong>方法2</strong>  public方法 (位置160/1)</td>
</tr>
<tr>
<td>00 0e</td>
<td>14</td>
<td>指向常量#14 -字符串值:getTitle</td>
</tr>
<tr>
<td>00 0f</td>
<td>15</td>
<td>指向常量#15 -字符串值:()Ljava/lang/String</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td>该方法携带1个属性</td>
</tr>
<tr>
<td>00 09</td>
<td>9</td>
<td>属性名称 指向常量#9 -字符串值:code </td>
</tr>
<tr>
<td>00 00 00 2f</td>
<td>47</td>
<td>属性的值占47个字符</td>
</tr>
<tr>
<td>0001…(47个字节)</td>
<td></td>
<td>属性的值</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td><strong>方法3</strong>  public方法 (位置:190/e)</td>
</tr>
<tr>
<td>00 10</td>
<td>16</td>
<td>指向常量#16 -字符串值:setTitle</td>
</tr>
<tr>
<td>00 11</td>
<td>17</td>
<td>指向常量#17 -字符串值:(Ljava/lang/String;)V</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td>该方法携带1个属性</td>
</tr>
<tr>
<td>00 09</td>
<td>9</td>
<td>属性名称 指向常量#9 -字符串值:code </td>
</tr>
<tr>
<td>00 00 00 3e</td>
<td>62</td>
<td>属性的值占46个字符</td>
</tr>
<tr>
<td>0002..(62个字节)</td>
<td></td>
<td>属性的值</td>
</tr>
<tr>
<td><strong>方法表集合结束</strong></td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td>该class携带一个属性 (位置:1e0/a)</td>
</tr>
<tr>
<td>00 12</td>
<td>18</td>
<td>属性名称 指向常量#18 -字符串值:SourceFile</td>
</tr>
<tr>
<td>00 00 00 02</td>
<td>3</td>
<td>属性的值占2个字符</td>
</tr>
<tr>
<td>00 13</td>
<td></td>
<td>max_stack  max_locals</td>
</tr>
</tbody>
</table>
<p><em>表中（位置:x/y）对应上图中字节在WinHex中的位置</em></p>
<p>下面解析第一个方法<code>inti&lt;&gt;</code>中的code属性(位置从120/4到150/f)<br>根据code属性表结构</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>attribute_name_index</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>attributes_length</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>max_stack</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>max_locals</td>
<td>1</td>
</tr>
<tr>
<td>u4</td>
<td>code_lenght</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>code</td>
<td>code_lenght</td>
</tr>
<tr>
<td>u2</td>
<td>exception_table_length</td>
<td>1</td>
</tr>
<tr>
<td>exception_info</td>
<td>exception_table</td>
<td>exception_table_length</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<p>解析结果如下</p>
<table>
<thead>
<tr>
<th>16进制值</th>
<th>10进制值</th>
<th>解析</th>
</tr>
</thead>
<tbody>
<tr>
<td>00 09</td>
<td>9</td>
<td>属性名称 指向常量#9 -字符串值:code</td>
</tr>
<tr>
<td>00 00 00 2f</td>
<td>47</td>
<td></td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td>max_stack</td>
</tr>
<tr>
<td>00 01</td>
<td>1</td>
<td>max_locals</td>
</tr>
<tr>
<td>00 00 00 05</td>
<td>5</td>
<td>字节码数量</td>
</tr>
<tr>
<td>2A B7 00 01 B1</td>
<td>字节码</td>
</tr>
<tr>
<td>00 00</td>
<td></td>
<td>不抛出异常</td>
</tr>
<tr>
<td>00 02</td>
<td>2</td>
<td>携带2个属性</td>
</tr>
<tr>
<td>00 0a</td>
<td>10</td>
<td><strong>属性1</strong> attribute_name_index 指定变量#10 -字符串值:LineNumberTable</td>
</tr>
<tr>
<td>00 00 00 06</td>
<td>6</td>
<td>attribute_length </td>
</tr>
<tr>
<td>000100000006</td>
<td></td>
<td></td>
</tr>
<tr>
<td>00 0b</td>
<td>11</td>
<td><strong>属性2</strong> attribute_name_index   指定变量#11 -字符串值:LocalVariableTable</td>
</tr>
<tr>
<td>00 00 00 0c</td>
<td>12</td>
<td>attribute_length</td>
</tr>
<tr>
<td>000100000005000C000D0000</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>(LineNumberTable属性建立了字节码偏移量到源代码行号之间的联系,LocalVariableTable 属性建立了方法中的局部变量与源代码中的局部变量之间的对应关系)<br><strong>max_stack代表操作数栈深度的最大值。在方法执行的任意时刻，，操作数栈都不会超过这个深度。虚拟机运动的时候需要根据这个值来分配栈桢中的操作栈深度。<br>max_locals代表局部变量表所需的存储空间，单位是Variable Slot（虚拟机为局部变量分配内存所使用的最小单位。）<br>在实例方法局部变量表中会预留出第一个 Slot 位来存放对象实例引用，所以max_stack/max_locals为1</strong></p>
<p>最重要是字节码<code>2A B7 00 01 B1</code>，虚拟机将方法体中的代码转化为字节码存储在这里。  </p>
<p><code>2A</code> aload_0 将第0个Slot中reference类型的本地变量推送到操作数栈顶<br><code>B7</code> invokerspecial 以栈顶reference类型数据所指对象作为方法接收者，调用此对象的实例构造器方法，private方法或它的父类方法。该指令接收一个u2类型的参数说明具体调用哪一个方法。<br><code>0001</code> invokerspecial参数 指向常量#1<br><code>B1</code> return </p>
<h2 id="使用javap解析class文件"><a href="#使用javap解析class文件" class="headerlink" title="使用javap解析class文件"></a>使用javap解析class文件</h2><p>可以使用javap解析class文件</p>
<pre><code>&gt;javap -help
用法: javap &lt;options&gt; &lt;classes&gt;
其中, 可能的选项包括:
  -help  --help  -?        输出此用法消息
  -version                 版本信息
  -v  -verbose             输出附加信息
  -l                       输出行号和本地变量表
  -public                  仅显示公共类和成员
  -protected               显示受保护的/公共类和成员
  -package                 显示程序包/受保护的/公共类
                           和成员 (默认)
  -p  -private             显示所有类和成员
  -c                       对代码进行反汇编
  -s                       输出内部类型签名
  -sysinfo                 显示正在处理的类的
                           系统信息 (路径, 大小, 日期, MD5 散列)
  -constants               显示最终常量
  -classpath &lt;path&gt;        指定查找用户类文件的位置
  -cp &lt;path&gt;               指定查找用户类文件的位置
  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置
</code></pre><p>使用javap解析上述blog.class</p>
<pre><code>&gt; javap -v Blog.class
Classfile /F:/learning/Blog.class
  Last modified 2016-11-30; size 500 bytes
  MD5 checksum eae8926f4456cae2cf3bdef1048a4bea
  Compiled from &quot;Blog.java&quot;
public class bean.Blog
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V
   #2 = Fieldref           #3.#21         // bean/Blog.title:Ljava/lang/String;
   #3 = Class              #22            // bean/Blog
   #4 = Class              #23            // java/lang/Object
   #5 = Utf8               title
   #6 = Utf8               Ljava/lang/String;
   #7 = Utf8               &lt;init&gt;
   #8 = Utf8               ()V
   #9 = Utf8               Code
  #10 = Utf8               LineNumberTable
  #11 = Utf8               LocalVariableTable
  #12 = Utf8               this
  #13 = Utf8               Lbean/Blog;
  #14 = Utf8               getTitle
  #15 = Utf8               ()Ljava/lang/String;
  #16 = Utf8               setTitle
  #17 = Utf8               (Ljava/lang/String;)V
  #18 = Utf8               SourceFile
  #19 = Utf8               Blog.java
  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V
  #21 = NameAndType        #5:#6          // title:Ljava/lang/String;
  #22 = Utf8               bean/Blog
  #23 = Utf8               java/lang/Object
{
  public bean.Blog();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V
         4: return
      LineNumberTable:
        line 6: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lbean/Blog;

  public java.lang.String getTitle();
    descriptor: ()Ljava/lang/String;
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: getfield      #2                  // Field title:Ljava/lang/String;
         4: areturn
      LineNumberTable:
        line 11: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lbean/Blog;

  public void setTitle(java.lang.String);
    descriptor: (Ljava/lang/String;)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: aload_1
         2: putfield      #2                  // Field title:Ljava/lang/String;
         5: return
      LineNumberTable:
        line 15: 0
        line 16: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   Lbean/Blog;
            0       6     1 title   Ljava/lang/String;
}
SourceFile: &quot;Blog.java&quot;
</code></pre><p>javap已经详细地解析了class文件。</p>
]]></content>
      
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java内存回收]]></title>
      <url>https://binecy.coding.me/java-memory-recycle/</url>
      <content type="html"><![CDATA[<p>文章记录了java内存垃圾收集器回收的一些算法，及相关的垃圾收集器。<br><a id="more"></a></p>
<p>程序计数器, 虚拟机栈, 本地方法栈随线程而生, 随线程而灭, 不需要过多考虑回收.</p>
<p>垃圾回收主要关注Java堆和方法区.</p>
<h2 id="判断对象是否可用的算法"><a href="#判断对象是否可用的算法" class="headerlink" title="判断对象是否可用的算法"></a>判断对象是否可用的算法</h2><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>给对象中添加一个引用计数器, 每当有一个地方引用它时, 计数器就加1; 当引用失效时, 计数器就减1; 任何时刻计数器为0的对象就是不可能再被使用.<br>主流java虚拟机都没有选用计数算法管理内存, 因为它很难解决对象之间相互循环引用的问题.<br>循环引用</p>
<pre><code class="java">        Instance ojeA,ojeB;
        ojeA.instance = objB;
        ojeB.instance = objA;
</code></pre>
<p>上述代码中ojeA与ojeB都有引用指定对方，但它们再无其他任何引用, 实际上这两个对象已经不可能再被访问, 但是它们因为互相引用对方, 导致它们的引用计数都不为0, 于是引用计数算法无法通知GC收集器回收它们。</p>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>以一系列”GC Roots”对象作为起始点, 开始向下搜索, 搜索所走过的路径称为引用链.当GC Roots到一个对象没有引用链时, 证明此对象不可用.</p>
<p>可作为GC Roots的对象包括:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常用引用的对象</li>
<li>Native方法引用的对象</li>
</ul>
<h4 id="stop-the-world"><a href="#stop-the-world" class="headerlink" title="stop the world"></a>stop the world</h4><p>可达性分析必须在一个能确保一致性的快照中进行, 就是整个分析期间整个执行系统看起来就像被冻结在某个时间点上, 不可以出现分析过程中对象引用关系还在不断变化的情况. 这点导致GC进行时必须停顿所有的java执行线程.</p>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h3><p>分为”标记”和”清除”两个阶段:首先标记出所有需要回收的对象, 在标记完成后统一回收所有被标记的对象.</p>
<p>不足:<br>效率问题:标记和清除的效率都不高<br>空间问题:标记清除的产生大量不连续的内存碎片.<br><img src="/java-memory-recycle/1.png" alt=""></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存划分为容量大小相等的两块, 每次只使用基本一块. 当这一块内存用完了, 将存活的对象复制到另外一块, 将这一块内存一次清除.</p>
<p>不足:<br>可用内存缩小为原来的一半.<br><img src="/java-memory-recycle/2.png" alt=""></p>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记 - 整理算法"></a>标记 - 整理算法</h3><p>与标记 - 清除算法一样, 但后续步骤不是直接对可回收对象进行清理, 而是让所有存活的对象都向一端移动, 然后直接清理掉边界外的内存.<br><img src="/java-memory-recycle/3.png" alt=""></p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><p>JVM根据对象存活周期不同将内存划分为几块. 一般将Java堆分为年轻区和年老代.<br><img src="/java-memory-recycle/4.png" alt=""></p>
<h3 id="年轻区回收-Minor-GC"><a href="#年轻区回收-Minor-GC" class="headerlink" title="年轻区回收 Minor GC"></a>年轻区回收 Minor GC</h3><p>年轻区每次收集都有大批对象死去, 所以选用复制算法。<br>对象的内存分配都是先在Eden区域中进行的，当Eden区域的空间不足于分配新对象时，就会触发年轻区上的垃圾回收（发生在Eden和Survivor内存区域上），所有存活的对象（仍然可达对象）会被拷贝到其中一个Survivor区域。<br>当第二次minor gc被触发时，JVM会会将Eden内存区域和Survivor1内存区域存活的对象拷贝到新的Survivor2内存区域，并清空Eden内存区域和Survivor1内存区域。</p>
<h4 id="进入年老区"><a href="#进入年老区" class="headerlink" title="进入年老区"></a>进入年老区</h4><p>虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍存活并被移到Survivor空间，那对象年龄将被设为1。对象在Survivor区每经过一次Minor GC，年龄就加1。当它的年龄增加到一定程度（默认为15，可通过 -XX:maxtenuringthreshold配置）, 将被移动到年老区.</p>
<p>如果在Survivor空间中相同年龄的对象大小总和大于Survivor空间的一半, 年龄大于或等于该年龄的对象直接进行年老代, 无须等到maxtenuringthreshold要求的年龄.</p>
<p>对于大对象（需要大量连续内存空间的Java对象，最典型的大对象就是很长的字符串以及数组，如byte[]）<br>虚拟机提供 -XX:pretenuresizethreshold 参数, 令大于这个设置值的对象直接在年老代分配, 避免在Eden区及两个Survivor区之间发生大量内存复制。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>Minor GC时，如果一个Survivor区域无法容纳所有的存活对象，则Survivor区域无法容纳所有的存活对象将直接进入年老区。<br>发生Minor GC之前, 虚拟机会先检查年老代最大可用的连续空间是否大于年轻区所有对象总空间, 如果条件成立, Minor GC是安全的. 如果条件不成立, 虚拟机会查看HandlePromotionFailure设置值是否允许担保失败, 如果允许, 那么会继续检查年老代最大可用连续空间是否大于历次移动到年老代对象的平均大小, 如果大于, 将尝试进行一次Minor GC, 如果小于或不允许担保失败, 将进行Full GC。<br>如果年轻区中大量对象存活, 一个Survivor和年老代都无法容纳这些对象, 那么将发生担保失败.如果担保失败, 只好在失败后重新发起一次Full GC.</p>
<h3 id="年老代回收"><a href="#年老代回收" class="headerlink" title="年老代回收"></a>年老代回收</h3><p>年老代对象存活率高, 没有额外空间进行分配担保, 必须使用”标记 - 清除” 或 “标记 - 整理”</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="年轻区收集器"><a href="#年轻区收集器" class="headerlink" title="年轻区收集器"></a>年轻区收集器</h3><p><strong>Serial收集器</strong><br>单线程<br>Client模式下默认年轻区收集器  </p>
<p><strong>ParNew收集器</strong><br>Serial收集器的多线程版<br>许多虚拟机Server模式下首选的年轻区收集器</p>
<p><strong>Parallel Scavenge收集器</strong><br>年轻区收集器, 使用复制算法 并发<br>关注点不是尽可能缩短垃圾收集时用户线程的停顿时间，而是达到一个可控制的吞吐量（<em>吞吐量=运行用户代码时间/(运行用户代码时间+垃圾回收时间), 如虚假机运行100分钟, 其中垃圾收集花掉1分钟, 吞吐量就是99%</em>）  </p>
<p>停顿时间越短就越适合需要与用户交互的程序，而高吞吐量则可以高效地利用cpu时间，主要适用于后台运算而不需要过多交互的任务。</p>
<h3 id="年老区收集器"><a href="#年老区收集器" class="headerlink" title="年老区收集器"></a>年老区收集器</h3><p><strong>Serial old收集器</strong><br>Serial收集器的年老代版本<br>单线程, “标记 - 整理”算法<br>主要提供给Client模式下的虚构机使用</p>
<p><strong>Parallel old收集器</strong><br>Parallel Scavenge收集器的年老代版本<br>多线程, “标记 - 整理”算法<br>在注重吞吐量及CPU资源敏感的场合, 都可以优先使用Parallel Scavenge收集器加Parallel old收集器</p>
<p><strong>CMS收集器</strong><br>CMS等收集则致力于尽可能缩短垃圾收集时用户线程依赖时间, 适合于需要与用户交互的程序, 非常符合互联网站或B/S系统的服务端.<br>CMS收集器基于”标记 - 清除”算法，实现了让垃圾收集线程和用户线程(基本上)同时工作：  </p>
<ol>
<li>初始标记: stop the world 仅标记一下GC Roots能直接关联的对象, 速度很快  </li>
<li>并发标记: GC Roots tracing   </li>
<li>重新标记: stop the world 修正并发标记期间因用户程序继续运行而导致标记变动的那一部分对象的标记记录. 速度很快  </li>
<li>并发清除: 清除垃圾</li>
</ol>
<p>缺点  </p>
<ol>
<li>对CPU资源敏感：占用部分线程(CPU资源), 使用用户线程变慢, 总吞吐量降低.  </li>
<li>产生大量内存碎片</li>
<li>无法处理浮动垃圾：由于CMS并发清理时用户线程还在运行，还有会垃圾产生，CMS无法在当次收集中处理它们, 只能留待下一次GC时再清理。这部分垃圾称为”浮动垃圾”。 所以CMS需要预留部分空间提供给用户线程使用， 如果CMS运动期间预留的内存无法满足用户线程，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial old收集器重新进行年老代的垃圾收集，这样停顿时间更长了。</li>
</ol>
<h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1收集器可以作用于年轻区和年老区。</p>
<p>G1收集器比较复杂，可参考<a href="http://tech.meituan.com/g1.html" target="_blank" rel="external">Java Hotspot G1 GC的一些关键技术</a></p>
]]></content>
      
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java运行时内存概述]]></title>
      <url>https://binecy.coding.me/java-memory/</url>
      <content type="html"><![CDATA[<p>文章描述了java运行时内存分区，包括程序计数器，Java虚拟机栈，本地方法栈，Java堆，方法区以及java8内存分区的变化。<br><a id="more"></a></p>
<p><strong>运行时数据区域</strong><br>java虚拟机在执行java程序的过程中会把它管理的内存划分为若干不同的数据区域。这些区域都有各自的用途，以及创建和销毁时间。有的区域随着虚拟机启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。  </p>
<p><img src="/java-memory/3.png" alt=""></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>每一条java虚拟机线程都有自己的pc寄存器。<br>如果当前方法不是Native方法，pc寄存器会保存虚拟机正在执行的字节码指令的地址;如果当前方法是Native方法，则pc寄存器的值为undefined。</p>
<p>此区域任何情况都不能导致OutOfMemoryError情况的区域  </p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>线程私有,生命周期与线程相同.</p>
<p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表, 操作数栈, 动态链接, 方法出口等信息.每一个方法从调用直至执行完成的过程, 都对应一个栈帧在虚拟机栈中入栈到出栈的过程.</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度, 将抛出StackOverflowError异常.</p>
<p>如果虚拟机栈可以动态扩展, 但如果扩展时无法申请到足够的内存,或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈帧，则抛出OutOfMemoryError异常.</p>
<p>-Xss参数可以设定栈容量。</p>
<pre><code>/**
 * VM Args : -Xss128k
 */
public class JavaVMStackSOF {
    private int stackLength = 1;

    public void stackLeak() {
        stackLength++;
        stackLeak();
    }

    public static void main(String[] args) {
        JavaVMStackSOF oom = new JavaVMStackSOF();
        try {
            oom.stackLeak();
        } catch (Throwable e) {
            System.out.println(&quot;stack length : &quot; + oom.stackLength);
            e.printStackTrace();
        }
    }
}
</code></pre><p><code>stackLeak()</code>方法不断调用自身，导致虚拟机栈溢出，抛出异常<code>java.lang.StackOverflowError</code></p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>与虚拟机栈相似, 但它为虚拟机用到的Native方法服务.</p>
<p>同样抛出StackOverflowError异常和OutOfMemoryError异常.</p>
<p>本地方法无法设定（-Xoss无效）</p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>用于存放对象实例，所有线程共享<br>所有对象实例和数组都要在堆上分配.(栈上分配, 标量替换等优化技术除外)<br>可以处于物理上不连续的内存空间, 只要逻辑上是连续的即可.</p>
<p>-Xms128m JVM初始分配的堆内存<br>-Xmx512m JVM最大允许分配的堆内存，可按需扩展  </p>
<pre><code class="java">/**
 * VM Args : -Xms10m -Xmx10m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOM {
    public static void main(String[] args) {
        List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();
        while(true) {
            list.add(new Object());
        }
    }
}
</code></pre>
<p><code>list</code>不断存入创建的Object对象，导致Java堆内存不足，抛出<code>java.lang.OutOfMemoryError: Java heap space</code>异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。<br>运行时常量池是方法区的一部分，用于存储编译期生成的各种字面量和符号引用。</p>
<p>线程共享</p>
<p>当方法区无法满足内存分配需求时, 将抛出OutOfMemoryError异常.</p>
<p>方法区常被称为“永久代”，实际上Full GC会进行持久代的回收。</p>
<h2 id="jdk8变化"><a href="#jdk8变化" class="headerlink" title="jdk8变化"></a>jdk8变化</h2><p>jdk6:<br><img src="/java-memory/1.png" alt=""></p>
<p>jdk8:<br><img src="/java-memory/2.png" alt=""><br>从JDK7已经开始永久代的移除工作了，贮存在永久代的一部分数据已经转移到了Java Heap或者是Native Heap。但永久代仍然存在于JDK7，并没有完全的移除：符号引用(Symbols)转移到了native heap;字面量(interned strings)转移到了java heap;类的静态变量(class statics)转移到了java heap。<br>Jdk8 中方法区被完全的移除了，直接使用本地内存来表示类的元数据，这个区域就叫做元空间。<br>JVM会忽略PermSize和MaxPermSize这两个参数，也不会出现java.lang.OutOfMemoryError: PermGen error的异常了。  </p>
<pre><code>public class StringOomMock {
    private static String  base = &quot;string&quot;;
    public static void main(String[] args) {
        List&lt;String&gt; list = new ArrayList&lt;String&gt;();
        for (int i=0;i&lt; Integer.MAX_VALUE;i++){
            String str = base + base;
            base = str;
            list.add(str.intern());
        }
    }
}
</code></pre><p>在jdk8 下，抛出如下异常</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space
    at java.util.Arrays.copyOf(Arrays.java:3332)
    at java.lang.AbstractStringBuilder.expandCapacity(AbstractStringBuilder.java:137)
    at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:121)
    at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:421)
    at java.lang.StringBuilder.append(StringBuilder.java:136)
    at memory.StringOomMock.main(StringOomMock.java:14)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)

Process finished with exit code 1
</code></pre><p>可以看到发生了堆内存溢出，可见字符串常量已经由永久代转移到堆中。</p>
<h1 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h1><p>直接内存不属于虚拟机运行时数据，也不是Java虚拟机规范中定义的内存区域。<br>但可以通过NIO（DirectByteBuffer）操作直接内存，从而避免在Java堆和Native堆中复制数据。操作直接内存也可能导致DirectByteBuffer异常出现。<br>直接内存的分配不受Java堆大小的限制，但会受到本机总内存大小及处理器寻址空间的限制。</p>
<p>参考：<br><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">深入理解Java虚拟机（第2版）</a>  </p>
<p><a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="external">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></p>
<p><a href="http://droidyue.com/blog/2015/08/22/where-has-the-java-permgen-gone/index.html" target="_blank" rel="external">Java永久代去哪儿了</a></p>
]]></content>
      
        
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Wireshark分析http请求]]></title>
      <url>https://binecy.coding.me/wireshark-http/</url>
      <content type="html"><![CDATA[<p>使用Wireshark分析一个http请求的栗子，包括握手，挥手过程，内容传输等。<br><a id="more"></a></p>
<h2 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h2><p>client(10.3.20.42)向server(ec2-54-70-215-146….)发送http请求，获取一个html页面。</p>
<pre><code>curl http://54.70.215.146:8080/
</code></pre><p>使用Wireshark抓包<br><img src="http://ofbrwsjmr.bkt.clouddn.com/wireshark_http/1.png" alt="image"></p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>报文NO34,NO45,NO46为三次握手报文。（NO序号为Wireshark创建的序号，与http无关）</p>
<p>已知tcp报文格式为<br><img src="http://ofbrwsjmr.bkt.clouddn.com/wireshark_http/3.png" alt="tcp报文格式"></p>
<p>需要关注的tcp标志</p>
<blockquote>
<p>SYN：携带这个标志的包表示正在发起连接请求。因为连接是双向的，所以建立连接时，双方都要发一个SYN。<br>FIN: 携带这个标志位的包表示正在请求终止连接。因为连接是双向的，所以彻底关闭一个连接时，双方都要发一个FIN。<br>RST：用于重置一个混乱的连接，或拒绝一个无效的请求。</p>
<p>seq号：TCP提供有序的传输，所以每个数据段都要标上一个序号。当接收方接收到乱序的包时，可以根据序号重新排序。TCP是双向的，双方都可以是发送方，所以各自维护了一个Seq号。<br>ack号：确认号，接收方向发送方确认已经收到了哪些字节。如甲向乙发送了“Seq:x   len:y”的数据段给乙，那乙回复Ack为x+y，表示它已经收到x+y之前的所有字节。同样，Ack号恰好应该是发送方下一个Seq号。</p>
</blockquote>
<p>三次握手过程为</p>
<p><img src="/images/wireshark_http/1.png" alt="@startuml
    Client-&gt;&gt;Server:SYN=1 seq=x 
    Server-&gt;&gt;Client:SYN=1 ACK=1 seq=y ack=x+1
    Client-&gt;&gt;Server:ACK=1 seq=x+1 ack=y+1
@enduml"></p>
<p>(ACK=1表示ACK标志为1，ack则表示ack确认号)<br>现在来看报文No34,No45,No46<br>NO34是Client向Server发送SYN标识报文，seq=0，len=0<br>NO45是Server回复报文，seq=0，len=0， ack=1<br>No46是Client回复报文，seq=1，ack=1</p>
<h2 id="Http请求"><a href="#Http请求" class="headerlink" title="Http请求"></a>Http请求</h2><p>报文NO47是Client向Server发送的http请求<br>详细的报文内容为<br><img src="http://ofbrwsjmr.bkt.clouddn.com/wireshark_http/2.png?v=20150430" alt="image"></p>
<p>红框为Wireshark为分析的结果，可以查看到网络分层结构</p>
<pre><code>Ethernet II 以太网协议  
Internet Protocol Version 4  ip协议  
Transmission Control Protocol  tcp协议
Hypertext Transfer Protocol 超文本(http)协议
</code></pre><p>一个完整的http报文包括如下内容<br><img src="http://ofbrwsjmr.bkt.clouddn.com/wireshark_http/4.png" alt="image"></p>
<p>黑框为原始的报文数据，以16进制显示（我点击了红框中的Transmission Control Protocol，所以黑框中选中了tcp协议的数据）<br>按照上图tcp报文格式，可以自行分析tcp协议的数据：</p>
<pre><code>f868  源端口63592
1f90  目的端口8080
4b056340  序号号1258644288 
e7fec30c  确认号3892232972 
5018      二进制1010(数据偏移)00000(保留)011000 (标识位)
0100  窗口256
2c72 检验和   
0000 紧急指针
</code></pre><p>注意图中seq：1，ack：83是Wireshark对tcp进行了分析处理，将Tcp开始序号置为0了，不是真实的序号。<br>配置“编辑 -&gt; 首选项 -&gt; Protocols -&gt; Tcp”中，将Relative sequence numbers的选项取消，则可以可以看到真实的序号号和确认号了<br><img src="http://ofbrwsjmr.bkt.clouddn.com/wireshark_http/5.png" alt="image"></p>
<p>报文NO48为Server回复的Ack报文，ack=1+82=83</p>
<h2 id="Http回应"><a href="#Http回应" class="headerlink" title="Http回应"></a>Http回应</h2><p>NO49到NO53，是TCP层收到上层大块报文后分解发出的数据段。TCP根据MSS（即每个TCP包所能携带的最大数据量，报文NO34中已经指定了MSS为1460）进行分段发送。</p>
<p>这几个TCP segment数据段的ack都是83，len都是1460</p>
<p>报文No54为Client发送的Ack报文，ack = 1+1406*5=7301，seq=83，表示已经成功接收seq7301前的数据</p>
<p>NO55到NO57依然为TCP segment数据段。<br>报文NO58是Server发送的Http报文，包括了html页面中剩余部分，与前面的TCP segment数据段构成完整的html页面。  </p>
<p>NO59是Client发送的ack<br>NO60包括了两个标志，一个是Server的ack标志，别一个是Fin标志，表示Server请求关闭连接。  </p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>四次挥手过程</p>
<p><img src="/images/wireshark_http/2.png" alt="@startuml
    Server-&gt;&gt;Client: FIN=1 seq=x
    Client-&gt;&gt;Server: ACK=1 seq=y ack=x+1
    Client-&gt;&gt;Server: FIN=1 seq=x
    Server-&gt;&gt;Client: ACK=1 ack=y+1
@enduml"></p>
<p>上面已经说了，<br>报文60包括了FIN标志，Seq=82<br>NO62也包括了两个标志，一个ACK标志，ack序号为84，同时它也包括了FIN标志，seq序号为11370<br>报文No63为Server回复的ACK报文，ack序号为11371，四次挥手完成。</p>
<p>至此，一次完整的http请求完成了。</p>
<p>上述内容中并没有包括tcp的一个重要协议：滑动窗口协议(如报文NO34声明了自己的接收窗口Win=9182)<br><a href="http://coolshell.cn/articles/11564.html" target="_blank" rel="external">TCP 的那些事儿(上)</a><br><a href="http://coolshell.cn/articles/11609.html" target="_blank" rel="external">TCP 的那些事儿(下)</a></p>
<p>参考<br><a href="https://book.douban.com/subject/26268767/" target="_blank" rel="external">Wireshark网络分析就这么简单</a><br><a href="http://blog.csdn.net/doupei2006/article/details/7539945" target="_blank" rel="external">wireshark中“tcp segment of a reassembled pdu”的解释</a><br><a href="https://segmentfault.com/a/1190000006885287" target="_blank" rel="external">TCP三次握手四次挥手</a><br><a href="http://blog.csdn.net/qq_16681169/article/details/50831856" target="_blank" rel="external">TCP报文结构 </a></p>
<p><a href="https://wizardforcel.gitbooks.io/network-basic/content/index.html" target="_blank" rel="external">网络基本功系列</a></p>
]]></content>
      
        
        <tags>
            
            <tag> http </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gradle 入门]]></title>
      <url>https://binecy.coding.me/gradle-basic/</url>
      <content type="html"><![CDATA[<p>简单记录gradle入门使用的过程。<br><a id="more"></a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在 <a href="http://www.gradle.org/downloads" target="_blank" rel="external">官网</a> 下载（仅需要 Gradle的二进制发布包）  </p>
<p>解压，将解压目录中的bin目录添加到环境变量中  </p>
<p>环境变量中添加GRADLE_USER_HOME， 指定GRADLE用户空间目录<br>如果使用maven，也需要在环境变量中添加M2_HOME ，指向maven的安装目录。  </p>
<p>命令行运行gradle，安装成功则可以看到如下结果</p>
<pre><code># gradle
Starting a Gradle Daemon (subsequent builds will be faster)
:help

Welcome to Gradle 3.1.

To run a build, run gradle &lt;task&gt; ...

To see a list of available tasks, run gradle tasks

To see a list of command-line options, run gradle --help

To see more detail about a task, run gradle help --task &lt;task&gt;

BUILD SUCCESSFUL

Total time: 8.051 secs
C:\Users\bin&gt;
</code></pre><p>GRADLE_USER_HOME中已生成如下目录</p>
<pre><code>|-- caches
|-- daemon
|-- native
</code></pre><h2 id="配置java项目"><a href="#配置java项目" class="headerlink" title="配置java项目"></a>配置java项目</h2><p>创建目录结构</p>
<pre><code>mkdir -p src/main/java/hello
vim  src/main/java/hello/HelloWorld.java
</code></pre><p>HelloWorld.java内容为</p>
<pre><code>package hello;

public class HelloWorld {
   public static void main(String[] args) {
           System.out.println(&quot;hello,gradle&quot;);
    }
}
</code></pre><p>创建build.gradle，内容为</p>
<pre><code>apply plugin: &#39;java&#39;
</code></pre><p>此时项目目录结构为</p>
<pre><code>|-- build.gradle
|-- src
    |-- main
        |-- java
            |-- hello
                |-- HelloWorld.java
</code></pre><p>运行gradle任务</p>
<pre><code>gradle build
</code></pre><p>该任务执行以下操作：编译、执行单元测试、组装Jar文件</p>
<p>成功后可以看到输入<code>BUILD SUCCESSFUL</code></p>
<p>此时当前目录生成build目录，其中关键子目录</p>
<ul>
<li>classes: 保存被编译后的.class文件</li>
<li>reports: 构建报告（如：测试报告）</li>
<li>lib: 组装好的项目包（通常为：.jar或者.war文件）</li>
</ul>
<h2 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a>声明依赖</h2><p>创建测试类</p>
<pre><code>mkdir -p src/test/java/hello
vim src/test/java/hello/HelloTest.java
</code></pre><p>HelloTest内容为</p>
<pre><code>package hello;

import org.junit.Test;

public class HelloTest {
    @Test
    public void test() {
    System.out.println(&quot;hello,test&quot;);
    }

}
</code></pre><p>引用了junit的类，所以需要申明依赖于junit，build.gradle中添加内容</p>
<pre><code>repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
    compile &quot;junit:junit:4.12&quot;
}
</code></pre><p>repositories定义告诉构建系统通过Maven中央库来检索项目依赖的软件包<br>dependencies则声明项目依赖  </p>
<p>运行<code>gradle build</code>可以看到构建成功。</p>
<p>需要注意的是，上述代码声明的依赖compile范围的，即这个库在编译和运行时都需要（如果构建WAR文件，这个依赖文件会包括在/WEB-INF/libs目录下），<br>另外值得注意的依赖类型包括：</p>
<ul>
<li>providedCompile：在编译期间需要这个依赖包，但在运行期间可能由容器提供相关组件（比如：Java Servlet API）</li>
<li>testCompile：依赖项仅在构建和运行测试代码时需要，在项目运行时不需要这个依赖项。</li>
</ul>
<p>所以junit的声明应该为</p>
<pre><code>dependencies {
    testCompile(  
        &quot;junit:junit:4.11&quot;  
    ) 
}
</code></pre><h2 id="修改maven远程地址"><a href="#修改maven远程地址" class="headerlink" title="修改maven远程地址"></a>修改maven远程地址</h2><pre><code>repositories {
    mavenLocal()
    mavenCentral()
}
</code></pre><p>根据上述定义，Gradle会使用本地仓库，本地仓库路径使用maven配置路径，即M2_HOME/conf/settings.xml中localRepository指定目录，如果本地仓库不存在相关依赖，Gradle会创建maven远程仓库下载，默认地址为 <a href="https://repo1.maven.org/maven2/" target="_blank" rel="external">https://repo1.maven.org/maven2/</a> ，下载速度较慢，可以将下载地址修改为国内的Maven镜像仓库。<br>在GRADLE_USER_HOME/ 下添加文件init.gradle，内容如下：</p>
<pre><code>allprojects{
    repositories {
        def REPOSITORY_URL = &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39;
        all { ArtifactRepository repo -&gt;
            if(repo instanceof MavenArtifactRepository){
                def url = repo.url.toString()
                if (url.startsWith(&#39;https://repo1.maven.org/maven2&#39;) || url.startsWith(&#39;https://jcenter.bintray.com/&#39;)) {
                    project.logger.lifecycle &quot;Repository ${repo.url} replaced by $REPOSITORY_URL.&quot;
                    remove repo
                }
            }
        }
        maven {
            url REPOSITORY_URL
        }
    }
}
</code></pre><p>init.gradle文件其实是Gradle的初始化脚本(Initialization Scripts)，也是运行时的全局配置。<br>上述代码将默认地址修改为阿里提供的maven仓库。</p>
<p>运行<code>gradle build</code>可以看到如下输出</p>
<pre><code>Starting a Gradle Daemon (subsequent builds will be faster)
Repository https://repo1.maven.org/maven2/ replaced by http://maven.aliyun.com/nexus/content/groups/public/.
Repository https://repo1.maven.org/maven2/ replaced by http://maven.aliyun.com/nexus/content/groups/public/.
</code></pre><h2 id="Gradle-Wrappe"><a href="#Gradle-Wrappe" class="headerlink" title="Gradle Wrappe"></a>Gradle Wrappe</h2><p>Gradle Wrapper是开始一个Gradle构建的首选方式。它包含了windows批处理以及OS X和Linux的Shell脚本。这些脚本允许我们在没有安装Gradle的系统上执行Gradle构建。<br>build.gradle如下内容</p>
<pre><code>task wrapper(type: Wrapper) {
    gradleVersion = &#39;3.1&#39;
}
</code></pre><p>下载和初始化wrapper脚本，执行命令</p>
<pre><code>gradle wrapper
</code></pre><p><code>BUILD SUCCESSFUL</code>后，可以看到当前目录已生成了gradle，gradlew，gradlew.bat，当前目录概要为</p>
<pre><code>|-- build
|-- build.gradle
|-- gradle
|-- gradlew
|-- gradlew.bat
|-- src
</code></pre><p>现在Gradle Wrapper已经可以用于构建系统了，在任何地方，都运行wrapper脚本来构建系统</p>
<pre><code>./gradlew build
</code></pre><p>当第一次通过wrapper使用指定版本的Gradle构建系统时，wrapper首先下载对应版本的Gradle可执行文件。<br>可以直接将下载好的对应版本的Gradle可执行文件放到GRADLE_USER_HOME/wrapper/dists下对应的目录。</p>
<h2 id="多模块项目"><a href="#多模块项目" class="headerlink" title="多模块项目"></a>多模块项目</h2><p>创建一个新的目录，初始化</p>
<pre><code>gradle init
</code></pre><p>此时项目目录结构为</p>
<pre><code>├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle
</code></pre><p>创建两个子模块core和web，创建模块目录</p>
<pre><code>mkdir -p core/src/main/java
mkdir -p core/src/test/java
mkdir -p web/src/main/java
mkdir -p web/src/test/java
</code></pre><p>修改settings.gradle 文件，引入子模块</p>
<pre><code>include &#39;core&#39;,&#39;web&#39;
</code></pre><p>修改build.gradle，内容为</p>
<pre><code>apply plugin: &#39;java&#39;

// 所有子模块的通用配置
subprojects { 
    apply plugin: &#39;java&#39;

    repositories {
        mavenLocal()
        mavenCentral()
    }

    dependencies {
        testCompile(  
            &quot;junit:junit:4.11&quot;  
        ) 
    }

}

// 子模块配置
project(&#39;:core&#39;) {  
    dependencies {
        compile &quot;joda-time:joda-time:2.2&quot;
    }
}  


project(&#39;:web&#39;) {  

}
</code></pre><p>子模块配置也可以写在子模块目录build.gradle下。</p>
<p>参考<br><a href="http://www.importnew.com/15881.html" target="_blank" rel="external">使用Gradle构建Java项目</a><br><a href="https://yq.aliyun.com/articles/25589" target="_blank" rel="external">Gradle构建多模块项目 </a><br><a href="https://yrom.net/blog/2015/02/07/change-gradle-maven-repo-url/" target="_blank" rel="external">Gradle 修改 Maven 仓库地址</a></p>
<p>更多文档<br><a href="http://pkaq.org/gradledoc/docs/userguide/userguide.html" target="_blank" rel="external">Gradle 用户手册</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[effective java 泛型]]></title>
      <url>https://binecy.coding.me/effective-java-generic/</url>
      <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">《Effective Java》</a>读书笔记，关于泛型系列。<br><a id="more"></a></p>
<h2 id="不要在再使用原生态类型"><a href="#不要在再使用原生态类型" class="headerlink" title="不要在再使用原生态类型"></a>不要在再使用原生态类型</h2><p>声明中具有一个或多个 <em>类型参数</em> 的类或接口就是泛型</p>
<p>原生态类型：即不带任何实际类型参数的泛型，如List<e>对应的原生态类型为List。<br><strong>如果使用原生态类型，就失去了泛型在安全性和表述性方面所有优势。</strong></e></p>
<p>原生态类型List与参数化类型List<e>之间有区别在于前者逃避了泛型检查，而后者则表明它能够持有任意类型的对象。而且泛型有子类型化的规则，List<string>是原生态类型List的一个子类型，但不是参数化类型List<object>的子类型。</object></string></e></p>
<p>如果不关心或不确定实际的类型参数，可以使用无限制的通配符类型Set&lt;?&gt;，通配符类型是安全，不能将任何元素（除了null之外）放到Set&lt;?&gt;。</p>
<p>由于泛型在运行时被擦除，<strong>在类文字（class literal）中必须使用原生态类型</strong> 规范不允许使用参数化类型（但允许数组类型和基本类型），即List.class，String[].class和int.class是合法的，但List<string>.class和List&lt;?&gt;.class不合法。  </string></p>
<p>在参数化类型而非无限制通配符上使用instanceof操作符是非法的。<code>set instanceof Set&lt;?&gt;</code>是合法的，但与<code>set instanceof Set</code>无任何区别。</p>
<p>对泛型使用instanceof操作首选方案：</p>
<pre><code class="java">if(set instanceof Set) {
    Set&lt;?&gt; m = (Set&lt;?&gt;)set;
}
</code></pre>
<p>注意此处将set转换为通配符类型Set&lt;?&gt;，而不是原生类型Set</p>
<h2 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h2><p><strong>尽可能消除每一个非受检警告</strong><br>如果无法消除警告，而且可以证明引起警告的代码是类型安全的（只在在这种情况下），可以用一个@SuppressWarnings(“unchecked”)<br><strong>应该始终在尽可能小的范围中使用SuppressWarnings注解。永远不要在整个类上使用SuppressWarnings，这么做会掩盖重要的警告</strong>  </p>
<h2 id="列表优先于数组"><a href="#列表优先于数组" class="headerlink" title="列表优先于数组"></a>列表优先于数组</h2><p>数组是协变的：如果Sub是Sup的子类型，则Sub[]是Sup[]的子类型。<br>泛型是不可变的：对于任意两个不同的类型T1和T2，List<t1>既不是List<t2>的子类型，也不是List<t2>的超类型。</t2></t2></t1></p>
<p>创建泛型，参数化类型或参数化类型的数组都是非法的，如下语句无法通过编译：<code>new E()</code>, <code>new List&lt;String&gt;[]</code>和<code>new List&lt;E&gt;()</code></p>
<p>如果创建泛型数组合法，则编译器在其他正确的程序中发生的转换就会在运行时失败。</p>
<pre><code>List&lt;String&gt;[] strings = new List&lt;String&gt;[1];   // 假设编译通过
List&lt;Integer&gt; ints = Arrays.asList(42);
Object[] objects = strings;     // 数组是协变的，转化为Object[]就失去了类型检查
objects[1] = ints;
String s = strings[0].get(0);   //抛出异常ClassCastException
</code></pre><p>如果创建泛型数组出错，最好的解决方案是优先使用集合类型List<e>，而不是数组类型E[]。</e></p>
<h2 id="优先使用泛型"><a href="#优先使用泛型" class="headerlink" title="优先使用泛型"></a>优先使用泛型</h2><p>设计新类型时，如果客户需要（与Object）进行类型转换才能使用，则可以考虑使用泛型。<br>如</p>
<pre><code class="java">public class Stack {
    Object[] elements;  // 对象存储数组
    public Object pop() {
        ...
    }

    public void push(Object e) {
        ..
    }
    ... 
}
</code></pre>
<p>可以使用泛型</p>
<pre><code class="java">public class Stack&lt;E&gt; {
    E[] elements;  // 对象存储数组

    @SuppressWarnings(&quot;unchecked&quot;)
    public Stack() {
        elements = (E())new Object[default_initial_capacity];   // !   
    }

    public E pop() {
        ...
    }

    public void push(E e) {
        ..
    }
    ... 
}
</code></pre>
<p>注意上述代码中 <code>elements = (E())new Object[default_initial_capacity];</code> 语句中将Object数组转化为泛型数组，在无法使用列表的情况下，可以使用这种方法创建泛型数组。但相关的数组必须保存在一个私有的域中，永远不要返回给客户或传给任何方法，必须该数组不会存储类型错误的对象。</p>
<p>这个问题可以使用第二种方法，将elements域的类型改用Object[]，pop方法使用</p>
<pre><code class="java">public E pop() {
    @SuppressWarnings(&quot;unchecked&quot;)
    E result = (E)elements[--size];
    ...
}
</code></pre>
<p>数组类型的未受检转换比变量的未受检转换更危险，建议使用第二种方法。但如果需要从数组多处读取元素，第二种方法又需要多次转换，所以第一种更常用。</p>
<h2 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h2><p>与类型一样，为了确保新方法不用转换就可以使用，可以优先考虑泛型方法</p>
<h2 id="利用有限制通配符提升api的灵活性"><a href="#利用有限制通配符提升api的灵活性" class="headerlink" title="利用有限制通配符提升api的灵活性"></a>利用有限制通配符提升api的灵活性</h2><p>上述的Stack类中增加一个方法，将Iterable中所有的元素都加入到Stack中：</p>
<pre><code class="java">public void pushAll(Iterable&lt;E&gt; src) {
    for(E e: src) {
        push(e);
    }
}
</code></pre>
<p>但这个方法无法将Iterable<integer>加入到Stack<number>中，所以需要使用<em>有限制的通配符类型</em>，修改pushAll方法为</number></integer></p>
<pre><code class="java">public void pushAll(Iterable&lt;? extends E&gt; src) {
    for(E e: src) {
        push(e);
    }
}
</code></pre>
<p><code>Iterable&lt;？ extends E&gt; src</code>表示<em>类型为E的某种子类的Iterable</em>。<br>Stack类同样提供弹出所有元素到指定集合的方法：</p>
<pre><code class="java">public void popAll(Collection&lt;? super E&gt; dst) {
    while(!isEmpty()) {
        dst.add(pop());
    }
}
</code></pre>
<p>Collection&lt;? super E&gt; dst表示<em>类型为E的某种超类的集合</em>  </p>
<p>为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型。如果某个输入参数即是生产者，又是消费者，则应该使用严格的类型匹配。<br><strong>PECS表示producter-extends,consumer-super</strong><br>对于参数类型T的提供类，使用&lt;? extends T&gt;。如pushAll方法中的src参数产生E实例供Stack使用，所以src参数为提供都，类型为Iterable&lt;? extends E&gt;<br>对于参数类型T的消费者，使用&lt;? super E&gt;。如popAll的dst参数通过Stack消费E实例，所以dst参数为消费者，类型为Collection&lt;? super E&gt; dst。</p>
<p><strong>不要使用通配符类型作为返回类型，它会强制用户在客户端使用通配符类型</strong>  </p>
<p>考虑一个方法声明，该方法作用是求List中最大的元素。</p>
<pre><code>public static &lt;T&gt; T max(List&lt;T&gt; list) { ... }
</code></pre><p>但该方法声明存在问题，既然求最大的元素，那就要求List中每个元素都能够与列表其他元素相比较，所以可能要求它们实现Comparable接口：</p>
<pre><code>    public static &lt;T extends Comparable&gt; T max(List&lt;T&gt; list) { ...     }
</code></pre><p>但Comparable为泛型接口：</p>
<pre><code>public interface Comparable&lt;T&gt; {
    public int compareTo(T o);
}
</code></pre><p>所以需要将Comparable指定参数类型，所有的类型都可以与自身相比较，而且max方法要求参数类型T可以与其他参数类型T相比较，所以T应该实现Comparable<t></t></p>
<pre><code>    public static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list) { ... }
</code></pre><p>这样通过某个包含类型参数本身的表达式来限制类型参数，就是递归类型限制。</p>
<p>考虑下面两个接口：</p>
<pre><code>public interface ScheduledFuture&lt;V&gt; extends Delayed, Future&lt;V&gt; {
}

public interface Delayed extends Comparable&lt;Delayed&gt; {
}
</code></pre><p>如下代码无法编译</p>
<pre><code>List&lt;ScheduledFuture&gt; list = new ArrayList&lt;ScheduledFuture&gt;();
System.out.println(max(list));
</code></pre><p>ScheduledFuture继承了其父接口Delayed的Comparable声明，但它并没有声明自身实现Comparable<scheduledfuture><br>(ScheduledFuture也是泛型接口，此处为了方便展示直接使用原生态类型)</scheduledfuture></p>
<p>这里可以看到max方法中参数list为生产者，而Comparable<t>为消费者，Comparable.compareTo操作需要消费list中的T实例（并产生表示大小关系的数值），所以max声明修改</t></p>
<pre><code>public static &lt;T extends Comparable&lt;? super T&gt;&gt; T max(List&lt;? extends T&gt; list) { ... }
</code></pre><p>现在可以看到List<scheduledfuture> 可以作为max的传入参数了  </scheduledfuture></p>
<p>Comparable始终都是消费者，使用Comparable&lt;? super T&gt;优先于Comparable<t>,Comparator也是一样。</t></p>
<h2 id="优先使用类型安全的异构容器"><a href="#优先使用类型安全的异构容器" class="headerlink" title="优先使用类型安全的异构容器"></a>优先使用类型安全的异构容器</h2>]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[dubbo与dubbox入门]]></title>
      <url>https://binecy.coding.me/dubbo-dubbox/</url>
      <content type="html"><![CDATA[<p>记录一下dobbu及dubbox的入门过程及一些简单的栗子<br><a id="more"></a></p>
<h2 id="dubbo-service"><a href="#dubbo-service" class="headerlink" title="dubbo service"></a>dubbo service</h2><p>pom中添加依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
    &lt;version&gt;2.5.6&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>定义服务接口和服务类</p>
<pre><code>package com.study.service;

public interface HelloService {
    public String hello(String user) ;
}


package com.study.service.impl;

import com.study.service.HelloService;

public class HelloServiceImpl implements HelloService {
    public String hello(String user) {
        System.out.println(&quot; user : &quot; + user + &quot; say hello !&quot;);
        return &quot;hello ! &quot; + user;
    }
}
</code></pre><p>在目录resources/META-INF/spring下添加application.xml<br>（该目录不可任意修改，dubbo默认会读取该目录所有配置文件），文件内容如下</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:dubbo=&quot;http://code.alibabatech.com/schema/dubbo&quot;  
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans    
       http://www.springframework.org/schema/beans/spring-beans.xsd  
        http://code.alibabatech.com/schema/dubbo
        http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;
    &lt;dubbo:application name=&quot;base-service&quot;  /&gt;
    &lt;!-- 用dubbo协议在29115端口暴露服务 --&gt;
    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;29115&quot; /&gt;

    &lt;!-- 定义接口实现类 --&gt;
    &lt;bean id=&quot;helloService&quot; class=&quot;com.study.service.impl.HelloServiceImpl&quot;&gt;&lt;/bean&gt;
    &lt;!-- 声明需要暴露的服务接口 --&gt;
    &lt;dubbo:service interface=&quot;com.study.service.HelloService&quot; ref=&quot;helloService&quot; timeout=&quot;6000&quot;  registry=&quot;N/A&quot; /&gt;
&lt;/beans&gt;
</code></pre><p>配置文件中<code>registry=&quot;N/A&quot;</code>表示暴露的服务接口不注册任何注册中心。</p>
<p>resources下添加log配置log4j.properties：</p>
<pre><code>log4j.rootLogger=info, console

log4j.appender.console=org.apache.log4j.ConsoleAppender
log4j.appender.console.Threshold=debug
log4j.appender.console.layout=org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=%5p %d{MM-dd HH:mm:ss}(%F:%L): %m%n
</code></pre><p>此时配置文件目录结构为：</p>
<pre><code>|-- resources
    |-- META-INF
        |-- spring
            |-- application.xml
    |-- log4j.properties
</code></pre><p>添加主程序</p>
<pre><code>public class Main
{
    public static void main( String[] args )
    {

        com.alibaba.dubbo.container.Main.main(args);
    }
}
</code></pre><p>com.alibaba.dubbo.container.Main是dubbo提供的类，可以用来启动dubbo服务端。<br>运行Main.main方法，就已经完成了服务端的配置了。</p>
<p>window下查看29115端口的占用情况</p>
<pre><code>&gt; netstat -aon|findstr 29115
  TCP    0.0.0.0:29115          0.0.0.0:0              LISTENING       4484
  TCP    10.3.20.42:61814       10.3.20.42:29115       TIME_WAIT       0
  TCP    [::]:29115             [::]:0                 LISTENING       4484
</code></pre><h2 id="dubbo-client"><a href="#dubbo-client" class="headerlink" title="dubbo client"></a>dubbo client</h2><p>配置文件内容：</p>
<pre><code>&lt;!-- 服务消费者应用名称，不要与提供者应用名称一致 --&gt;
&lt;dubbo:application name=&quot;base-client&quot; /&gt;

&lt;!-- 生成远程服务代理，可以和本地bean一样使用HelloService --&gt;
&lt;dubbo:reference id=&quot;helloService&quot; interface=&quot;com.study.service.helloService&quot; url=&quot;dubbo://127.0.0.1:29115&quot;  timeout=&quot;60000&quot;/&gt;
</code></pre><p><code>url=&quot;dubbo://127.0.0.1:29115&quot;</code>表示通过url直接连接服务端。<br>客户端需要使用服务端暴露的服务接口<code>com.study.service.IService</code>，可以直接copy源文件或将其打包jar。</p>
<p>测试方法</p>
<pre><code>public static void main( String[] args ) {
    ClassPathXmlApplicationContext ctx = new  
    ClassPathXmlApplicationContext(new String[]{&quot;classpath:META-INF/spring/application.xml&quot;});
    ctx.start();

    HelloService service = (HelloService)ctx.getBean(&quot;helloService&quot;);

    System.out.println(service.hello(&quot;bin&quot;));
}
</code></pre><p>运行main方法，客户端就可以远程调用服务端的方法了。</p>
<h2 id="zookeeper注册中心"><a href="#zookeeper注册中心" class="headerlink" title="zookeeper注册中心"></a>zookeeper注册中心</h2><p>上述简单实例中并没有使用注册中心，下面使用zookeeper作为注册中心<br>服务端pom中添加zk依赖：</p>
<pre><code>&lt;!-- zookeeper 注册中心 --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
  &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
  &lt;version&gt;3.3.3&lt;/version&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;artifactId&gt;log4j&lt;/artifactId&gt;
      &lt;groupId&gt;log4j&lt;/groupId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt;
  &lt;artifactId&gt;zkclient&lt;/artifactId&gt;
  &lt;version&gt;0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>修改配置文件为：</p>
<pre><code>&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;
&lt;dubbo:application name=&quot;base-service&quot;  /&gt;
&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;
&lt;dubbo:registry address=&quot;zookeeper://54.70.215.146:2181&quot; /&gt;
&lt;!-- 用dubbo协议在29115端口暴露服务 --&gt;
&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;29115&quot; /&gt;

&lt;!-- 定义接口实现类 --&gt;
&lt;bean id=&quot;baseService&quot; class=&quot;com.study.service.BaseService&quot;&gt;&lt;/bean&gt;
&lt;!-- 声明需要暴露的服务接口 --&gt;
&lt;dubbo:service interface=&quot;com.study.service.IService&quot; ref=&quot;baseService&quot; timeout=&quot;6000&quot;/&gt;
</code></pre><p>重启服务端，在zk客户端中可以查看dubbo生成的文件</p>
<pre><code>[zk: 127.0.0.1:2181(CONNECTED) 1] ls /
[dubbo, zookeeper]
</code></pre><p>客户端修改配置文件：</p>
<pre><code>&lt;!-- 服务消费者应用名称，不要与提供者应用名称一致 --&gt;
&lt;dubbo:application name=&quot;base-client&quot; /&gt;
&lt;!-- 使用zookeeper注册中心订阅服务地址 --&gt;
&lt;dubbo:registry address=&quot;zookeeper://54.70.215.146:2181&quot;/&gt;

&lt;dubbo:reference id=&quot;service&quot; interface=&quot;com.study.service.IService&quot;   timeout=&quot;60000&quot;/&gt;
</code></pre><p>此时可以通过注册中心访问服务端了。</p>
<h2 id="dubbox入门"><a href="#dubbox入门" class="headerlink" title="dubbox入门"></a>dubbox入门</h2><p>dubbox是当当网对ddubbo的开源扩展，支持REST风格远程调用。项目地址：<a href="https://github.com/dangdangdotcom/dubbox" target="_blank" rel="external">https://github.com/dangdangdotcom/dubbox</a>  </p>
<p>dubbox并没有上传jar到maven仓库，所以需要编译java代码</p>
<pre><code>git clone https://github.com/dangdangdotcom/dubbox
</code></pre><p>在checkout出来的dubbox目录执行mvn install -Dmaven.test.skip=true来尝试编译一下dubbo（并将dubbo的jar安装到本地maven库）<br>（maven下载相关依赖包可能速度比较慢，我是在亚马逊 aws上编译成功的。）</p>
<p>这一步完成后，maven项目就可以直接引用dubbo 2.8.4了</p>
<h2 id="dubbox-service"><a href="#dubbox-service" class="headerlink" title="dubbox service"></a>dubbox service</h2><p>将上述dubbo service项目中pom中添加</p>
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
  &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
  &lt;version&gt;2.8.4&lt;/version&gt;
&lt;/dependency&gt;

&lt;!--  RESTEasy，JBoss实现JAX-RS --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
  &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt;
  &lt;version&gt;3.0.7.Final&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
  &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;
  &lt;version&gt;3.0.7.Final&lt;/version&gt;
&lt;/dependency&gt;


&lt;!-- tomcat --&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
  &lt;artifactId&gt;tomcat-embed-core&lt;/artifactId&gt;
  &lt;version&gt;8.0.11&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
  &lt;artifactId&gt;tomcat-embed-logging-juli&lt;/artifactId&gt;
  &lt;version&gt;8.0.11&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;javax.validation&lt;/groupId&gt;
  &lt;artifactId&gt;validation-api&lt;/artifactId&gt;
  &lt;version&gt;1.0.0.GA&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p><strong>（记得删除原来dubbo的引用）</strong></p>
<p>这里重新执行main方法，并使用dubbo client仍然能调用成功。</p>
<h2 id="REST远程调用"><a href="#REST远程调用" class="headerlink" title="REST远程调用"></a>REST远程调用</h2><p>配置文件resources/META-INF/spring/application.xml 添加rest协议：</p>
<pre><code>&lt;!-- 使用tomcat开放rest接口 --&gt;
&lt;dubbo:protocol name=&quot;rest&quot; port=&quot;8888&quot; threads=&quot;500&quot; contextpath=&quot;services&quot; server=&quot;tomcat&quot; accepts=&quot;500&quot;/&gt;
</code></pre><p>rest接口及实现</p>
<pre><code>package com.study.service;

public interface EchoService {
    String echo(String msg);
}



package com.study.service.impl;

import com.study.service.EchoService;
import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;  


@Path(value = &quot;echo&quot;)
public class EchoServiceImpl implements EchoService{
    @GET
    @Path(value = &quot;/{message}&quot;)
    public String echo(@PathParam(&quot;message&quot;) String message)
    {
        return message;
    }
}
</code></pre><p>配置文件resources/META-INF/spring/application.xml 添加rest开放接口</p>
<pre><code>&lt;bean id=&quot;echoService&quot; class=&quot;com.study.service.impl.EchoServiceImpl&quot;&gt;&lt;/bean&gt;
&lt;dubbo:service interface=&quot;com.study.service.EchoService&quot; ref=&quot;echoService&quot;  protocol=&quot;rest&quot;/&gt;
</code></pre><p>声明helloService使用dubbo协议，修改为</p>
<pre><code>&lt;dubbo:service interface=&quot;com.study.service.HelloService&quot; ref=&quot;helloService&quot; timeout=&quot;6000&quot; protocol=&quot;dubbo&quot;/&gt;
</code></pre><p>重新执行main方法，使用浏览器访问 <a href="http://localhost:8888/services/echo/123" target="_blank" rel="external">http://localhost:8888/services/echo/123</a> 就可以看到浏览器显示服务端返回的字符串”123”</p>
<p>待扩展：<br>dubbo 监控<br>dubbox 基于Kryo和FST的Java高效序列化实现</p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[resteasy入门]]></title>
      <url>https://binecy.coding.me/jersey-basis/</url>
      <content type="html"><![CDATA[<h3 id="集成tomcat"><a href="#集成tomcat" class="headerlink" title="集成tomcat"></a>集成tomcat</h3><p>创建maven项目</p>
<pre><code>mvn archetype:generate -DgroupId=com.maven -DartifactId=resteasyD  -DinteractiveMode=false -DarchetypeCatalog=local
</code></pre><p>pom文件</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;com.maven&lt;/groupId&gt;
  &lt;artifactId&gt;resteasyD&lt;/artifactId&gt;
  &lt;packaging&gt;war &lt;/packaging&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;name&gt;resteasyD&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;
  &lt;dependencies&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jaxrs&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;commons-httpclient&lt;/groupId&gt;
          &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
          &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
          &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;
          &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;
      &lt;artifactId&gt;resteasy-jettison-provider&lt;/artifactId&gt;
      &lt;version&gt;2.2.1.GA&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
          &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;com.sun.xml.bind&lt;/groupId&gt;
          &lt;artifactId&gt;jaxb-impl&lt;/artifactId&gt;
        &lt;/exclusion&gt;
        &lt;exclusion&gt;
          &lt;groupId&gt;javax.xml.stream&lt;/groupId&gt;
          &lt;artifactId&gt;stax-api&lt;/artifactId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;

  &lt;/dependencies&gt;


&lt;/project&gt;
</code></pre><p>创建service类</p>
<pre><code>package com.maven.resteasy;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;

@Path(value = &quot;echo&quot;)
public class Echo {
    @GET
    @Path(value = &quot;/{message}&quot;)
    public String echoService(@PathParam(&quot;message&quot;) String message)
    {
        return message;
    }
}
</code></pre><p>main目录下添加配置webapp/WEB-INF/web.xml，内容如下</p>
<pre><code>&lt;!DOCTYPE web-app PUBLIC
 &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;
 &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;

&lt;web-app&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;resteasy.resources&lt;/param-name&gt;
        &lt;param-value&gt;com.maven.resteasy.Echo&lt;/param-value&gt;
    &lt;/context-param&gt;

   &lt;listener&gt;
      &lt;listener-class&gt;
         org.jboss.resteasy.plugins.server.servlet.ResteasyBootstrap
      &lt;/listener-class&gt;
   &lt;/listener&gt;

   &lt;servlet&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;servlet-class&gt;org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher&lt;/servlet-class&gt;
   &lt;/servlet&gt;

   &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Resteasy&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
   &lt;/servlet-mapping&gt;
&lt;/web-app&gt;
</code></pre><p>配置中resteasy.resources对应的val指向Echo服务类。</p>
<p>项目结构为</p>
<pre><code>|-- resteasyD
    |-- main
        |-- java
            |-- com.maven.resteasy
                |-- Echo.java
    |-- webapp
        |-- WEB-INF
            |-- web.xml
</code></pre><p>使用maven导出war，放到tomcat/webapps下运行<br>浏览器访问 <a href="http://localhost:8080/resteasyD-1.0-SNAPSHOT/echo/123" target="_blank" rel="external">http://localhost:8080/resteasyD-1.0-SNAPSHOT/echo/123</a> (resteasyD-1.0-SNAPSHOT为导出war包名)，可以看到浏览器显示服务器返回的字符串”123”</p>
<h3 id="集成Grizzly"><a href="#集成Grizzly" class="headerlink" title="集成Grizzly"></a>集成Grizzly</h3><p>引用</p>
<pre><code>    &quot;org.glassfish.jersey.containers:jersey-container-grizzly2-servlet:2.16&quot;
    &quot;org.glassfish.jersey.media:jersey-media-moxy:2.16&quot;
</code></pre><pre><code>public class Blog {
    private String title;

    public String getTitle() {
        return title;
    }

    public void setTitle(String title) {
        this.title = title;
    }    
}

@Path(&quot;blog&quot;)
public class BlogService {
    private Logger logger = LoggerFactory.getLogger(BlogService.class);

    @GET
    @Path(&quot;ping&quot;)
    @Produces(MediaType.TEXT_PLAIN)
    public String getIt() {
        return &quot;hello,client&quot;;
    }

    @GET
    @Path(&quot;{id}&quot;)
    @Produces(MediaType.APPLICATION_JSON)
    public Blog getBlog(@PathParam(&quot;id&quot;) long id) {
        Blog blog = new Blog();
        blog.setTitle(&quot;id is &quot; + id);
        return blog;
    }

    @POST
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.TEXT_PLAIN)
    public String addBlog(Blog blog) {
        logger.info(&quot;post blog : {}&quot;, blog);
        return &quot;post success&quot;;
    }

    @DELETE
    @Path(&quot;{id}&quot;)
    @Produces(MediaType.TEXT_PLAIN)
    public String delete(@PathParam(&quot;id&quot;) long id) {
        logger.info(&quot;delete id : &quot; + id);

        return &quot;delete success&quot;;
    }

    @PUT
    @Path(&quot;{id}&quot;)
    @Produces(MediaType.TEXT_PLAIN)
    @Consumes(MediaType.APPLICATION_JSON)
    public String put(@PathParam(&quot;id&quot;)long id,Blog blog) {
        logger.info(&quot;id : {}, blog : {}&quot;, id , blog);

        return &quot;put success&quot;;
    }
}
</code></pre><p>启动Grizzly服务器</p>
<pre><code>public class JerseyMain {
    // Base URI the Grizzly HTTP server will listen on
    public static final String BASE_URI = &quot;http://localhost:8080/&quot;;

    /**
     * Starts Grizzly HTTP server exposing JAX-RS resources defined in this application.
     * @return Grizzly HTTP server.
     */
    public static HttpServer startServer() {
        // create a resource config that scans for JAX-RS resources and providers
        // in com.example package
        final ResourceConfig rc = new ResourceConfig().packages(&quot;service.blog&quot;);

        // create and start a new instance of grizzly http server
        // exposing the Jersey application at BASE_URI
        return GrizzlyHttpServerFactory.createHttpServer(URI.create(BASE_URI), rc);
    }

    /**
     * Main method.
     * @param args
     * @throws IOException
     */
    public static void main(String[] args) throws IOException {
        final HttpServer server = startServer();
        System.out.println(String.format(&quot;Jersey app started with WADL available at &quot;
                + &quot;%sapplication.wadl\nHit enter to stop it...&quot;, BASE_URI));
        System.in.read();
        server.stop();
    }
}
</code></pre><p>参考：<br><a href="http://blog.csdn.net/rnzuozuo/article/details/38349403" target="_blank" rel="external">利用resteasy框架构建rest webservice—-第一波：快速构建HelloWorld（实例、教程） </a></p>
]]></content>
      
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[tomcat配置https]]></title>
      <url>https://binecy.coding.me/tomcat-https/</url>
      <content type="html"><![CDATA[<p>记录一下tomcat配置https的方式<br><a id="more"></a></p>
<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><pre><code>$ keytool -genkey -alias tomcat  -keyalg RSA  -keystore tomcat.keystore
$ $Enter keystore password:
$ Re-enter new password:
$ What is your first and last name?
  [Unknown]:  a
$ What is the name of your organizational unit?
  [Unknown]:  a
$ What is the name of your organization?
  [Unknown]:  a
$ What is the name of your City or Locality?
  [Unknown]:  a
$ What is the name of your State or Province?
  [Unknown]:  a
$ What is the two-letter country code for this unit?
  [Unknown]:  a
$ Is CN=a, OU=a, O=a, L=a, ST=a, C=a correct?
  [no]:  y

$Enter key password for &lt;tomcat&gt;
        (RETURN if same as keystore password):
$Re-enter new password:
</code></pre><p><code>-keyalg RSA</code> 指定密钥的算法<br>上述操作需要输入keystore password密钥库口令和key password密钥口令。密钥库口令用于打开密钥库，而密钥口令用于在java中加载PrivateKey<br>执行完了后可以看到当前目前已生成了tomcat.keystore文件。</p>
<h2 id="导出crt证书"><a href="#导出crt证书" class="headerlink" title="导出crt证书"></a>导出crt证书</h2><pre><code>$ keytool -export -file tomcat.crt   -alias tomcat -keystore tomcat.keystore
$ Enter keystore password:
Certificate stored in file &lt;tomcat.crt&gt;
</code></pre><p>密码使用上面输入的密钥库口令</p>
<h2 id="将crt证书导入到JVM密钥库"><a href="#将crt证书导入到JVM密钥库" class="headerlink" title="将crt证书导入到JVM密钥库"></a>将crt证书导入到JVM密钥库</h2><pre><code>$ sudo keytool -import -keystore $JAVA_HOME/jre/lib/security/cacerts -file tomcat.crt -alias  tomcat
Enter keystore password:
Owner: CN=a, OU=a, O=a, L=a, ST=a, C=a
Issuer: CN=a, OU=a, O=a, L=a, ST=a, C=a
Serial number: 140233f6
Valid from: Fri Oct 28 11:41:25 UTC 2016 until: Thu Jan 26 11:41:25 UTC 2017
Certificate fingerprints:
         MD5:  94:24:86:8B:23:81:54:76:CA:52:7B:58:0C:6F:4A:5E
         SHA1: B7:53:92:61:92:16:1F:B3:07:63:5C:F6:67:A0:FD:7B:DD:A8:A0:50
         SHA256: B7:91:A5:B2:C7:46:C4:29:EB:31:78:C0:92:6F:A6:19:DA:B1:2C:5C:AF:57:30:D0:62:B2:55:9D:40:36:80:C2
         Signature algorithm name: SHA1withDSA
         Version: 3

Extensions:

#1: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 46 CD 82 57 6D DF 5D 82   35 59 B7 44 A0 99 58 36  F..Wm.].5Y.D..X6
0010: 97 4F 11 35                                        .O.5
]
]

$ Trust this certificate? [no]:  y
Certificate was added to keystore
</code></pre><p>密码使用changeit，这是JVM密钥库的密钥库口令</p>
<h2 id="修改tomcat配置"><a href="#修改tomcat配置" class="headerlink" title="修改tomcat配置"></a>修改tomcat配置</h2><p>修改tomcat/conf/server.xml的配置<br>将</p>
<pre><code>&lt;!--
    &lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; /&gt;
    --&gt;
</code></pre><p>修改为</p>
<pre><code>&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
                keyAlias=&quot;tomcat&quot;
               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;tomcat.keystore&quot; keystorePass=&quot;123456&quot;
 /&gt;
</code></pre><p>keystoreFile指向上一步中生成的tomcat.keystore文件，keystorePass使用tomcat.keystore生成时的密钥库口令。</p>
<p>此时tomcat7可以正常启动，但用chrome访问时会出现如下错误<br><img src="/images/tomcat_https/1.png" alt="image"></p>
<p>而在tomcat8 中，可以在logs/catalina.out查看到如下异常：<br><img src="/images/tomcat_https/2.png" alt="image"></p>
<p>将上述配置重新修改为以下内容，指定加密算法套件。</p>
<pre><code>&lt;Connector port=&quot;8443&quot; protocol=&quot;org.apache.coyote.http11.Http11Protocol&quot;
               maxThreads=&quot;150&quot; SSLEnabled=&quot;true&quot; scheme=&quot;https&quot; secure=&quot;true&quot;
                keyAlias=&quot;tomcat&quot;
               clientAuth=&quot;false&quot; sslProtocol=&quot;TLS&quot; keystoreFile=&quot;tomcat.keystore&quot; keystorePass=&quot;123456&quot;
    ciphers=&quot;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,
   TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384,TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_RC4_128_SHA,
   TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA256,
   TLS_RSA_WITH_AES_256_CBC_SHA,SSL_RSA_WITH_RC4_128_SHA&quot;
 /&gt;
</code></pre><p>重启tomcat，则可以正常访问。</p>
<p><a href="http://wiki.jikexueyuan.com/project/tomcat/ssl-tls.html" target="_blank" rel="external">tomcat-SSL/TLS 配置</a></p>
<p><a href="http://kb.cnblogs.com/page/194742/" target="_blank" rel="external">数字证书及CA的扫盲介绍</a></p>
<p><a href="http://blog.csdn.net/huaishuming/article/details/8965597" target="_blank" rel="external">完美配置Tomcat的HTTPS</a></p>
<p><a href="http://blog.csdn.net/nuanchun666/article/details/2947451" target="_blank" rel="external">各种数字证书区别 </a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一句话设计模式]]></title>
      <url>https://binecy.coding.me/design-mode/</url>
      <content type="html"><![CDATA[<p>简单记录个人对设计模式理解，错漏之处，还望指出<br><a id="more"></a></p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>客户不需要创建对象实例，由一个工厂类创建的具体产品类</p>
<pre><code>class  Factory {
    public static Component getComponent(int type) {    // type由客户指定或从配置中读取
        ...
    }
}
</code></pre><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>在工厂类中增加一个抽象工厂定义，产品类的实例化过程延迟到工厂子类完成（允许系统在不修改具体工厂角色的情况下引进新的产品）    </p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>使用一个工厂等级结构创建出属于不同产品等级结构的一个产品族中的所有对象<br>切换产品族的时候，只要提供不同的抽象工厂实现就可以<br>系统可以根据构件依赖定制抽象工厂，也可以由客户定制抽象工厂，提供给系统使用。<br>缺点：如果给整个产品族添加一个新的产品，那么就需要修改抽象工厂类，这样就会导致必须修改所有的工厂实现类。<br><img src="http://ofbrwsjmr.bkt.clouddn.com/design_patterns/1.png" alt="image"><br><img src="http://ofbrwsjmr.bkt.clouddn.com/design_patterns/2.png" alt="image"></p>
<h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><p>确保构件只有一个实例，并且构件需要向整个系统提供这个实例。</p>
<h3 id="创建者"><a href="#创建者" class="headerlink" title="创建者"></a>创建者</h3><p>构件使用创建者实现构件实例化的细节。<br>如果对象构造方法参数过多，可以使用内部创建者构造对象。  </p>
<h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>通过复制这个原型对象的办法创建出更多同类型的对象<br>如果对象需要深度复制，可以实现clone方法  </p>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="适配器"><a href="#适配器" class="headerlink" title="适配器"></a>适配器</h3><p>常用于转化api  </p>
<h3 id="桥梁"><a href="#桥梁" class="headerlink" title="桥梁"></a>桥梁</h3><p>…</p>
<h3 id="合成（组合）"><a href="#合成（组合）" class="headerlink" title="合成（组合）"></a>合成（组合）</h3><p>对于树结构关系的对象，将个体对象（叶子结点）和容器对象（非叶子结果）作同样处理（实现相同的接口），让客户可以将他们一致对待。<br>典型：把目录和文件当做同一种对象对待和处理  </p>
<h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><p>装饰者继承构件，和构件提供一样的接口，但装饰会添加额外的逻辑<br>可以将aop中的代理类视为装饰者<br>典型：Java I/O标准库的设计<br><img src="http://ofbrwsjmr.bkt.clouddn.com/design_patterns/3.png" alt="image"></p>
<h3 id="外观（门面）"><a href="#外观（门面）" class="headerlink" title="外观（门面）"></a>外观（门面）</h3><p>外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用，也减少外部系统与的耦合。</p>
<p><img src="http://ofbrwsjmr.bkt.clouddn.com/design_patterns/4.png" alt="image"></p>
<h3 id="享元"><a href="#享元" class="headerlink" title="享元"></a>享元</h3><p>以共享的方式高效地支持大量的细粒度对象<br><img src="http://ofbrwsjmr.bkt.clouddn.com/555.png" alt="image"><br>简单工厂FlyweightFactory负责创建和管理享元角色，他必须保证享元对象可以被系统适当地共享。<br>典型：string<br>享元是对象级别的, 即多处使用到相同内容对象的地方只需要使用同一个对象即可, 而单例是类级别的, 即这个类必须只能实例化出来一个对象。</p>
<p>代理模式：构件提供一个代理对象，并由代理对象控制对的引用。<br>在某些情况下，客户不想或者不能够直接引用构件，而代理对象可以在客户端和客户之间起到中介的作用。<br><img src="http://ofbrwsjmr.bkt.clouddn.com/666.png" alt="image"></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>每个链节对象都持有下一链节的引用从而连接起来形成一条责任链。请求在这个链上传递， 每个链节处理完后将请求传递给下一个链节。<br>客户并不知道具体哪一链节处理了这个请求，所以系统可以在不影响客户的情况下动态地重新组织和分配责任。<br>客户也可以根据需要自行组合责任链。<br>典型：Tomcat中的Filter，netty的ChannelHandler</p>
<h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>抽象类定义一系列抽象方法（这些方法会被系统逻辑所调用），这些方法（钩子方法）由客户具体实现。客户可以以不同的方式实现这些抽象方法，从而实现自己的逻辑。<br>典型：HttpService类中的service()方法会调用doPost/doPut/doDelete/doGet等方法，而这些do…方法则客户自行实现。</p>
<h3 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h3><p>给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。  </p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>将一个请求或者操作封装到对象中。命令模式使请求方与执行方解耦，系统可以轻松实现命令队列，命令日志化，撤销和恢复，复合命令或扩展新的命令</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>客户可以通过迭代器顺序地访问一个聚集中的元素而不必暴露聚集的内部元素。<br>遍历算法被封装在迭代器中，迭代的算法可以独立于聚集角色变化，聚集角色也可以实现多个迭代器<br>方法1：由聚集对象实现迭代方法next，如java.sql.ResultSet</p>
<pre><code>ResultSet rs;
while(rs.next()) {
    Object o = rs.getObject(i);
}
</code></pre><p>方法2：由聚集对象创建的iterator实现迭代方法next，如果java.util.List</p>
<pre><code>List&lt;String&gt; list ;
Iterator&lt;String&gt; iterator = list.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
}
</code></pre><h3 id="中介者"><a href="#中介者" class="headerlink" title="中介者"></a>中介者</h3><p>增加一个中介者对象，构件间的相互调用需要通过中介者调度。当构件间相互作用发生改变时，不会立即影响到其他构件之间的相互作用。从而保证这些相互作用可以彼此独立地变化。<br>构件间解耦，中介者集中控制交互，多对多关系变成一对多关系<br>缺点：<br>调停者过于复杂</p>
<p><img src="http://ofbrwsjmr.bkt.clouddn.com/777.jpg" alt="image"></p>
<h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><p>备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉(Capture)住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。  </p>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>将构件的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。<br>状态模式可以帮助避免if-else子句或者switch-case条件判定逻辑。<br><img src="http://ofbrwsjmr.bkt.clouddn.com/design_patterns/8.png" alt="image"></p>
<h3 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h3><p>针对一组算法，将每一种算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。<br>策略模式的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，所以实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。</p>
<p><strong>状态模式与策略模式区别</strong><br>状态模式根据不同的状态来决定具体行为，一种状态下只能有一种行为<br><img src="http://ofbrwsjmr.bkt.clouddn.com/design_patterns/9.png" alt=""></p>
<p>策略模式强调的是平等性与可替换性，所有策略是同一行为的不同实现，客户根据需要选择一种策略<br><img src="http://ofbrwsjmr.bkt.clouddn.com/design_patterns/10.png" alt=""></p>
<h3 id="访问者"><a href="#访问者" class="headerlink" title="访问者"></a>访问者</h3><pre><code>// 访问者
interface Visitor {
    void visit(Component c);    // 接收构件作为参数并作具体处理
}

// 构件
public Class Component {
    public int accept(Visitor visitor) {    // 接收访问者作为参数，并调用visit方法
        visitor.visit(this);    // 将自身传递给访问者
    }
}
</code></pre><p>事件回调也可以视为一种访问者模式</p>
<pre><code>button.setOnClickListener(new Button.OnClickListener() {    // 访问者Button.OnClickListener
    public void onClick(View v) {   // 将构件View传递给访问者
        ...
    }
});
</code></pre><h3 id="观察者（发布-订阅）"><a href="#观察者（发布-订阅）" class="headerlink" title="观察者（发布-订阅）"></a>观察者（发布-订阅）</h3><p>让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够做相应处理。</p>
<p>推模型:主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或大部分数据。</p>
<p>拉模型:主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取。<br>java.util.Observable类/Observer接口，提供了对观察者模式的支持。</p>
<p>观察者模式类似访问者模式的加强，支持一系列的观察者，构件更新时通知所有的观察者，并实现添加/移除观察者的操作。</p>
<p>参考：<br><a href="http://www.cnblogs.com/java-my-life/" target="_blank" rel="external">java_my_life</a><br><a href="http://it.deepinmind.com/designpattern/2014/03/10/DP-in-JDK.html" target="_blank" rel="external">细数JDK里的设计模式</a></p>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[java转义字符]]></title>
      <url>https://binecy.coding.me/java-escape-character/</url>
      <content type="html"><![CDATA[<p>简单总结了java中转义字符的使用。</p>
<a id="more"></a>
<p><strong>八进制转义序列</strong><br><code>\</code> + 三位八进制数字<br>范围: <code>&#39;\000&#39;</code>~<code>&#39;\377&#39;</code><br>如 <code>\101</code> 表示<code>A</code>（101为十进制数字65）</p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="external">ASCII字符集</a></p>
<p><strong>Unicode转义字符</strong><br><code>\u</code> + 四个十六进制数字<br>范围: <code>\u0000</code> ~ <code>\ufffff</code></p>
<p>参考：<a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%88%97%E8%A1%A8" target="_blank" rel="external">Unicode字符列表</a></p>
<p><strong>特殊字符</strong><br>双引号：\“<br>单引号：\‘<br>反斜线：\\</p>
<p><strong>控制字符</strong><br>回车：\r<br>换行：\n<br>走纸换页：\f<br>横向跳格：\t<br>退格：\b</p>
<p><strong>正则表达式中需要转义的字符</strong></p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>匹配整个字符串的起始位置，或者行的起始位置，如果在字符组内部，则表示排除型（negative）字符组</td>
</tr>
<tr>
<td>$</td>
<td>匹配整个字符串的结束位置，或者行的结束位置</td>
</tr>
<tr>
<td>()</td>
<td>分组，提供反向引用(gourp1) \1或多选分支</td>
</tr>
<tr>
<td>* + ?</td>
<td>量词，限定之前元素出现的次数</td>
</tr>
<tr>
<td>.</td>
<td>默认情况下匹配换行符之外的任意字符，在多行模式下可以匹配换行符</td>
</tr>
<tr>
<td>[</td>
<td>字符组的起始符号</td>
</tr>
<tr>
<td>\</td>
<td>反斜线用来表示转义序列，或去掉元字符的转义</td>
</tr>
<tr>
<td>{</td>
<td>重现限定符的开始</td>
</tr>
<tr>
<td>&#124;</td>
<td>划分多选分支（括号没有出现时，可以想象括号出现在整个表达式最外层）</td>
</tr>
</tbody>
</table>
<p>表格中的元字符在正则表达式中使用，需要使用反斜杠<code>\</code>转义为普通字符，但<code>\</code>在java中是特殊字符，需要使用<code>\\</code>表示</p>
<pre><code>String t = &quot;123|456|789&quot;;


t.replace(&quot;|&quot;, &quot;,&quot;);    // 123,456,789

t.replaceAll(&quot;\\|&quot;, &quot;,&quot;);   // 123,456,789

t.replaceFirst(&quot;\\|&quot;, &quot;,&quot;); // 123,456|789
</code></pre><p>注意上面三个方法，<br><code>replace(char oldChar, char newChar)</code>两个参数都是字符串，所以<code>|</code>不需要转义。<br><code>replace(CharSequence target, CharSequence replacement)</code>与<code>replaceAll(String regex, String replacement)</code>第一个参数为正则表达式，第二个参数为字符串。所以<code>|</code>需要使用转义<code>\\|</code></p>
<p>参考<br><a href="http://www.infoq.com/cn/news/2011/01/regular-expressions-1" target="_blank" rel="external"><br>正则表达式（一）：纠结的转义</a><br><a href="http://www.cnblogs.com/iyangyuan/p/4809582.html" target="_blank" rel="external">你真的会用java replaceAll函数吗？</a><br><a href="http://www.cnblogs.com/yaochc/p/4574910.html" target="_blank" rel="external">Java转义符\|</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql整数类型范围]]></title>
      <url>https://binecy.coding.me/mysql-int-range/</url>
      <content type="html"><![CDATA[<p>记录mysql整数类型使用时的一个误区<br><a id="more"></a></p>
<p>mysql建表语句中，<br>varchar(5)表示varchar最多可以存储5个字符（不是字节）<br>decimal(18,9)表示小数点两边各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点占1个字节。<br><strong>但整数类型int(5)并不表示int只可以存储5位的整数，<code>(5)</code>对于大多数应该没有意义，它不会限制值的合法范围，只是规定了MySql的一些交互工具（如MySql命令行客户端）用于显示字符的个数。对于存储和计算来说，int(1)和int(20)是相同的</strong>  <em>这点可能会造成误导，必须小心</em></p>
<p>下面是整数类型真正的有效值范围</p>
<table>
<thead>
<tr>
<th>type</th>
<th>Storage(Bytes)</th>
<th>Minimum Value</th>
<th>Maximum Value </th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td>Unsigned TINYINT</td>
<td>1</td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768</td>
<td>32768</td>
</tr>
<tr>
<td>Unsigned</td>
<td>2</td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608</td>
<td>8388608</td>
</tr>
<tr>
<td>Unsigned</td>
<td>3</td>
<td>0</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td>4</td>
<td>-2147483648</td>
<td>2147483647</td>
</tr>
<tr>
<td>Unsigned</td>
<td>4</td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808</td>
<td>9223372036854775807</td>
</tr>
<tr>
<td>Unsigned</td>
<td>8</td>
<td>0</td>
<td>18446744073709551615</td>
</tr>
</tbody>
</table>
]]></content>
      
        
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[effective java - 方法]]></title>
      <url>https://binecy.coding.me/effective-java-method/</url>
      <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">《Effective Java》</a>读书笔记，关于方法系列。<br><a id="more"></a></p>
<h2 id="检查参数有效性"><a href="#检查参数有效性" class="headerlink" title="检查参数有效性"></a>检查参数有效性</h2><p>应该在方法开头检查参数，如索引值必须大于0，对象引用不能为null（“应该在发生错误之后尽快检测错误”）</p>
<p>对于公有方法，要用Javadoc的@throws标签在文档中说明违反参数限制会抛出的异常。通常抛出IllegalArgumentException，IndexOutOfBoundException，NullPointerException异常。</p>
<p>如果因为无效参数值导致计算过程抛出的异常，与文档标明方法将抛出的异常不相符，应该使用异常转译。</p>
<p>对于未导出的方法，作为包的创建者，你可以控制这个方法将在哪些情况下被调用，因此你可以确保只将有效的参数值传递进来，所以，非公有方法应该使用断言（assertion）检查参数</p>
<p><strong>对于有些参数，方法本身没有用到，却被保存起来以后使用，检验这类参数的有效性尤其重要。</strong></p>
<p>如果有效检查非常昂贵或不切实际，可不用检查。如Collections.sort(List)不用提前检查每个元素是否能够相互比较，这正是sort方法应该做的事情。</p>
<!--more-->
<h2 id="必要时进行保护性拷贝"><a href="#必要时进行保护性拷贝" class="headerlink" title="必要时进行保护性拷贝"></a>必要时进行保护性拷贝</h2><p>考虑下面这个类是否为一个不可变类：</p>
<pre><code>public class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if(start.compareTo(end) &gt; 0) {
            throw new IllegalArgumentException(start + &quot; after &quot; + end);
        }
        this.start = start;
        this.end = end;
     }

    public Date getStart() { return start;     }

    public Date getEnd() { return end;    }

}
</code></pre><p>这并不是一个不可变类，如：</p>
<pre><code>Date start = new Date();
Date end = new Date();
Period period = new Period(start, end);
end.setYear(78);
</code></pre><p>可以看到period的内部被破坏</p>
<p><strong>对于构造器的每个可变参数进行保护性拷贝是必要的</strong></p>
<pre><code>public Period(Date start, Date end) {
    if(start.compareTo(end) &gt; 0) {
        throw new IllegalArgumentException(start + &quot; after &quot; + end);
    }
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());
}
</code></pre><p><strong>保护性拷贝在检查参数的有效性之前进行，并且有效性检查是针对拷贝之后的对象，而不是针对原始对象。</strong> 这样可以避免在“从检查参数开始，执行到拷贝参数之间的时间段”，其他线程修改参数</p>
<p>这里没有使用clone方法，因为Date非final类，不能保证子类clone方法一定返回类为java.util.Date的对象，子类可以返回恶意破坏的实例。<strong>对于参数类型可以被不信任方子类化的参数，不要使用clone方法进行保护性拷贝</strong></p>
<p>上面period仍然可以被改变：</p>
<pre><code>Period period = new Period(new Date(), new Date());
period.end.setYear(78);
</code></pre><p><strong>对返回可变域进行保护性拷贝</strong></p>
<pre><code>public Date getStart() { return new Date(start.getTime());     }
public Date getEnd() { return new Date(end.getTime());    }
</code></pre><p>访问方法进行保护性拷贝可以使用clone方法，因为确认Period内部实例为java.util.Date的对象</p>
<p>接受客户提供的对象，有必要考虑一下你的类是否容忍对象进入数据结构后发生变化，同样，返回内部可变组件到客户端之前也要考虑是否容忍对象改变。</p>
<h2 id="慎用重载"><a href="#慎用重载" class="headerlink" title="慎用重载"></a>慎用重载</h2><p>要调用哪个重载方法，是在编译时做出的决定。<br>避免胡乱使用重载机制，才能不会陷入到“对于任何一组实例的参数，哪个重载方法是适用的”的困扰中。<br><strong>安全而保守的策略是，永远不要导出两个具有相同参数数目的重载方法。如果方法使用可变参数，保守的策略是根本不要重载它。</strong><br><strong>但如果两个重载方法在同样的参数上被调用，它们执行相同的功能，重载就不会带来危害。可以让更具体化的重载方法把调用转发给更一般的重载方法。</strong></p>
<pre><code>public boolean contentEquals(StringBuffer sb) {
    return contentEquals((CharSequence)sb);
}
</code></pre><p><strong>自动装箱和泛型，会使谨慎重载显得更加重要了。</strong></p>
<p>下述代码无法正常删除list中的正数：</p>
<pre><code>Set&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;();
List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();

for(int i = -3; i &lt; 3; i++) {
    set.add(i);
    list.add(i);
}

for(int i = 0; i &lt; 3; i++) {
    set.remove(i);
    list.remove(i);
}
System.out.println(set + &quot; &quot; + list);
</code></pre><p>上述代码中输出结果为<br><code>[-3, -2, -1] [-2, 0, 2]</code><br>因为set只有remove(Object o)方法，而list重载了remove(Object o)和remove(int index)方法，这里调用到remove(int index)，即删除对应下标的元素。</p>
<pre><code>for(int i = 0; i &lt; 3; i++) {
    set.remove(i);
    list.remove((Integer)i);
}
</code></pre><p>上述代码才可以正常删除list中的正数。</p>
<h2 id="慎用可变参数"><a href="#慎用可变参数" class="headerlink" title="慎用可变参数"></a>慎用可变参数</h2><p>在定义参数数目不定的方法时，可变参数方法是一种很方便的方式，但是它们不应该被滥用，如果使用不恰当，会产生混乱的结果  </p>
<h2 id="返回零长度的数组或集合，而不是null"><a href="#返回零长度的数组或集合，而不是null" class="headerlink" title="返回零长度的数组或集合，而不是null"></a>返回零长度的数组或集合，而不是null</h2><h2 id="为所有导出的api编写文档注释"><a href="#为所有导出的api编写文档注释" class="headerlink" title="为所有导出的api编写文档注释"></a>为所有导出的api编写文档注释</h2><p><strong>在每个被导出的类，接口，构造器，方法和域声明之前增加一个文档注释</strong></p>
<p><strong>方法的文档注释应该简洁地描述它和客户端之间的约定。这个约定应该说明方法做了什么，而不是怎么做。</strong><br>文档还应该列举这个方法的所有前提条件和后置条件。前提条件是指为了使客户端能够调用这个方法，必须满足的条件。后置条件指调用成功后，哪些条件必须满足。</p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo next 添加背景图片]]></title>
      <url>https://binecy.coding.me/hexo-next-background/</url>
      <content type="html"><![CDATA[<p>记录一下怎样在hexo的next主题上添加背景图片<br><a id="more"></a></p>
<ol>
<li>在hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; images 下添加背景图片background.png</li>
<li><p>hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _schemes -&gt; Mist -&gt; index.styl，在文件开头添加如下样式：</p>
<pre><code>@media screen and (min-width: 768px) {
body { 
    background:url(/images/background.png);
    background-size: 100% 100%;
    background-attachment:fixed
}
}
</code></pre></li>
<li><p>如果需要去掉上方导航栏的背景色，可以在 hexo（hexo工程文件）-&gt; themes -&gt; next -&gt; source -&gt; css -&gt; _schemes -&gt; Mist -&gt; _header.styl 文件开始，将<br><code>.header { background: $whitesmoke; }</code> 修改为<br><code>.header { background: none; }</code></p>
</li>
</ol>
<p>参考：<br><a href="http://blog.csdn.net/wang631106979/article/details/51375184" target="_blank" rel="external">给hexo个人博客 next主题添加背景图片</a></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 内部类]]></title>
      <url>https://binecy.coding.me/java-inner-class/</url>
      <content type="html"><![CDATA[<p>本文记录了笔者对于内部类的一些思考及使用总结，不当之处，还望指教</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>成员内部类方法可以访问其外部类所有成员（属性和方法）（包括private成员）</strong> 而外部类也可以调用内部类所有成员(包括private成员)<br><strong>成员内部类可以用可见性修饰符private,protected,public修饰</strong></p>
<p><strong>方法内部类可以访问其外部类所有成员(包括private成员)，也可以访问所在方法<code>final</code>修饰的局部变量</strong></p>
<p>非静态内部类依赖于外部类，不能有<em>非final修饰的static属性</em>。</p>
<p>静态内部类可以使用可见性修饰符修饰，不能访问外部类非static的属性和方法。</p>
<h2 id="使用情景"><a href="#使用情景" class="headerlink" title="使用情景"></a>使用情景</h2><p>使用内部类主要利用它的两个特点： </p>
<ol>
<li>内部类拥有指向外部类的一个引用，所以它们能访问外部类的成员（包括private成员）——毋需取得任何资格。  </li>
<li>内部类可以使用可见性修饰符修饰，可以非常方便地隐藏实施细节。</li>
</ol>
<pre><code>interface Selector&lt;T&gt; {
    boolean end();
    T current();
    void next();
}


public class Sequence&lt;T&gt; {
    private T[] o;
    private int next = 0;
    public Sequence(int size) {
        o = (T[]) new Object[size];
    }
    public void add(T x) {
        if(next &lt; o.length) {
            o[next] = x;
            next++;
        }
    }

    private class SSelector&lt;T&gt; implements Selector&lt;T&gt; {
        int i = 0;
        public boolean end() {
            return i == o.length;
        }
        public T current() {
            return (T)o[i];
        }
        public void next() {
            if(i &lt; o.length) i++;
        }
    }
    public Selector getSelector() {
        return new SSelector();
    }
}
</code></pre><p>Sequence如果不使用内部类，是无法实现一个Selector对T[]进行操作，因为T[]数组是private，外部类无法访问。<br>同时SSelector使用了private修饰，其他类可以使用<br><code>Selector s = new Sequence(10).getSelector();</code><br>来引用，但完成无法访问SSelector的实现。<br>使用内部类可完全禁止其他人依赖类型编码，并可将具体的实施细节完全隐藏起来。</p>
<p> <strong>匿名内部类实现事件回调</strong><br> 由于内部类的这两个特点，使得内部类非常适用于实现事件回调操作。</p>
<pre><code> Arrays.sort(persons, new Comparator&lt;Person&gt;() {
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge();
    }
});
</code></pre><p>这是匿名内部类最常使用的情况了</p>
<p><strong>双重继承</strong><br>这种使用情况并不多</p>
<pre><code>class Camera {
    public void photograph() {};
}

class  PlayStation {
    public void play() {};
}

public class  Phone extends  PlayStation {
    class  PhoneWithCamera  extends  Camera {
        public void screenshot() {
            play();
            photograph();
        }
    }
}
</code></pre><p>内部类PhoneWithCamera可以同时调用Camera和PlayStation类的方法，与双重继承有点相似<br>但其实内部类更类似于自动组合了其外部类：</p>
<pre><code>class  PhoneWithCamera  extends  Camera { 
    private Phone phone =  new Phone(); // 组合了一个外部类对象
}
</code></pre><p><strong>由于内部类自动持有对外部类的引用，所以也要考虑其对内存回收的影响</strong></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[java 路径]]></title>
      <url>https://binecy.coding.me/java-path/</url>
      <content type="html"><![CDATA[<p>总结了一下java中获取路径的一些方法。<br><a id="more"></a></p>
<h3 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h3><p>System.getProperty(“user.dir”) 可以获取java虚拟机调用目录，即当前用户目录。<br>JAVA IO操作中相对路径都是该路径。  </p>
<pre><code>public class Path {
    public static void main(String[] args) {
        System.out.println(System.getProperty(&quot;user.dir&quot;));
    }
}
</code></pre><p>如Path类位于<code>E:\java</code><br>运行Path类：</p>
<pre><code>$ java Path
E:\java
</code></pre><p>可以看到输入Path类所在路径</p>
<p>但在tomcat启动的web项目中，System.getProperty(“user.dir”)获取到的是<code>tomcat/bin</code>目录<br>在eclipse或idea等IDE中获取的结果也不样<br>使用相对目录的缺点是<strong>无法获取一致的路径</strong></p>
<h3 id="classpath"><a href="#classpath" class="headerlink" title="classpath"></a>classpath</h3><p>默认情况下classpath即编译文件.class的输出路径。  </p>
<h4 id="Class-getResource"><a href="#Class-getResource" class="headerlink" title="Class.getResource"></a>Class.getResource</h4><p>Class.getResource(“/“) 可以获取表示classpath的URL<br>Class.getResource(“”) 可以获取表示该类编译后class文件所在目录的URL</p>
<pre><code>package com.study.path;

import org.junit.Test;

public class ClassPath {

    @Test
    public void testClassGetResource() {
        System.out.println(this.getClass().getResource(&quot;&quot;).getPath());
        System.out.println(this.getClass().getResource(&quot;/&quot;).getPath());
    }
}
</code></pre><p>输出</p>
<pre><code>/F:/maven_study/target/test-classes/com/study/path/     # ClassPath.class目录
/F:/maven_study/target/test-classes/
</code></pre><p><strong>URL使用了utf-8字符集对路径进行了编码，会对中文和空格进行转换，可以调用URLDecoder.decode方法进行解码获取原始路径。</strong></p>
<pre><code>String classPath = java.net.URLDecoder.decode(classPath, &quot;utf-8&quot;);
</code></pre><h4 id="ClassLoader-getResource"><a href="#ClassLoader-getResource" class="headerlink" title="ClassLoader.getResource"></a>ClassLoader.getResource</h4><p>ClassLoader.getResource(“”)  可以获取表示classpath的URL<br><strong>ClassLoader.getResource(“/“)返回null，参数不能以/开始</strong></p>
<pre><code>@Test
public void testClassLoaderGetResource() {
    System.out.println(Thread.currentThread().getContextClassLoader().getResource(&quot;&quot;).getPath());
}
</code></pre><p>输出</p>
<pre><code>/F:/maven_study/target/test-classes/
</code></pre><p><em>建议使用ClassLoader.getResource</em></p>
<p>参考:<br><a href="http://blog.csdn.net/magi1201/article/details/18731581" target="_blank" rel="external">java代码中获取classpath路径 </a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[spring boot 配置shiro]]></title>
      <url>https://binecy.coding.me/spring-boot-shiro/</url>
      <content type="html"><![CDATA[<p>记录spring boot中配置shiro的过程及一些小栗子<br><a id="more"></a></p>
<h2 id="spring-boot-配置shiro"><a href="#spring-boot-配置shiro" class="headerlink" title="spring boot 配置shiro"></a>spring boot 配置shiro</h2><h3 id="由于使用了maven，所以先编辑pom"><a href="#由于使用了maven，所以先编辑pom" class="headerlink" title="由于使用了maven，所以先编辑pom"></a>由于使用了maven，所以先编辑pom</h3><pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
      &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="添加主程序类和一个服务类"><a href="#添加主程序类和一个服务类" class="headerlink" title="添加主程序类和一个服务类"></a>添加主程序类和一个服务类</h3><pre><code>@EnableWebMvc
@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application extends WebMvcConfigurerAdapter {
    public static void main(String[] args) throws Exception {
        SpringApplication.run(Application.class, args);
    }
}

@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @ResponseBody
    @RequestMapping(value = &quot;/hello&quot;)
    public String hello() {
        return &quot;hello &quot;;
    }
}
</code></pre><p>此时运行主程序类，浏览器访问 <a href="http://localhost:8080/user/hello" target="_blank" rel="external">http://localhost:8080/user/hello</a> ,可以看到服务器返回字符串：hello</p>
<h3 id="实现用户认证"><a href="#实现用户认证" class="headerlink" title="实现用户认证"></a>实现用户认证</h3><p><strong>现在实现需求：用户需要登录后才能访问地址 <a href="http://localhost:8080/user/hello" target="_blank" rel="external">http://localhost:8080/user/hello</a> </strong></p>
<h4 id="实现AuthorizingRealm"><a href="#实现AuthorizingRealm" class="headerlink" title="实现AuthorizingRealm"></a>实现AuthorizingRealm</h4><p>AuthorizingRealm是shiro中的权限管理器，可以对用户进行认证和授权操作<br>添加如下类：</p>
<pre><code>public class SimpleRealm  extends AuthorizingRealm {

    /**
     * 授权
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    /**
     * 认证
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        UsernamePasswordToken credentials = (UsernamePasswordToken) authenticationToken;

        String userName = credentials.getUsername();
        String password = new String(credentials.getPassword());

        // 固定用户：u1:123和u2:123
        if( (userName.equals(&quot;u1&quot;) &amp;&amp; password.equals(&quot;123&quot;)) || (userName.equals(&quot;u2&quot;) &amp;&amp; password.equals(&quot;123&quot;))) {
            return new SimpleAuthenticationInfo(userName, password,userName);
        } else {
            throw new AuthenticationException();
        }

    }
}
</code></pre><p><code>doGetAuthenticationInfo</code>方法对用户身份进行认证操作，SimpleRealm固定了两个用户，这里可以实现从数据库中查询用户信息进行认证。<br><code>doGetAuthorizationInfo</code>方法对用户身份进行授权操作，暂不使用</p>
<h4 id="配置过滤器"><a href="#配置过滤器" class="headerlink" title="配置过滤器"></a>配置过滤器</h4><p>添加如下配置类：  </p>
<pre><code>@Configuration
public class ShiroConfiguration {
    /**
     * 创建ShiroFilterFactoryBean，提供给spring使用
     */
    @Bean
    public ShiroFilterFactoryBean shiroFilter() {
        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
        factoryBean.setSecurityManager(securityManager());  // 配置安全管理器

        Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMapping);

        return factoryBean;
    }


    public DefaultWebSecurityManager securityManager() {
        final DefaultWebSecurityManager securityManager
                = new DefaultWebSecurityManager();
        List&lt;Realm&gt; list = new ArrayList&lt;&gt;();
        list.add(new SimpleRealm());    // 使用SimpleRealm权限管理器
        securityManager.setRealms(list);
        return securityManager;
    }
}
</code></pre><p><code>filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);</code>配置了调用以/user开始的url，必须通过authc这个过滤器（authc是shiro默认提供的form认证过滤器）</p>
<p>这里访问<a href="http://localhost:8080/user/hello，可以看到浏览器自动跳转到http://localhost:8080/login.jsp" target="_blank" rel="external">http://localhost:8080/user/hello，可以看到浏览器自动跳转到http://localhost:8080/login.jsp</a> ，这是当用户没有进行认证操作时，shiro自动将url跳转到login.jsp页面（可通过<code>factoryBean.setLoginUrl(String);</code>进行配置）。</p>
<h4 id="添加用户登录接口"><a href="#添加用户登录接口" class="headerlink" title="添加用户登录接口"></a>添加用户登录接口</h4><p>UserController中添加如下方法：</p>
<pre><code>@ResponseBody
@RequestMapping(value = &quot;/login&quot;)
public String login(@RequestParam(&quot;user&quot;)String user, @RequestParam(&quot;password&quot;)String password) {
    Subject subject = SecurityUtils.getSubject();
    UsernamePasswordToken token = new UsernamePasswordToken(user, password);
    try {
        subject.login(token);   // 用户认证并登录
        return &quot;login success&quot;;
    } catch (AuthenticationException e) {
        e.printStackTrace();
        return &quot;login fail&quot;;
    }
}
</code></pre><p>调用<code>subject.login(token);</code>，shiro将进行用户认证操作，用户信息错误将抛出异常。</p>
<p>过滤配置修改：</p>
<pre><code>Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();

filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);    // 不需要任何过滤器

filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
</code></pre><p><strong>注意路径表达式按事先定义好的顺序判断传入的请求，并遵循 FIRST MATCH WINS 这一原则。/user/login必须要/user/<strong>之前加入filterChainDefinitionMapping，如果调换顺序，当访问/user/login时，由于先匹配了`(“/user/</strong>“, “authc”)<code>,则</code>(“/user/login”, “anon”)`永远不匹配到</strong></p>
<p>访问登录接口<br><a href="http://localhost:8080/user/login?user=u1&amp;password=123" target="_blank" rel="external">http://localhost:8080/user/login?user=u1&amp;password=123</a> 完成登录, 再访问<br><a href="http://localhost:8080/user/hello" target="_blank" rel="external">http://localhost:8080/user/hello</a><br>可以看到访问正常</p>
<h3 id="实例用户授权"><a href="#实例用户授权" class="headerlink" title="实例用户授权"></a>实例用户授权</h3><p><strong>现在实现需求：UserController添加一个sendGift接口，该接口必须拥有admin角色的用户才能访问</strong></p>
<p>添加sendGift接口</p>
<pre><code>@ResponseBody
@RequestMapping(value = &quot;/sendGift&quot;)
public String sendGift() {
    return &quot;success&quot;;
}
</code></pre><p>添加url过滤：</p>
<pre><code>Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();

filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);

filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,roles[user]&quot;);

filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
</code></pre><p><code>filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,roles[user]&quot;);</code>配置了访问<code>/user/sendGift</code>的用户必须拥有user角色( roles也是shrio默认提供的角色过滤器)<br>可以发现，此时即使u1登录了，当访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a> 时，仍然返回401的访问错误。</p>
<p>这里需要修改SimpleRealm中的授权操作，对用户添加对应的角色权限<br>修改SimpleRealm中的doGetAuthorizationInfo方法为</p>
<pre><code>/**
 * 授权
 */
@Override
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
    Set&lt;String&gt; names = principalCollection.getRealmNames();
    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();
    if(names.contains(&quot;u1&quot;)) {
        authorizationInfo.addRole(&quot;user&quot;);  // 为u1用户添加user角色
    }
    return authorizationInfo;
}
</code></pre><p>此时用户u1只要登录，就可以访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a> 了</p>
<p><strong>现对需求进行扩展，要求sendGift接口不仅user角色可以访问，admin管理角色也可以访问</strong><br>尝试对url过滤配置进行如下修改</p>
<pre><code>Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();

filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);

filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,roles[user,admin]&quot;);

filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
</code></pre><p>但现在导致的问题是sendGift接口不仅admin角色无法访问，连原来的user角色都不可以访问了。原因是roles默认过滤器对<code>[user,admin]</code>处理是要求用户同时拥有user和admin两个角色。<br>这里我们需要自定义一个过滤器，支持只要拥有user角色或admin角色就通过验证的需求。</p>
<pre><code>public class MyRolesAuthorizationFilter  extends AuthorizationFilter {
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
        Subject subject = this.getSubject(request, response);
        String[] rolesArray = (String[])((String[])mappedValue);
        if(rolesArray != null &amp;&amp; rolesArray.length != 0) {
            for(String role : rolesArray) {
                if(subject.hasRole(role)) { // 只在用户拥有定义中的任一角色，则通过验证
                    return true;
                }
            }

            return false;
        } else {
            return true;
        }
    }
}
</code></pre><p>url配置修改为：</p>
<pre><code>@Bean
public ShiroFilterFactoryBean shiroFilter() {
    ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
    factoryBean.setSecurityManager(securityManager());  // 配置安全管理器

    // 配置自定义的过滤器
    Map&lt;String,Filter&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;myRoles&quot;, new MyRolesAuthorizationFilter());
    factoryBean.setFilters(map);

    Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();
    filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);
    filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,myRoles[user,admin]&quot;);    // 使用自定义的过滤器myRoles
    filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
    factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMapping);

    return factoryBean;
}
</code></pre><p>此时只要通过登录，拥有user角色的u1可以访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a> 。<br>其他用户如u2，只要拥有user角色或admin角色也就可以访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a></p>
<h2 id="jquery-ajax实现CORS跨域，shrio的一些问题"><a href="#jquery-ajax实现CORS跨域，shrio的一些问题" class="headerlink" title="jquery ajax实现CORS跨域，shrio的一些问题"></a>jquery ajax实现CORS跨域，shrio的一些问题</h2><h3 id="jquery发送Cookies"><a href="#jquery发送Cookies" class="headerlink" title="jquery发送Cookies"></a>jquery发送Cookies</h3><p>要实现跨域，spring boot需要添加如下配置，允许客户端跨域访问</p>
<pre><code>@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {
    public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping(&quot;/**&quot;)
                    .allowedOrigins(&quot;http://127.0.0.1:9090&quot;)
                    .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;, &quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;)
                    .allowedHeaders(&quot;X-Requested-With&quot;, &quot;Content-Type&quot;, &quot;Accept&quot;, &quot;Authorization&quot;, &quot;Access-Control-Request-Method&quot;, &quot;Access-Control-Request-Headers&quot;)
                    .allowCredentials(true).maxAge(3600);

    }
}
</code></pre><p><code>allowedOrigins</code>方法配置允许访问的客户端域名，上述代码允许域名为<a href="http://127.0.0.1:9090的地址跨域访问。" target="_blank" rel="external">http://127.0.0.1:9090的地址跨域访问。</a>  </p>
<p>shiro实现了session管理，如下代码可以获取session</p>
<pre><code>Subject subject = SecurityUtils.getSubject();
Session session = subject.getSession();
</code></pre><p>shiro使用session记录用户的登录信息，但在跨域访问的情况下，jquery不会将收到的Cookies发送到服务端，导致shiro用户登录信息丢失。</p>
<pre><code>$.ajax({
    url: &quot;http://localhost:8080/user/login?user=u1&amp;password=123&quot;,
    type: &#39;GET&#39; 
});

$.ajax({
    url: &quot;http://localhost:8080/user/hello&quot;,
    type: &#39;GET&#39; 
});
</code></pre><p>连续调用上述两个ajax请求，在firefox firebug中查看网络请求：<br><img src="/spring-boot-shiro/spring_shiro/1.png" alt="image"><br>可以看到服务器已经将Cookies返回，其中JSESSIONID就是sessionId，但jquery在第二次请求中并没有将返回的Cookies发送到服务端，导致第二次请求失败。<br>可以使用withCredentials参数要求jquery ajax中携带服务端返回的Cookies</p>
<pre><code>$.ajax({
    url: &quot;http://localhost:8080/user/login?user=u1&amp;password=123&quot;,
    type: &#39;GET&#39;,
    xhrFields: {
        withCredentials: true
    }
});
$.ajax({
    url: &quot;http://localhost:8080/user/hello&quot;,
    type: &#39;GET&#39;,
    xhrFields: {
        withCredentials: true
    }
});
</code></pre><p><img src="/spring-boot-shiro/spring_shiro/2.png" alt="image"><br>可以看到第二次请求已经携带第一次请求返回的Cookies了。</p>
<h3 id="复杂CORS跨域请求，OPTIONS请求的处理"><a href="#复杂CORS跨域请求，OPTIONS请求的处理" class="headerlink" title="复杂CORS跨域请求，OPTIONS请求的处理"></a>复杂CORS跨域请求，OPTIONS请求的处理</h3><p>当调用如delete等复杂CORS跨域请求时，浏览器会先发送一种”预请求”OPTIONS，此时服务端也需要返回”预回应”作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。  </p>
<p>但shiro默认提供的form认证过滤器FormAuthenticationFilter对于”预请求”OPTIONS无法通过验证，所以这里重写FormAuthenticationFilter，对OPTIONS进行特别操作：</p>
<pre><code>public class MyFormAuthorizationFilter extends FormAuthenticationFilter {
    protected boolean isAccessAllowed(ServletRequest servletRequest, ServletResponse servletResponse, Object o) {
        HttpServletRequest httpServletRequest = WebUtils.toHttp(servletRequest);
        if(&quot;OPTIONS&quot;.equals(httpServletRequest.getMethod())) {
            return true;
        }
        return super.isAccessAllowed(servletRequest, servletResponse, o);
    }
}
</code></pre><p>这里允许所有的OPTIONS通过验证，所以服务器不能再开放类型为OPTIONS的接口了，否则会很危险。<br>当然这种处理只是临时处理方案，更合适的方案可以在阅读shiro相关源码再探讨。</p>
<p>参考：<br><a href="https://waylau.gitbooks.io/apache-shiro-1-2-x-reference/content/" target="_blank" rel="external">apache-shiro-1.2.x-reference</a><br><a href="http://wiki.jikexueyuan.com/project/shiro/" target="_blank" rel="external">极客学院</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[node js安装及hexo简单使用]]></title>
      <url>https://binecy.coding.me/nodeJs-hexo/</url>
      <content type="html"><![CDATA[<p>记录一下hexo安装使用的过程<br><a id="more"></a></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>从 <a href="https://nodejs.org/en/" target="_blank" rel="external">node.js官网</a> 下载安装文件，正常安装即可<br>安装完成后，在cmd中运行命令，查看到版本号即安装成功  </p>
<pre><code>    $ npm -v
    2.15.9
</code></pre><!--more-->
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>    // 设置npm安装程序时的默认位置
    npm config set prefix &quot;E:\node&quot;


    // 设置npm安装程序时的缓存位置
    npm config set cache &quot;E:\nodeCache&quot;
</code></pre><p>运行下面命令可查看配置结果</p>
<pre><code>    $ npm config get prefix
    e:\node

    # npm config get cache
    E:\nodeCache
</code></pre><p>我的是win7系统，所以在<code>计算机-属性-高级系统设置-高级-环境变量中</code>中的Path变量中添加npm安装程序目录E:\node<br>必须配置该参数，否则无法在cmd中直接调用node的全局模块。</p>
<h3 id="安装模板"><a href="#安装模板" class="headerlink" title="安装模板"></a>安装模板</h3><p>以安装hexo为例<br>运行命令  </p>
<pre><code>$ npm install hexo-cli -g
</code></pre><p>-g参数表示安装为全局模块</p>
<p>安装完成后运行命令查看版本</p>
<pre><code>    $ hexo version
    hexo-cli: 1.0.2
    os: Windows_NT 6.1.7601 win32 ia32
    http_parser: 2.7.0
    node: 4.6.0
    v8: 4.5.103.37
    uv: 1.9.1
    zlib: 1.2.8
    ares: 1.10.1-DEV
    icu: 56.1
    modules: 46
    openssl: 1.0.2j
</code></pre><p>安装成功。</p>
<h3 id="简单记录hexo的使用"><a href="#简单记录hexo的使用" class="headerlink" title="简单记录hexo的使用"></a>简单记录hexo的使用</h3><h4 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h4><pre><code>$ hexo init hexo  #执行init命令初始化到你指定的hexo目录  
$ cd hexo

$ hexo g #生成静态文件
$ hexo s #运行服务器
INFO  Start processing
INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.
</code></pre><p>这时访问 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 可以看到如下界面：<br><img src="/nodeJs-hexo/nodeJs-hexo/hexo_first.png" alt="image"></p>
<p>此时hexo已经正常运行，使用的是默认主题landscape。  </p>
<p>运行<code>$ hexo init hexo</code>后可以看到hexo目录结构大致为</p>
<pre><code>|-- _config.yml
|-- public
|-- scaffolds
|-- scripts
|-- source
   |-- _posts
|-- themes
</code></pre><p>其中_config.yml文件用于配置hexo，source下存放的是markdown 语法的文章内容，public存放的是hexo生成的静态文件，themes为主题文件</p>
<p>对主题的使用，请参考流行主题NexT ： <a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT文档</a></p>
<p>常用命令</p>
<pre><code>文章中插入阅读更多`&lt;!--more--&gt;`
分类，二级类
categories:
- f2e
- html、css


$ hexo n &quot;文件名&quot;    # 生成新的文章
$hexo new draft &quot;草稿文件&quot; #生成一个草稿文件(并不会在博客中显示)
$hexo publish &quot;草稿文件名&quot; #发布草稿文件 (默认发布到_posts,类似于移动文件)
$hexo server --draft #开启服务，会渲染草稿文件

$hexo clean #清理工作目录
$hexo g #生成public pages
$hexo d #git部署(配置过_config.yml)

hexo d -g #合并上两个操作
</code></pre><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><p>发布时出现异常</p>
<pre><code>$ hexo d
ERROR Deployer not found: git
</code></pre><p>运行以下命令安装git发布工具</p>
<pre><code>    $ npm install hexo-deployer-git --save
</code></pre><p>_config.yml中发布信息可以使用如下配置</p>
<pre><code>deploy:  
type: git
repository: https://usename:password@github.com/...
branch: master
</code></pre><p>在repository的url中带上github用户名及密码 <a href="https://usename:password@github.com/" target="_blank" rel="external">https://usename:password@github.com/</a>…<br>参考：<br><a href="http://opiece.me/2015/04/09/hexo-guide/" target="_blank" rel="external">使用Hexo搭建个人博客(基于hexo3.0)</a><br><a href="http://www.wuxubj.cn/2016/07/footer-beautify-of-nexT/index.html" target="_blank" rel="external">Hexo+nexT页脚美化</a></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[effective java - 异常]]></title>
      <url>https://binecy.coding.me/effective-java-exception/</url>
      <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="external">《Effective Java》</a>读书笔记，关于异常系列。<br><a id="more"></a></p>
<h2 id="只针对异常的情况才使用异常"><a href="#只针对异常的情况才使用异常" class="headerlink" title="只针对异常的情况才使用异常"></a>只针对异常的情况才使用异常</h2><p><strong>异常应该只用于异常情况，不应该用于正常的控制流</strong></p>
<p>设计良好的api不应该强迫客户端为了正常控制流而使用异常。如果类有在特定状态下才可以调用的方法，就应该有对应的“状态检查”方法，如Iterator的next方法和hasNext方法。<br>或方法返回标识结束的值，如null，-1<br><!--more--></p>
<h2 id="对可恢复的情况使用受检异常，对编程错误使用运行时异常"><a href="#对可恢复的情况使用受检异常，对编程错误使用运行时异常" class="headerlink" title="对可恢复的情况使用受检异常，对编程错误使用运行时异常"></a>对可恢复的情况使用受检异常，对编程错误使用运行时异常</h2><p><strong>如果期望调用者能够适当地恢复，应该使用受检异常。</strong> 通过抛出受检异常，强迫调用者在一个catch子句中处理该异常，或者将它传播出去。<br><em>用户可以根据错误信息进行处理</em><br>受检异常往往要指明可恢复的条件</p>
<p><strong>用运行时异常表明编程错误</strong>  大多数运行时异常都表示客户没有遵守api规范中的约定，如ArrayIndexOutBoundsException。</p>
<h2 id="避免不必要地使用受检异常"><a href="#避免不必要地使用受检异常" class="headerlink" title="避免不必要地使用受检异常"></a>避免不必要地使用受检异常</h2><p>受检异常会增加异常处理的工作量，也会增加代码复杂度。<br><strong>对于底层接口的方法或经常被调用的方法，如果声明抛出受检异常，可能会造成受检异常的大量蔓延，因为所有实现或调用这些方法的代码都必须处理受检异常。</strong>  </p>
<p><strong>使用受检异常时，要考虑到异常捕获者能否立即采取有用的措施，如果不能，那考虑是否使用未受检异常更合适。</strong>  </p>
<p>对于可能失败的方法，可以考虑添加“状态检查”方法并使用未受检异常。<br>捕获到的受检异常也可以根据情况转译为未受检异常</p>
<h2 id="优先使用标准异常"><a href="#优先使用标准异常" class="headerlink" title="优先使用标准异常"></a>优先使用标准异常</h2><p>1.使api易于学习和使用<br>2.可读性更好，不会出现程序员不熟悉的异常。<br>3.异常类越少，内存印迹就越小，装载这些类的时间开销就越少。</p>
<p>最常用的可重用异常：</p>
<table>
<thead>
<tr>
<th>异常</th>
<th>使用场合</th>
</tr>
</thead>
<tbody>
<tr>
<td>IllegalArgumentException</td>
<td>非null的参数值不正确</td>
</tr>
<tr>
<td>IllegalStateException</td>
<td>对于方法调用而言，对象状态不合适</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>在禁止使用null的情况下参数值为null</td>
</tr>
<tr>
<td>IndexOutOfBoundsException</td>
<td>下标参数越界</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>在禁止并发修改的情况下，检测到对象的并发修改。</td>
</tr>
<tr>
<td>ConcurrentModificationException</td>
<td>对象不支持用户请求的方法</td>
</tr>
</tbody>
</table>
<h2 id="抛出与抽象层面相对应的异常"><a href="#抛出与抽象层面相对应的异常" class="headerlink" title="抛出与抽象层面相对应的异常"></a>抛出与抽象层面相对应的异常</h2><p>如果方法抛出的异常与它所执行的任务没有明显联系(如底层细节方法抛出的异常)，往往使人困惑，实现细节也会污染高层api。为了避免这个问题<strong>更高层的实现应该捕获底层的异常，同时抛出可以按照高层抽象进行解释的异常</strong>这种做法称为<em>异常转译</em><br>使用异常链<br>可以在给底层传递参数前，检查参数的有效性，从而避免底层方法抛出异常。</p>
<h2 id="每个方法抛出的异常都要有文档"><a href="#每个方法抛出的异常都要有文档" class="headerlink" title="每个方法抛出的异常都要有文档"></a>每个方法抛出的异常都要有文档</h2><p><strong>始终要单独声明受检异常，并用利用javadoc的<code>@throws</code>标记，准确地记录下抛出每个异常的条件</strong><br><em>如果一个方法可能抛出多个异常，不要只声明它会抛出的这些异常的某个超类，即永远不要声明方法<code>throws Exception</code>或<code>throws Throwable</code></em></p>
<p><strong>使用javadoc的<code>@throws</code>标签记录下一个方法可能抛出的每个未受检异常，但不要使用<code>throws</code>关键字将未受检异常包含在方法声明中。</strong></p>
<h2 id="在异常的细节消息中包含失败的信息"><a href="#在异常的细节消息中包含失败的信息" class="headerlink" title="在异常的细节消息中包含失败的信息"></a>在异常的细节消息中包含失败的信息</h2><p><strong>为了捕获失败，异常的细节信息应该包含所有“对该异常有用的”的参数和域的值</strong>如IndexOutOfBoundsException异常的细节消息应该包含下界，上界和越界的下标值。<br>但异常消息中包含大量的描述信息往往没有作用。异常的细节消息与“用户层次的错误信息”不同，后者对于最终用户必须是可理解的，但异常的消息细节是让程序员用于分析错误的，信息的内容比可理解性要重要很多。<br>可以在异常中使用属性保存关键消息，再生成对应的消息描述，而不是直接使用字符串：</p>
<h2 id="努力使失败保持原子性"><a href="#努力使失败保持原子性" class="headerlink" title="努力使失败保持原子性"></a>努力使失败保持原子性</h2><p><strong>对于会修改对象状态的方法，如果调用失败了，应该使对象保持在被调用之前的状态</strong></p>
<ul>
<li>使用不可变类，如果一个操作失败了，阻止创建新的对象  </li>
<li>执行操作前先检查参数的有效性，对无效参数先抛出适合的异常</li>
<li>调整计算处理的顺序，使得任何可能会失败的计算部分都在对象状态被修改之前发生。 这是对上一个方法的扩展  </li>
<li>编写恢复代码（使用较少）</li>
<li>在对象的一份临时拷贝上操作，成功后再拷贝内容替换对象内容。</li>
</ul>
<h2 id="不要忽略异常"><a href="#不要忽略异常" class="headerlink" title="不要忽略异常"></a>不要忽略异常</h2><p><strong>这里有三个重要的原则</strong></p>
<ul>
<li>具体明确<br>不要使用Throwable，Error，Exception或RuntimeException，使用具体的异常子类，如FileNotFoundException，EOFException和ObjectStreamException这些子 类，分别描述了一类特定的I/O错误：文件丢失,异常文件结尾和错误的序列化对象流</li>
<li><p>提早抛出<br>如在方法开始时检查参数有效性，而不是将错误参数进行处理，再处理过程再抛出异常。<br><em>通过提早抛出异常（又称＂迅速失败＂），异常得以清晰又准确。堆栈信息立即反映出什么出了错（非法参数值），为什么出错（文件名不能为空值），以及哪里出的错（readPreferences()的前部分）。</em></p>
</li>
<li><p>延迟捕获</p>
<pre><code>public void readPreferences(String filename){
  InputStream in = null;

  // DO NOT DO THIS!!!
  try{
      in = new FileInputStream(filename);
  }
  catch (FileNotFoundException e){
      logger.log(e);
  }

  in.read(...);
  //...
}
</code></pre></li>
</ul>
<p>如果出现FileNotFoundException异常，当我们查看日志时，会本能地查看日志最后的异常信息，却看到异常信息为代码 <code>in.read(...);</code> 抛出的NullPointerException异常，这里会造成非常大的误导。<br><strong>在合适的层面捕获异常，以便你的程序要么可以从异常中有意义地恢复并继续下去，而不导致更 深入的错误；要么能够为用户提供明确的信息，包括引导他们从错误中恢复过来。如果你的方法无法胜任，那么就不要处理异常，把它留到后面捕获和在恰当的层面处理(可能要转译)。</strong><br>参考<br><a href="http://www.importnew.com/1701.html" target="_blank" rel="external">有效处理Java异常三原则</a></p>
]]></content>
      
        <categories>
            
            <category> java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
