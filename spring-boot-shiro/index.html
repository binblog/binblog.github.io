	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>spring boot 配置shiro | binecy</title>
  <meta name="author" content="bin">
  
  <meta name="description" content="记录spring boot中配置shiro的过程及一些小栗子">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="spring boot 配置shiro"/>
  <meta property="og:site_name" content="binecy"/>

  
  
		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="/favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">binecy</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/about" title="">
                    <i class="fa fa-info-circle"></i>关于
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>spring boot 配置shiro</h2>
					
					<div>
						<span class="post-time">2016-10-08 23:23:30</span>
					</div>	
					

					<div class="article-content">
						<p>记录spring boot中配置shiro的过程及一些小栗子<br><a id="more"></a></p>
<h2 id="spring-boot-配置shiro"><a href="#spring-boot-配置shiro" class="headerlink" title="spring boot 配置shiro"></a>spring boot 配置shiro</h2><h3 id="由于使用了maven，所以先编辑pom"><a href="#由于使用了maven，所以先编辑pom" class="headerlink" title="由于使用了maven，所以先编辑pom"></a>由于使用了maven，所以先编辑pom</h3><pre><code>&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.3.5.RELEASE&lt;/version&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;
      &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;
      &lt;version&gt;1.3.2&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><h3 id="添加主程序类和一个服务类"><a href="#添加主程序类和一个服务类" class="headerlink" title="添加主程序类和一个服务类"></a>添加主程序类和一个服务类</h3><pre><code>@EnableWebMvc
@Configuration
@EnableAutoConfiguration
@ComponentScan
public class Application extends WebMvcConfigurerAdapter {
    public static void main(String[] args) throws Exception {
        SpringApplication.run(Application.class, args);
    }
}

@RestController
@RequestMapping(&quot;/user&quot;)
public class UserController {
    @ResponseBody
    @RequestMapping(value = &quot;/hello&quot;)
    public String hello() {
        return &quot;hello &quot;;
    }
}
</code></pre><p>此时运行主程序类，浏览器访问 <a href="http://localhost:8080/user/hello" target="_blank" rel="external">http://localhost:8080/user/hello</a> ,可以看到服务器返回字符串：hello</p>
<h3 id="实现用户认证"><a href="#实现用户认证" class="headerlink" title="实现用户认证"></a>实现用户认证</h3><p><strong>现在实现需求：用户需要登录后才能访问地址 <a href="http://localhost:8080/user/hello" target="_blank" rel="external">http://localhost:8080/user/hello</a> </strong></p>
<h4 id="实现AuthorizingRealm"><a href="#实现AuthorizingRealm" class="headerlink" title="实现AuthorizingRealm"></a>实现AuthorizingRealm</h4><p>AuthorizingRealm是shiro中的权限管理器，可以对用户进行认证和授权操作<br>添加如下类：</p>
<pre><code>public class SimpleRealm  extends AuthorizingRealm {

    /**
     * 授权
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    /**
     * 认证
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        UsernamePasswordToken credentials = (UsernamePasswordToken) authenticationToken;

        String userName = credentials.getUsername();
        String password = new String(credentials.getPassword());

        // 固定用户：u1:123和u2:123
        if( (userName.equals(&quot;u1&quot;) &amp;&amp; password.equals(&quot;123&quot;)) || (userName.equals(&quot;u2&quot;) &amp;&amp; password.equals(&quot;123&quot;))) {
            return new SimpleAuthenticationInfo(userName, password,userName);
        } else {
            throw new AuthenticationException();
        }

    }
}
</code></pre><p><code>doGetAuthenticationInfo</code>方法对用户身份进行认证操作，SimpleRealm固定了两个用户，这里可以实现从数据库中查询用户信息进行认证。<br><code>doGetAuthorizationInfo</code>方法对用户身份进行授权操作，暂不使用</p>
<h4 id="配置过滤器"><a href="#配置过滤器" class="headerlink" title="配置过滤器"></a>配置过滤器</h4><p>添加如下配置类：  </p>
<pre><code>@Configuration
public class ShiroConfiguration {
    /**
     * 创建ShiroFilterFactoryBean，提供给spring使用
     */
    @Bean
    public ShiroFilterFactoryBean shiroFilter() {
        ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
        factoryBean.setSecurityManager(securityManager());  // 配置安全管理器

        Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();
        filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
        factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMapping);

        return factoryBean;
    }


    public DefaultWebSecurityManager securityManager() {
        final DefaultWebSecurityManager securityManager
                = new DefaultWebSecurityManager();
        List&lt;Realm&gt; list = new ArrayList&lt;&gt;();
        list.add(new SimpleRealm());    // 使用SimpleRealm权限管理器
        securityManager.setRealms(list);
        return securityManager;
    }
}
</code></pre><p><code>filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);</code>配置了调用以/user开始的url，必须通过authc这个过滤器（authc是shiro默认提供的form认证过滤器）</p>
<p>这里访问<a href="http://localhost:8080/user/hello，可以看到浏览器自动跳转到http://localhost:8080/login.jsp" target="_blank" rel="external">http://localhost:8080/user/hello，可以看到浏览器自动跳转到http://localhost:8080/login.jsp</a> ，这是当用户没有进行认证操作时，shiro自动将url跳转到login.jsp页面（可通过<code>factoryBean.setLoginUrl(String);</code>进行配置）。</p>
<h4 id="添加用户登录接口"><a href="#添加用户登录接口" class="headerlink" title="添加用户登录接口"></a>添加用户登录接口</h4><p>UserController中添加如下方法：</p>
<pre><code>@ResponseBody
@RequestMapping(value = &quot;/login&quot;)
public String login(@RequestParam(&quot;user&quot;)String user, @RequestParam(&quot;password&quot;)String password) {
    Subject subject = SecurityUtils.getSubject();
    UsernamePasswordToken token = new UsernamePasswordToken(user, password);
    try {
        subject.login(token);   // 用户认证并登录
        return &quot;login success&quot;;
    } catch (AuthenticationException e) {
        e.printStackTrace();
        return &quot;login fail&quot;;
    }
}
</code></pre><p>调用<code>subject.login(token);</code>，shiro将进行用户认证操作，用户信息错误将抛出异常。</p>
<p>过滤配置修改：</p>
<pre><code>Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();

filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);    // 不需要任何过滤器

filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
</code></pre><p><strong>注意路径表达式按事先定义好的顺序判断传入的请求，并遵循 FIRST MATCH WINS 这一原则。/user/login必须要/user/<strong>之前加入filterChainDefinitionMapping，如果调换顺序，当访问/user/login时，由于先匹配了`(“/user/</strong>“, “authc”)<code>,则</code>(“/user/login”, “anon”)`永远不匹配到</strong></p>
<p>访问登录接口<br><a href="http://localhost:8080/user/login?user=u1&amp;password=123" target="_blank" rel="external">http://localhost:8080/user/login?user=u1&amp;password=123</a> 完成登录, 再访问<br><a href="http://localhost:8080/user/hello" target="_blank" rel="external">http://localhost:8080/user/hello</a><br>可以看到访问正常</p>
<h3 id="实例用户授权"><a href="#实例用户授权" class="headerlink" title="实例用户授权"></a>实例用户授权</h3><p><strong>现在实现需求：UserController添加一个sendGift接口，该接口必须拥有admin角色的用户才能访问</strong></p>
<p>添加sendGift接口</p>
<pre><code>@ResponseBody
@RequestMapping(value = &quot;/sendGift&quot;)
public String sendGift() {
    return &quot;success&quot;;
}
</code></pre><p>添加url过滤：</p>
<pre><code>Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();

filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);

filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,roles[user]&quot;);

filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
</code></pre><p><code>filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,roles[user]&quot;);</code>配置了访问<code>/user/sendGift</code>的用户必须拥有user角色( roles也是shrio默认提供的角色过滤器)<br>可以发现，此时即使u1登录了，当访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a> 时，仍然返回401的访问错误。</p>
<p>这里需要修改SimpleRealm中的授权操作，对用户添加对应的角色权限<br>修改SimpleRealm中的doGetAuthorizationInfo方法为</p>
<pre><code>/**
 * 授权
 */
@Override
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
    Set&lt;String&gt; names = principalCollection.getRealmNames();
    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();
    if(names.contains(&quot;u1&quot;)) {
        authorizationInfo.addRole(&quot;user&quot;);  // 为u1用户添加user角色
    }
    return authorizationInfo;
}
</code></pre><p>此时用户u1只要登录，就可以访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a> 了</p>
<p><strong>现对需求进行扩展，要求sendGift接口不仅user角色可以访问，admin管理角色也可以访问</strong><br>尝试对url过滤配置进行如下修改</p>
<pre><code>Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();

filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);

filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,roles[user,admin]&quot;);

filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
</code></pre><p>但现在导致的问题是sendGift接口不仅admin角色无法访问，连原来的user角色都不可以访问了。原因是roles默认过滤器对<code>[user,admin]</code>处理是要求用户同时拥有user和admin两个角色。<br>这里我们需要自定义一个过滤器，支持只要拥有user角色或admin角色就通过验证的需求。</p>
<pre><code>public class MyRolesAuthorizationFilter  extends AuthorizationFilter {
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {
        Subject subject = this.getSubject(request, response);
        String[] rolesArray = (String[])((String[])mappedValue);
        if(rolesArray != null &amp;&amp; rolesArray.length != 0) {
            for(String role : rolesArray) {
                if(subject.hasRole(role)) { // 只在用户拥有定义中的任一角色，则通过验证
                    return true;
                }
            }

            return false;
        } else {
            return true;
        }
    }
}
</code></pre><p>url配置修改为：</p>
<pre><code>@Bean
public ShiroFilterFactoryBean shiroFilter() {
    ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean();
    factoryBean.setSecurityManager(securityManager());  // 配置安全管理器

    // 配置自定义的过滤器
    Map&lt;String,Filter&gt; map = new HashMap&lt;&gt;();
    map.put(&quot;myRoles&quot;, new MyRolesAuthorizationFilter());
    factoryBean.setFilters(map);

    Map&lt;String, String&gt; filterChainDefinitionMapping = new LinkedHashMap&lt;&gt;();
    filterChainDefinitionMapping.put(&quot;/user/login&quot;, &quot;anon&quot;);
    filterChainDefinitionMapping.put(&quot;/user/sendGift&quot;, &quot;authc,myRoles[user,admin]&quot;);    // 使用自定义的过滤器myRoles
    filterChainDefinitionMapping.put(&quot;/user/**&quot;, &quot;authc&quot;);
    factoryBean.setFilterChainDefinitionMap(filterChainDefinitionMapping);

    return factoryBean;
}
</code></pre><p>此时只要通过登录，拥有user角色的u1可以访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a> 。<br>其他用户如u2，只要拥有user角色或admin角色也就可以访问 <a href="http://localhost:8080/user/sendGift" target="_blank" rel="external">http://localhost:8080/user/sendGift</a></p>
<h2 id="jquery-ajax实现CORS跨域，shrio的一些问题"><a href="#jquery-ajax实现CORS跨域，shrio的一些问题" class="headerlink" title="jquery ajax实现CORS跨域，shrio的一些问题"></a>jquery ajax实现CORS跨域，shrio的一些问题</h2><h3 id="jquery发送Cookies"><a href="#jquery发送Cookies" class="headerlink" title="jquery发送Cookies"></a>jquery发送Cookies</h3><p>要实现跨域，spring boot需要添加如下配置，允许客户端跨域访问</p>
<pre><code>@Configuration
public class WebConfig extends WebMvcConfigurerAdapter {
    public void addCorsMappings(CorsRegistry registry) {
            registry.addMapping(&quot;/**&quot;)
                    .allowedOrigins(&quot;http://127.0.0.1:9090&quot;)
                    .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;, &quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;)
                    .allowedHeaders(&quot;X-Requested-With&quot;, &quot;Content-Type&quot;, &quot;Accept&quot;, &quot;Authorization&quot;, &quot;Access-Control-Request-Method&quot;, &quot;Access-Control-Request-Headers&quot;)
                    .allowCredentials(true).maxAge(3600);

    }
}
</code></pre><p><code>allowedOrigins</code>方法配置允许访问的客户端域名，上述代码允许域名为<a href="http://127.0.0.1:9090的地址跨域访问。" target="_blank" rel="external">http://127.0.0.1:9090的地址跨域访问。</a>  </p>
<p>shiro实现了session管理，如下代码可以获取session</p>
<pre><code>Subject subject = SecurityUtils.getSubject();
Session session = subject.getSession();
</code></pre><p>shiro使用session记录用户的登录信息，但在跨域访问的情况下，jquery不会将收到的Cookies发送到服务端，导致shiro用户登录信息丢失。</p>
<pre><code>$.ajax({
    url: &quot;http://localhost:8080/user/login?user=u1&amp;password=123&quot;,
    type: &#39;GET&#39; 
});

$.ajax({
    url: &quot;http://localhost:8080/user/hello&quot;,
    type: &#39;GET&#39; 
});
</code></pre><p>连续调用上述两个ajax请求，在firefox firebug中查看网络请求：<br><img src="/spring-boot-shiro/spring_shiro/1.png" alt="image"><br>可以看到服务器已经将Cookies返回，其中JSESSIONID就是sessionId，但jquery在第二次请求中并没有将返回的Cookies发送到服务端，导致第二次请求失败。<br>可以使用withCredentials参数要求jquery ajax中携带服务端返回的Cookies</p>
<pre><code>$.ajax({
    url: &quot;http://localhost:8080/user/login?user=u1&amp;password=123&quot;,
    type: &#39;GET&#39;,
    xhrFields: {
        withCredentials: true
    }
});
$.ajax({
    url: &quot;http://localhost:8080/user/hello&quot;,
    type: &#39;GET&#39;,
    xhrFields: {
        withCredentials: true
    }
});
</code></pre><p><img src="/spring-boot-shiro/spring_shiro/2.png" alt="image"><br>可以看到第二次请求已经携带第一次请求返回的Cookies了。</p>
<h3 id="复杂CORS跨域请求，OPTIONS请求的处理"><a href="#复杂CORS跨域请求，OPTIONS请求的处理" class="headerlink" title="复杂CORS跨域请求，OPTIONS请求的处理"></a>复杂CORS跨域请求，OPTIONS请求的处理</h3><p>当调用如delete等复杂CORS跨域请求时，浏览器会先发送一种”预请求”OPTIONS，此时服务端也需要返回”预回应”作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。  </p>
<p>但shiro默认提供的form认证过滤器FormAuthenticationFilter对于”预请求”OPTIONS无法通过验证，所以这里重写FormAuthenticationFilter，对OPTIONS进行特别操作：</p>
<pre><code>public class MyFormAuthorizationFilter extends FormAuthenticationFilter {
    protected boolean isAccessAllowed(ServletRequest servletRequest, ServletResponse servletResponse, Object o) {
        HttpServletRequest httpServletRequest = WebUtils.toHttp(servletRequest);
        if(&quot;OPTIONS&quot;.equals(httpServletRequest.getMethod())) {
            return true;
        }
        return super.isAccessAllowed(servletRequest, servletResponse, o);
    }
}
</code></pre><p>这里允许所有的OPTIONS通过验证，所以服务器不能再开放类型为OPTIONS的接口了，否则会很危险。<br>当然这种处理只是临时处理方案，更合适的方案可以在阅读shiro相关源码再探讨。</p>
<p>参考：<br><a href="https://waylau.gitbooks.io/apache-shiro-1-2-x-reference/content/" target="_blank" rel="external">apache-shiro-1.2.x-reference</a><br><a href="http://wiki.jikexueyuan.com/project/shiro/" target="_blank" rel="external">极客学院</a></p>

					</div>
					
			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/spring-boot-shiro.md" data-title="spring boot 配置shiro" data-url="https://binecy.coding.me/spring-boot-shiro/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'tanke773'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  


</div>
	</div>

	
		<div class="col-md-3">
			<div id="toc" ></div>
		</div>
	

</div>


		<footer>
			

<!--
<p>
  &copy; 2017 <a href="https://binecy.coding.me"> bin </a>
</p>
-->
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
