	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ConcurrentHashMap实现 | binecy</title>
  <meta name="author" content="bin">
  
  <meta name="description" content="本文简单描述jdk7下ConcurrentHashMap的实现。
文章主要关注以下问题1.同步ConcurrentHashMap是线程安全的，那么如何解决线程冲突问题2.扩容如果当前容器已经接收新元素，将如何扩容3.hash冲突当出现hash冲突（不同hash值映射到同一位置）时，如何解决
构造pu">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="ConcurrentHashMap实现"/>
  <meta property="og:site_name" content="binecy"/>

  
  
		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="/favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">binecy</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/about" title="">
                    <i class="fa fa-info-circle"></i>关于
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>ConcurrentHashMap实现</h2>
					
					<div>
						<span class="post-time">2017-02-24 15:37:27</span>
					</div>	
					

					<div class="article-content">
						<p>本文简单描述jdk7下ConcurrentHashMap的实现。</p>
<p>文章主要关注以下问题<br>1.同步<br>ConcurrentHashMap是线程安全的，那么如何解决线程冲突问题<br>2.扩容<br>如果当前容器已经接收新元素，将如何扩容<br>3.hash冲突<br>当出现hash冲突（不同hash值映射到同一位置）时，如何解决</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><pre><code>public ConcurrentHashMap() {
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);
}


public ConcurrentHashMap(int initialCapacity,
                         float loadFactor, int concurrencyLevel) {
    ...

    // 计算一个大于concurrencyLevel的2的幂指数作为实际并发度
    int sshift = 0;
    int ssize = 1;
    while (ssize &lt; concurrencyLevel) {
        ++sshift;
        ssize &lt;&lt;= 1;
    }
    // segmentShift,segmentMask用于计算Segment位置
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    // 根据计算的并发度，计算每一个Segment的容量
    if (initialCapacity &gt; MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize &lt; initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap &lt; c)
        cap &lt;&lt;= 1;

    // 创建Segments数组和Segment[0]
    Segment&lt;K,V&gt; s0 =
        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),
                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);
    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
}
</code></pre><p>UNSAFE是jdk提供的，用于直接操作内存，是不安全的操作。<br>关于UNSAFE，可参考: <a href="http://www.jianshu.com/p/a16d638bc921" target="_blank" rel="external">java中的Unsafe</a></p>
<p>Segment是ConcurrentHashMap的内部静态类</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {
    transient volatile HashEntry&lt;K,V&gt;[] table;
    transient int count;

}
</code></pre><p>HashEntry数组是真正的存储元素的数组，<br>Segment继承自ReentrantLock，所以带有锁的功能。</p>
<p>HashEntry也是ConcurrentHashMap的内部静态类</p>
<pre><code>static final class HashEntry&lt;K,V&gt; {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry&lt;K,V&gt; next;
}
</code></pre><p>HashEntry中有next属性，指向下一个HashEntry元素，实际上HashEntry为一个链表，当hash冲突时，可以存储不同的值。（解决hash冲突的问题）</p>
<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><pre><code>public V put(K key, V value) {
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    // 计算hash值
    int hash = hash(key);
    // 计算Segment下标
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    // 查找Segment
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    // put操作
    return s.put(key, hash, value, false);
}
</code></pre><p><strong>计算hash值</strong></p>
<pre><code>private int hash(Object k) {
    int h = hashSeed;

    if ((0 != h) &amp;&amp; (k instanceof String)) {
        return sun.misc.Hashing.stringHash32((String) k);
    }

    h ^= k.hashCode();


    h += (h &lt;&lt;  15) ^ 0xffffcd7d;
    h ^= (h &gt;&gt;&gt; 10);
    h += (h &lt;&lt;   3);
    h ^= (h &gt;&gt;&gt;  6);
    h += (h &lt;&lt;   2) + (h &lt;&lt; 14);
    return h ^ (h &gt;&gt;&gt; 16);
}
</code></pre><p>这时将对hash值使用Wang/Jenkins hash算法。</p>
<p><strong>计算Segment下标</strong></p>
<pre><code>int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
</code></pre><p>运行时通过将key的高n位（n = 32 – segmentShift）和并发度减1（segmentMask）做位与运算定位到所在的Segment。<br>为什么是32呢，因为int只有32位（其中一位表示符号）。</p>
<p><strong>创建Segment</strong><br>由于支持并发操作，当segments[j]为空时,必须重复检查操作,</p>
<pre><code>private Segment&lt;K,V&gt; ensureSegment(int k) {
    final Segment&lt;K,V&gt;[] ss = this.segments;
    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset
    Segment&lt;K,V&gt; seg;
    // 重复检查
    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {
        // 使用ss[0]的属性构造新的Segment
        Segment&lt;K,V&gt; proto = ss[0]; // use segment 0 as prototype
        int cap = proto.table.length;
        float lf = proto.loadFactor;
        int threshold = (int)(cap * lf);
        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];
        // 再次检查
        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
            == null) { // recheck
            // 构造新的Segment
            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);
            // cas操作
            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))
                   == null) {
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}
</code></pre><p>这时进行了两次重复检查，并使用cas操作添加新的Segment</p>
<p>cas操作即比较交换操作，只有当ss[u]为null时，才进行赋值操作，否则将直接返回，而且操作是原子性的。这样就可以保证在并发的情况下，构造Segment的是安全的。</p>
<p><strong>Segment.put</strong></p>
<pre><code>final V put(K key, int hash, V value, boolean onlyIfAbsent) {
    // 加锁
    HashEntry&lt;K,V&gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try {
        HashEntry&lt;K,V&gt;[] tab = table;
        // 计算元素所在数组下标
        int index = (tab.length - 1) &amp; hash;
        // 查询对应的HashEntry
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);

        for (HashEntry&lt;K,V&gt; e = first;;) {
            // 如果当前HashEntry不空，则遍历链表，如果hash相同的，则使用新值替换
            if (e != null) {
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) {
                    oldValue = e.value;
                    if (!onlyIfAbsent) {
                        e.value = value;
                        ++modCount;
                    }
                    break;
                }
                e = e.next;
            }
            else {    // 如果HashEntry为空,则创建新的HashEntry
                // 新HashEntry的next指向first
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                // 如果put元素后容量将超过临界值，则扩容
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            }
        }
    } finally {
        // 释放锁
        unlock();
    }
    return oldValue;
}
</code></pre><p>ConcurrentHashMap中的put操作，在Segment范围内进行了加锁操作，而ConcurrentHashMap中将根据并发度创建多个Segment（默认为16），put操作时如果put到不同的Segment，就不需要竞争锁了，可以提高操作速度。</p>
<h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><pre><code>private void rehash(HashEntry&lt;K,V&gt; node) {
    HashEntry&lt;K,V&gt;[] oldTable = table;
    int oldCapacity = oldTable.length;
    int newCapacity = oldCapacity &lt;&lt; 1;    // 容量翻倍
    threshold = (int)(newCapacity * loadFactor);    // 新扩容临界值
    HashEntry&lt;K,V&gt;[] newTable =
        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];    // 创建新数组
    int sizeMask = newCapacity - 1;
    // 遍历原数组，放到新数组中
    for (int i = 0; i &lt; oldCapacity ; i++) {    
        HashEntry&lt;K,V&gt; e = oldTable[i];
        if (e != null) {
            HashEntry&lt;K,V&gt; next = e.next;
            int idx = e.hash &amp; sizeMask;
            // 单一元素，直接移动
            if (next == null)   
                newTable[idx] = e;
            else {
                // 
                HashEntry&lt;K,V&gt; lastRun = e;
                int lastIdx = idx;
                for (HashEntry&lt;K,V&gt; last = next;
                     last != null;
                     last = last.next) {
                    int k = last.hash &amp; sizeMask;
                    if (k != lastIdx) {
                        lastIdx = k;
                        lastRun = last;
                    }
                }
                newTable[lastIdx] = lastRun;
                // Clone remaining nodes
                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {
                    V v = p.value;
                    int h = p.hash;
                    int k = h &amp; sizeMask;
                    HashEntry&lt;K,V&gt; n = newTable[k];
                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);
                }
            }
        }
    }
    int nodeIndex = node.hash &amp; sizeMask; // 添加新元素
    node.setNext(newTable[nodeIndex]);
    newTable[nodeIndex] = node;
    table = newTable;
}
</code></pre><p>由于HashEntry长度都是2的倍数，而且扩展都是翻倍扩展，所以在长度oldLen的数组第i位的元素，扩展后的位置只可以为i或oldLen+i，所以这时做了一个简单的优化，以免创建过多的元素。当一个HashEntry为数组时，找到最后一段下标不变的数组，直接放到新的位置，然后遍历前面的元素，创建新的元素并放到适当位置</p>
<h2 id="size"><a href="#size" class="headerlink" title="size"></a>size</h2><p>调用size方法时，需要遍历所有的Segment，并且需要并发情况下保持Segment长度不变，下面看看实现：</p>
<ol>
<li><p>连续两次求所有Segment的modcount和， 如果相等，则过程中没有发生其他线程修改ConcurrentHashMap的情况，返回获得的值。</p>
</li>
<li><p>如果两次和不相等，则需要对所有的Segment依次进行加锁，获取统一的值后再依次解锁。</p>
<pre><code>public int size() {
 // Try a few times to get accurate count. On failure due to
 // continuous async changes in table, resort to locking.
 final Segment&lt;K,V&gt;[] segments = this.segments;
 int size;
 boolean overflow; // true if size overflows 32 bits
 long sum;         // sum of modCounts
 long last = 0L;   // previous sum
 int retries = -1; // first iteration isn&#39;t retry
 try {
     for (;;) {
         if (retries++ == RETRIES_BEFORE_LOCK) {
             for (int j = 0; j &lt; segments.length; ++j)
                 ensureSegment(j).lock(); // force creation
         }
         sum = 0L;
         size = 0;
         overflow = false;
         for (int j = 0; j &lt; segments.length; ++j) {
             Segment&lt;K,V&gt; seg = segmentAt(segments, j);
             if (seg != null) {
                 sum += seg.modCount;
                 int c = seg.count;
                 if (c &lt; 0 || (size += c) &lt; 0)
                     overflow = true;
             }
         }
         if (sum == last)
             break;
         last = sum;
     }
 } finally {
     if (retries &gt; RETRIES_BEFORE_LOCK) {
         for (int j = 0; j &lt; segments.length; ++j)
             segmentAt(segments, j).unlock();
     }
 }
 return overflow ? Integer.MAX_VALUE : size;
}
</code></pre></li>
</ol>
<p>错误之处，还望指出</p>
<p>参考：<br><a href="http://www.jianshu.com/p/4806633fcc55" target="_blank" rel="external">Concurrency of ConcurrentHashMap</a><br><a href="http://www.jianshu.com/p/e694f1e868ec" target="_blank" rel="external">谈谈ConcurrentHashMap1.7和1.8的不同实现</a><br><a href="http://tech.meituan.com/java-hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>

					</div>
					
			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/concurrentHashMap.md" data-title="ConcurrentHashMap实现" data-url="https://binecy.coding.me/concurrentHashMap/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'tanke773'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  


</div>
	</div>

	
		<div class="col-md-3">
			<div id="toc" ></div>
		</div>
	

</div>


		<footer>
			

<!--
<p>
  &copy; 2017 <a href="https://binecy.coding.me"> bin </a>
</p>
-->
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
