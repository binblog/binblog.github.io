	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>spring-support | binecy</title>
  <meta name="author" content="bin">
  
  <meta name="description" content="在spring获取bean - 源码简析 中简单描述了spring创建bean的过程。
下面，通过自定义BeanPostProcessor，在bean创建前后自定义自己的操作。
public class MyBeanProcessor implements BeanPostProcessor {

">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="spring-support"/>
  <meta property="og:site_name" content="binecy"/>

  
  
		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="/favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">binecy</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/about" title="">
                    <i class="fa fa-info-circle"></i>关于
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>spring-support</h2>
					
					<div>
						<span class="post-time">2017-04-29 15:36:43</span>
					</div>	
					

					<div class="article-content">
						<p>在<a href="/java-spring-get-bean/" title="spring获取bean - 源码简析">spring获取bean - 源码简析</a> 中简单描述了spring创建bean的过程。</p>
<p>下面，通过自定义BeanPostProcessor，在bean创建前后自定义自己的操作。</p>
<pre><code>public class MyBeanProcessor implements BeanPostProcessor {

    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;BeforeInitialization : &quot; + beanName + &quot; , &quot; + bean);
        return bean;
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;AfterInitialization : &quot; + beanName + &quot; , &quot; + bean);
        return bean;
    }
}
</code></pre><p>非常简单，仅仅是输出一些信息。</p>
<p>spring.xml配置:</p>
<pre><code>&lt;bean id=&quot;myBeanProcessor&quot; class=&quot;spring.processor.MyBeanProcessor&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;blog&quot; class=&quot;spring.bean.Blog&quot; &gt;
    &lt;property name=&quot;title&quot; value=&quot;hello spring&quot; &gt;&lt;/property&gt;
&lt;/bean&gt;
</code></pre><p>使用<a href="/java-spring-load-config/" title="spring加载配置-源码简析">spring加载配置-源码简析</a>中的测试方法</p>
<pre><code>@Test
public void test() {
    BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;spring.xml&quot;));
    Blog bean = (Blog)beanFactory.getBean(&quot;blog&quot;);
    Assert.assertEquals(bean.getTitle(), &quot;hello spring&quot;);
}
</code></pre><p>这时并没有输出MyBeanProcessor中定义的信息，而把测试方法修改为如下：</p>
<pre><code>@Test
public void test() {
    ClassPathXmlApplicationContext beanFactory = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);
    Blog bean = (Blog)beanFactory.getBean(&quot;blog&quot;);
    Assert.assertEquals(bean.getTitle(), &quot;hello spring&quot;);
}
</code></pre><p>这时可以看到程序输出了MyBeanProcessor中定义的信息。</p>
<p>org.springframework.context.support.ClassPathXmlApplicationContext是spring support中的类。下面简单看一下它做了哪些工作。</p>
<pre><code>public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh,
    ApplicationContext parent) throws BeansException {

    super(parent);
    setConfigLocations(configLocations);
    if (refresh) {
        refresh();
    }
}
</code></pre><p>核心方法为refresh():</p>
<pre><code>public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        // 准备刷新上下文环境
        prepareRefresh();

        // 初始化BeanFactory，并进行xml文件读取
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // 对beanFacotry进行各种功能填充
        prepareBeanFactory(beanFactory);

        try {
            // 提供给子类覆盖方法做额外处理
            postProcessBeanFactory(beanFactory);

            // 激活BeanFactoryPostProcessors
            invokeBeanFactoryPostProcessors(beanFactory);

            // 注册拦截Bean创建的Bean处理器(这里只是注册,真正调用在getBean的时候)
            registerBeanPostProcessors(beanFactory);

            // 初始化应用消息广播器,即不同语言的消息体,国际化处理
            initMessageSource();

            // 初始化广播器,并放到上下文中    
            initApplicationEventMulticaster();

            // 提供给子类初始化其他的Bean
            onRefresh();

            // 在所有注册的bean中查找Listener bean,注册到消息广播中
            registerListeners();

            // 初始化剩下的单实例(InitializingBean,DisposableBean, Aware对象等)
            finishBeanFactoryInitialization(beanFactory);

            // 完成刷新过程,通知生命周期处理器
            finishRefresh();
        }

        ...

        finally {
            // Reset common introspection caches in Spring&#39;s core, since we
            // might not ever need metadata for singleton beans anymore...
            resetCommonCaches();
        }
    }
}
</code></pre><h2 id="初始化BeanFactory"><a href="#初始化BeanFactory" class="headerlink" title="初始化BeanFactory"></a>初始化BeanFactory</h2><p>ClassPathXmlApplicationContext的继承层次很深:<br>ClassPathXmlApplicationContext -&gt; AbstractXmlApplicationContext -&gt; AbstractRefreshableConfigApplicationContext -&gt; AbstractRefreshableApplicationContext -&gt; AbstractApplicationContext<br>而AbstractApplicationContext -&gt; ConfigurableApplicationContext -&gt; ApplicationContext -&gt; ListableBeanFactory,HierarchicalBeanFactory -&gt; BeanFactory</p>
<p>可以看到 ClassPathXmlApplicationContext实现了BeanFactory接口，而调用方法<code>getBean</code>将执行到AbstractApplicationContext.getBean:</p>
<pre><code>public Object getBean(String name) throws BeansException {
    assertBeanFactoryActive();    // 判断BeanFactory是否为Active
    return getBeanFactory().getBean(name);    // 通过getBeanFactory()获取beanFactory，并使用beanFactory生成bean
}
</code></pre><p>getBeanFactory在AbstractRefreshableApplicationContext中实现</p>
<pre><code>@Override
public final ConfigurableListableBeanFactory getBeanFactory() {
    synchronized (this.beanFactoryMonitor) {
        if (this.beanFactory == null) {
            throw new IllegalStateException(&quot;BeanFactory not initialized or already closed - &quot; +
                    &quot;call &#39;refresh&#39; before accessing beans via the ApplicationContext&quot;);
        }
        return this.beanFactory;
    }
}
</code></pre><p>同步方法，方法返回了beanFactory属性，beanFactory属性的刷新要通过如下方法：</p>
<pre><code>protected final void refreshBeanFactory() throws BeansException {
    if (hasBeanFactory()) {     // 销毁已存在的beanFactory
        destroyBeans();
        closeBeanFactory();
    }

    ...
    DefaultListableBeanFactory beanFactory = createBeanFactory();    // 创建beanFactory

}

protected DefaultListableBeanFactory createBeanFactory() {
    return new DefaultListableBeanFactory(getInternalParentBeanFactory());
}
</code></pre><p>回到refresh()方法,refresh()中通过<code>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</code>获取beanFactory。</p>
<pre><code>protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    refreshBeanFactory();
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    ...
    return beanFactory;
}
</code></pre><p>可以看到该方法先调用了<code>refreshBeanFactory();</code>来刷新beanFactory，再通过<code>getBeanFactory()</code>获取beanFactory。</p>
<h2 id="激活BeanFactoryPostProcessors"><a href="#激活BeanFactoryPostProcessors" class="headerlink" title="激活BeanFactoryPostProcessors"></a>激活BeanFactoryPostProcessors</h2><p>通过BeanFactoryPostProcessor，可以对beanFactory进行处理，如修改其他BeanDefinition的配置。<br>refresh()中通过<code>invokeBeanFactoryPostProcessors(beanFactory);</code>激活BeanFactoryPostProcessors。</p>
<pre><code>protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
}
</code></pre><p>PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors方法支持周期性的，一次性的和优先级的Processor，下面仅摘录部分示意代码</p>
<pre><code>public static void invokeBeanFactoryPostProcessors(
    ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {
    ...
    String[] postProcessorNames =
                    beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
            processedBeans.add(ppName);
        }
    }                

    // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
    invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
    invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
}
</code></pre><h2 id="注册BeanPostProcessors处理器"><a href="#注册BeanPostProcessors处理器" class="headerlink" title="注册BeanPostProcessors处理器"></a>注册BeanPostProcessors处理器</h2><p>通过BeanPostProcessors，可以在bean创建过程中执行自定义操作，如重写<code>postProcessBeforeInitialization</code>方法并返回非null值，那spring将直接使用该返回值给bean赋值。<br>refresh()中通过<code>registerBeanPostProcessors(beanFactory);</code>注册BeanPostProcessors处理器</p>
<pre><code>protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
}
</code></pre><p>PostProcessorRegistrationDelegate.registerBeanPostProcessors中也是获取xml配置中的BeanPostProcessor处理器，并注册到beanFactory中，在spring创建bean时，将获取beanFactory中的BeanPostProcessor并调用。</p>
<pre><code>public static void registerBeanPostProcessors(
        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {
    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

    // First, register the BeanPostProcessors that implement PriorityOrdered.
    sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);
    ...
}
</code></pre><h2 id="初始化事件广播器"><a href="#初始化事件广播器" class="headerlink" title="初始化事件广播器"></a>初始化事件广播器</h2><p>Spring事件体系包括三个组件：事件，事件监听器，事件广播器。事件广播器负责将事件广播给监听器。<br><code>initApplicationEventMulticaster</code>将初始化广播器,并放到beanFactory中  </p>
<pre><code>protected void initApplicationEventMulticaster() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    // beanFactory中包含了事件广播器
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {    
        this.applicationEventMulticaster =
                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
    }
    else {    // 使用默认的事件广播器
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
    }
}
</code></pre><h2 id="初始化事件监听器"><a href="#初始化事件监听器" class="headerlink" title="初始化事件监听器"></a>初始化事件监听器</h2><p>事件监听器负责监听事件，并做出处理。<br>registerListeners将初始化事件监听器，并添加到事件广播器上。</p>
<pre><code>protected void registerListeners() {
    // Register statically specified listeners first.
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    // Publish early application events now that we finally have a multicaster...
    ...
}
</code></pre><h2 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h2><pre><code>protected void finishRefresh() {
    // Initialize lifecycle processor for this context.
    initLifecycleProcessor();

    // Propagate refresh to lifecycle processor first.
    getLifecycleProcessor().onRefresh();

    // Publish the final event.
    publishEvent(new ContextRefreshedEvent(this));

    // Participate in LiveBeansView MBean, if active.
    LiveBeansView.registerApplicationContext(this);
}
</code></pre><p>LifecycleProcessor是spring生命周期的管理。可以定义spring启动start，停止stop，或刷新onRefresh等操作。</p>
<pre><code>protected void initLifecycleProcessor() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {
        this.lifecycleProcessor =
                beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);
    }
    else {    // 使用默认的LifecycleProcessor
        DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();
        defaultProcessor.setBeanFactory(beanFactory);
        this.lifecycleProcessor = defaultProcessor;
        beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);
    }
}
</code></pre>
					</div>
					
			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/spring-support.md" data-title="spring-support" data-url="https://binecy.coding.me/spring-support/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'tanke773'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  


</div>
	</div>

	
		<div class="col-md-3">
			<div id="toc" ></div>
		</div>
	

</div>


		<footer>
			

<!--
<p>
  &copy; 2017 <a href="https://binecy.coding.me"> bin </a>
</p>
-->
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
