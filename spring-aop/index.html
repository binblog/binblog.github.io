	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>spring aop源码解析 | binecy</title>
  <meta name="author" content="bin">
  
  <meta name="description" content="这篇文章主要叙述spring aop内部源码的实现，不当之处，还望指出
一个小栗子定义一个服务接口
package com.spring.start.service;

public interface IBlogService {
    int getBlogCount();
}
接口实现类
p">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="spring aop源码解析"/>
  <meta property="og:site_name" content="binecy"/>

  
  
		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="/favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">binecy</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/about" title="">
                    <i class="fa fa-info-circle"></i>关于
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>spring aop源码解析</h2>
					
					<div>
						<span class="post-time">2017-07-23 10:54:59</span>
					</div>	
					

					<div class="article-content">
						<p>这篇文章主要叙述spring aop内部源码的实现，不当之处，还望指出</p>
<h2 id="一个小栗子"><a href="#一个小栗子" class="headerlink" title="一个小栗子"></a>一个小栗子</h2><p>定义一个服务接口</p>
<pre><code>package com.spring.start.service;

public interface IBlogService {
    int getBlogCount();
}
</code></pre><p>接口实现类</p>
<pre><code>package com.spring.start.service;

public class BlogService implements IBlogService {
    @Override
    public int getBlogCount() {
        int count = 123;
        System.out.println(&quot;blog count : &quot; + count);
        return count;
    }
}
</code></pre><p>定义一个切面（Aspect）</p>
<pre><code>@Aspect
public class LogAspect {

    @Around(&quot;execution(public * com.spring.start..*.*.*(..))&quot;)
    public Object methodAroundLog(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;log1 : start method&quot;);
        Object result = joinPoint.proceed(joinPoint.getArgs());
        System.out.println(&quot;log2 : end method&quot;);
        return result;
    }


    @Around(&quot;execution(public * com.spring.start..*.*.*(..))&quot;)
    public Object methodAroundLog2(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println(&quot;log2 : start method&quot;);
        Object result = joinPoint.proceed(joinPoint.getArgs());
        System.out.println(&quot;log2 : end method&quot;);
        return result;
    }
}
</code></pre><p>切面类中定义了两个通知（Advice）methodAroundLog和methodAroundLog2，对com.spring.start下所有子包中所有类的所有pubic方法进行拦截，并输出写简单的log信息。</p>
<p>来看看配置文件application.xml</p>
<pre><code>    &lt;!-- 开启aop --&gt;
    &lt;aop:aspectj-autoproxy/&gt;

    &lt;!-- 定义切面 --&gt;
    &lt;bean id=&quot;logAspect&quot; class=&quot;com.spring.start.aop.LogAspect&quot;&gt;&lt;/bean&gt;

    &lt;!-- 定义service --&gt;
    &lt;bean id=&quot;blogService&quot; class=&quot;com.spring.start.service.BlogService&quot;&gt;&lt;/bean&gt;
</code></pre><p>测试方法</p>
<pre><code>public static void main(String[] args) {
    ApplicationContext beanFactory = new ClassPathXmlApplicationContext(&quot;application.xml&quot;);
    IBlogService blogService = beanFactory.getBean(&quot;blogService&quot;, IBlogService.class);
    blogService.getBlogCount();        
}
</code></pre><p>输出结果：</p>
<pre><code>log1 : start method
log2 : start method
blog count : 123
log2 : end method
log2 : end method
</code></pre><p>可以看到aop已成功拦截到了方法，并输出了对应的log。</p>
<p>一开始，先明确几个概念<br>aspect：切面，该切面可以包含多个切入点和通知，而且标签内部的通知和切入点定义是无序的<br>advice：通知，表示一个method执行前或执行后的动作。上面栗子中定义了两个环绕通知<br>pointcut：切入点，表示根据method的名字或者正则表达式去拦截一个method。<br>advisor：只有一个通知和一个切入点的切面，可以看做一种特殊的aspect</p>
<p>开始阅读源码前，我比较关注的几个问题：</p>
<ol>
<li><code>&lt;aop:aspectj-autoproxy/&gt;</code>的作用</li>
<li>spring如何根据Aspect注解创建切面</li>
<li>spring如何根据切面信息创建代理对象</li>
<li>上面定义的两个通知methodAroundLog和methodAroundLog2，spring是如何进行链式调用的</li>
</ol>
<h2 id="lt-aop-aspectj-autoproxy-gt-的作用"><a href="#lt-aop-aspectj-autoproxy-gt-的作用" class="headerlink" title="&lt;aop:aspectj-autoproxy/&gt; 的作用"></a><code>&lt;aop:aspectj-autoproxy/&gt;</code> 的作用</h2><p>aspectj-autoproxy是spring自定义的标签。我们知道，在spring中自定义标签，需要编写一个继承于NamespaceHandlerSupport的类来实现标签解析工作。<br>在github spring源码中搜索一下，就可以发现aspectj-autoproxy的解析类是AopNamespaceHandler：</p>
<pre><code>public void init() {
    this.registerBeanDefinitionParser(&quot;config&quot;, new ConfigBeanDefinitionParser());
    this.registerBeanDefinitionParser(&quot;aspectj-autoproxy&quot;, new AspectJAutoProxyBeanDefinitionParser());
    this.registerBeanDefinitionDecorator(&quot;scoped-proxy&quot;, new ScopedProxyBeanDefinitionDecorator());
    this.registerBeanDefinitionParser(&quot;spring-configured&quot;, new SpringConfiguredBeanDefinitionParser());
}
</code></pre><p>而AspectJAutoProxyBeanDefinitionParser类负责对aspectj-autoproxy标签进行解析：</p>
<pre><code>public BeanDefinition parse(Element element, ParserContext parserContext) {
    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
    extendBeanDefinition(element, parserContext);
    return null;
}
</code></pre><p>关键代码是AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary：</p>
<pre><code>public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(
        ParserContext parserContext, Element sourceElement) {

    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext.getRegistry(), parserContext.extractSource(sourceElement));
    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
    registerComponentIfNecessary(beanDefinition, parserContext);
}
</code></pre><p>AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary：</p>
<pre><code>public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {
    return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
}
</code></pre><p>这里可以看到一个关键的类AnnotationAwareAspectJAutoProxyCreator，该类负责创建切面，registerOrEscalateApcAsRequired就是把该类注入到spring上下文环境中，以便后面使用。</p>
<pre><code>private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) {
    ...
    // 创建RootBeanDefinition, RootBeanDefinition是spring的元素单元
    RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);    
    beanDefinition.setSource(source);
    beanDefinition.getPropertyValues().add(&quot;order&quot;, Ordered.HIGHEST_PRECEDENCE);
    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
    // 注册到spring上下文
    registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);        
    return beanDefinition;
}
</code></pre><h2 id="创建切面"><a href="#创建切面" class="headerlink" title="创建切面"></a>创建切面</h2><p>spring中提供了BeanPostProcessor扩展接口，该接口有两个方法postProcessBeforeInitialization和postProcessAfterInitialization，实现该接口这两个方法，就可以在spring完成Bean的实例化前后添加自己的逻辑处理。</p>
<p>上面被aspectj-autoproxy解析类注入到spring上下文的AnnotationAwareAspectJAutoProxyCreator类，继承自AbstractAutoProxyCreator类，并实现了BeanPostProcessor。<br>来看看AbstractAutoProxyCreator.postProcessAfterInitialization（spring会在目标bean生成后调用该方法）</p>
<pre><code>public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (bean != null) {
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (!this.earlyProxyReferences.contains(cacheKey)) {
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}
</code></pre><p>主要操作在wrapIfNecessary:</p>
<pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
    ...

    // 创建Advices和Advisors
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);

    if (specificInterceptors != DO_NOT_PROXY) {
        this.advisedBeans.put(cacheKey, Boolean.TRUE);
        // 创建代理
        Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    return bean;
}
</code></pre><p>getAdvicesAndAdvisorsForBean会创建通知，该方法会调用子类AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean,并调用的AbstractAdvisorAutoProxyCreator.findEligibleAdvisors</p>
<pre><code>protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {
    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();    // 创建Advisors
    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);    // 过滤Advisors
    extendAdvisors(eligibleAdvisors);
    if (!eligibleAdvisors.isEmpty()) {
        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
    }
    return eligibleAdvisors;
}
</code></pre><p>这是一个非常重要的方法，实现了几个关键步骤</p>
<ol>
<li>findCandidateAdvisors 查找Advisors(第一次会创建)</li>
<li>findAdvisorsThatCanApply 根据目标bean的class过滤一部分的Advisors</li>
<li>extendAdvisors 扩充Advisors，spring会根据需要添加一些内部的Advisors</li>
<li>sortAdvisors 对Advisors排序</li>
</ol>
<h3 id="findCandidateAdvisors-查找Advisors"><a href="#findCandidateAdvisors-查找Advisors" class="headerlink" title="findCandidateAdvisors 查找Advisors"></a>findCandidateAdvisors 查找Advisors</h3><p>findCandidateAdvisors方法负责找到所有的Advisors，该方法会调用到AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors</p>
<pre><code>protected List&lt;Advisor&gt; findCandidateAdvisors() {
    // Add all the Spring advisors found according to superclass rules.
    List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();
    // Build Advisors for all AspectJ aspects in the bean factory.
    advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
    return advisors;
}
</code></pre><p>this.aspectJAdvisorsBuilder.buildAspectJAdvisors()是创建Advisor的关键，来看看BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors</p>
<pre><code>public List&lt;Advisor&gt; buildAspectJAdvisors() {
    List&lt;String&gt; aspectNames = this.aspectBeanNames;

    if (aspectNames == null) {
        synchronized (this) {
            aspectNames = this.aspectBeanNames;
            if (aspectNames == null) {


                List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();
                aspectNames = new LinkedList&lt;String&gt;();
                // 获取所以的bean
                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this.beanFactory, Object.class, true, false);

                for (String beanName : beanNames) {
                    ...
                    // 如果有Aspect注解
                    if (this.advisorFactory.isAspect(beanType)) {    
                        ...
                        if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
                            // 创建factory
                            MetadataAwareAspectInstanceFactory factory = new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);    
                            // 创建Advisors
                            List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);        
                            if (this.beanFactory.isSingleton(beanName)) {
                                this.advisorsCache.put(beanName, classAdvisors);    
                            }
                            else {
                                this.aspectFactoryCache.put(beanName, factory);
                            }
                            advisors.addAll(classAdvisors);
                        }
                    }    
                }
            }
        }    
    }

    if (aspectNames.isEmpty()) {
        return Collections.emptyList();
    }
    // 构建结果
    List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();
    for (String aspectName : aspectNames) {
        List&lt;Advisor&gt; cachedAdvisors = this.advisorsCache.get(aspectName);
        if (cachedAdvisors != null) {
            advisors.addAll(cachedAdvisors);
        }
        else {
            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
            advisors.addAll(this.advisorFactory.getAdvisors(factory));
        }
    }
    return advisors;
}
</code></pre><p>这里可以看到一个简单的单例模式，如果当前的aspectBeanNames为null，会创建Advisors，并保存在advisorsCache中，以后每次都从advisorsCache取出advisors。</p>
<p>可以看到，如果一个类有Aspect注解，就会使用该类的beanName创建MetadataAwareAspectInstanceFactory，并通过factory创建Advisors<br>而<code>this.advisorFactory.getAdvisors(factory)</code>将会调用到ReflectiveAspectJAdvisorFactory.getAdvisors</p>
<pre><code>public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
    // 切面类
    Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();    
    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
    validate(aspectClass);

    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator
    // so that it will only instantiate once.
    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory = new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

    List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;();
    // getAdvisorMethods会获取没有Pointcut注解的方法
    for (Method method : getAdvisorMethods(aspectClass)) {    
        // 创建Advisor
        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);    
        if (advisor != null) {
            advisors.add(advisor);
        }
    }

}    

//  创建Advisor
public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
        int declarationOrderInAspect, String aspectName) {
    // 获取切入点Pointcut    
    AspectJExpressionPointcut expressionPointcut = getPointcut(candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());        
    if (expressionPointcut == null) {
        return null;
    }

    // 创建Advisor,Advisor中包含了pointcut和adviceMethod
    return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
}    

//  获取切入点Pointcut
private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) {
    // 找到有Before, Around, After, AfterReturning, AfterThrowing, Pointcut注释的方法
    AspectJAnnotation&lt;?&gt; aspectJAnnotation = AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);        
    if (aspectJAnnotation == null) {
        return null;
    }

    // 生成AspectJExpressionPointcut，该类记录了Aspect表达式
    AspectJExpressionPointcut ajexp = new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);
    ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
    ajexp.setBeanFactory(this.beanFactory);
    return ajexp;
}
</code></pre><p>从上面可以看到，对应Aspect注解了的类，spring会查找其中有Before, Around, After, AfterReturning, AfterThrowing, Pointcut的方法，并创建Advisor。</p>
<h3 id="findAdvisorsThatCanApply-过滤Advisors"><a href="#findAdvisorsThatCanApply-过滤Advisors" class="headerlink" title="findAdvisorsThatCanApply 过滤Advisors"></a>findAdvisorsThatCanApply 过滤Advisors</h3><p>findAdvisorsThatCanApply方法，会过滤部分的Advisors<br>这里会检查目标bean的class和class中是否有方法可以匹配Advisor，如果没有则过滤。比较繁琐，不展开了</p>
<h3 id="extendAdvisors-eligibleAdvisors-扩充Advisors"><a href="#extendAdvisors-eligibleAdvisors-扩充Advisors" class="headerlink" title="extendAdvisors(eligibleAdvisors)  扩充Advisors"></a>extendAdvisors(eligibleAdvisors)  扩充Advisors</h3><p>看看AspectJAwareAdvisorAutoProxyCreator.extendAdvisors</p>
<pre><code>protected void extendAdvisors(List&lt;Advisor&gt; candidateAdvisors) {
    AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary(candidateAdvisors);
}
</code></pre><p>AspectJProxyUtils.makeAdvisorChainAspectJCapableIfNecessary</p>
<pre><code>public static boolean makeAdvisorChainAspectJCapableIfNecessary(List&lt;Advisor&gt; advisors) {
    // Don&#39;t add advisors to an empty list; may indicate that proxying is just not required
    if (!advisors.isEmpty()) {
        ...
        if (foundAspectJAdvice &amp;&amp; !advisors.contains(ExposeInvocationInterceptor.ADVISOR)) {
            // 添加ExposeInvocationInterceptor
            advisors.add(0, ExposeInvocationInterceptor.ADVISOR);
            return true;
        }
    }
    return false;
}
</code></pre><p>spring在advisors的开始位置添加了ExposeInvocationInterceptor</p>
<h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><p>我们知道，spring通过动态代理类实现aop，有jdk动态代理和cglib两种方法。<br>如果要使用jdk动态代理，被代理类必须实现一个接口。<br>为了避免在这里额外介绍cglib，我在上面的小栗子中让spring生成的BlogService实现了一个接口，这样我们来看一下jdk动态代理如何实现aop</p>
<p>回顾AbstractAutoProxyCreator.wrapIfNecessary方法：</p>
<pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
    // 构建Advisors
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
    if (specificInterceptors != DO_NOT_PROXY) {
        this.advisedBeans.put(cacheKey, Boolean.TRUE);
        // 生成代理
        Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }
}
</code></pre><p>getAdvicesAndAdvisorsForBean已经讲解（getAdvicesAndAdvisorsForBean已经查找了Advices和Advisors，buildAdvisors只是做一些检查，转换处理，如将Advices转换成Advisor），<br>这里来看看动态代理创建过程AbstractAutoProxyCreator.createProxy        </p>
<pre><code>protected Object createProxy(
    ...
    Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    // 存储Advisor
    for (Advisor advisor : advisors) {    
        proxyFactory.addAdvisor(advisor);
    }

    return proxyFactory.getProxy(getProxyClassLoader());
}
</code></pre><p>ProxyFactory.getProxy</p>
<pre><code>public Object getProxy(ClassLoader classLoader) {
    return createAopProxy().getProxy(classLoader);
}
</code></pre><p>调用父类ProxyCreatorSupport.createAopProxy</p>
<pre><code>protected final synchronized AopProxy createAopProxy() {
    if (!this.active) {
        activate();
    }
    return getAopProxyFactory().createAopProxy(this);
}
</code></pre><p><code>getAopProxyFactory().createAopProxy(this)</code>中参数是this，proxyFactory将自身作为参数（proxyFactory存储着Advisor），调用DefaultAopProxyFactory.createAopProxy</p>
<pre><code>public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
    if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
        Class&lt;?&gt; targetClass = config.getTargetClass();
        ...
        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
            return new JdkDynamicAopProxy(config);
        }
        return new ObjenesisCglibAopProxy(config);
    }
    else {
        return new JdkDynamicAopProxy(config);
    }
}
</code></pre><p>可以看到，spring会根据用户配置和目标bean是否有实现接口，来决定使用JdkDynamicAopProxy或ObjenesisCglibAopProxy</p>
<p>来看看JdkDynamicAopProxy.getProxy</p>
<pre><code>public Object getProxy(ClassLoader classLoader) {
    if (logger.isDebugEnabled()) {
        logger.debug(&quot;Creating JDK dynamic proxy: target source is &quot; + this.advised.getTargetSource());
    }
    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
    // 创建代理对象
    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);    
}
</code></pre><p>注意：<code>Proxy.newProxyInstance(classLoader, proxiedInterfaces, this)</code>第三个参数是JdkDynamicAopProxy.this，JdkDynamicAopProxy实现了InvocationHandler</p>
<h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>JdkDynamicAopProxy实现了InvocationHandler，看一下关键的invoke方法：</p>
<pre><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // 获取拦截器链
    List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

    invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
    // Proceed to the joinpoint through the interceptor chain.
    retVal = invocation.proceed();
}
</code></pre><p><code>this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass)</code> 获取拦截器链，</p>
<pre><code>public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Method method, Class&lt;?&gt; targetClass) {
    MethodCacheKey cacheKey = new MethodCacheKey(method);
    // 从缓存中查询
    List&lt;Object&gt; cached = this.methodCache.get(cacheKey);
    if (cached == null) {
        // 缓存没有则创建
        cached = this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(this, method, targetClass);
        this.methodCache.put(cacheKey, cached);
    }
    return cached;
}
</code></pre><p>DefaultAdvisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice </p>
<pre><code>public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(Advised config, Method method, Class&lt;?&gt; targetClass) {

    ...
    for (Advisor advisor : config.getAdvisors()) {
        if (advisor instanceof PointcutAdvisor) {
            // Add it conditionally.
            PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;
            // 检查class是否匹配
            if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {    
                MethodInterceptor[] interceptors = registry.getInterceptors(advisor);
                MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();
                // 检查method 是否匹配
                if (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) {    
                    if (mm.isRuntime()) {
                        // Creating a new object instance in the getInterceptors() method
                        // isn&#39;t a problem as we normally cache created chains.
                        for (MethodInterceptor interceptor : interceptors) {    
                            interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));
                        }
                    }
                    else {
                        interceptorList.addAll(Arrays.asList(interceptors));
                    }
                }
            }
        }
    }
}
</code></pre><p>可以看到，这里从Advisor获取到对应的MethodInterceptor数组，MethodInterceptor中包括了Advisor中定义的advice（通知）。</p>
<p>回到ReflectiveMethodInvocation.proceed，ReflectiveMethodInvocation，顾名思义，反射方法进行调用</p>
<pre><code>public Object proceed() throws Throwable {
    // 是否到拦截器链尾了
    if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {    
        return invokeJoinpoint();
    }

    // 获取下一个拦截器，currentInterceptorIndex初始值是-1
    Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);    
    // 是否为动态拦截器
    if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {    
        ...
    }
    else {
        // 直接调用
        return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);    
    }
}
</code></pre><p>注意，invoke会将ReflectiveMethodInvocation自身作为参数。</p>
<p>调用链以ExposeInvocationInterceptor开头，ExposeInvocationInterceptor只是简单的配置和恢复上下文</p>
<pre><code>public Object invoke(MethodInvocation mi) throws Throwable {
    MethodInvocation oldInvocation = invocation.get();
    // 设置上下文
    invocation.set(mi);    

    try {
        return mi.proceed();
    }
    finally {
        invocation.set(oldInvocation);    // 恢复上下文
    }
}
</code></pre><p><code>mi.proceed()</code>会调用到ReflectiveMethodInvocation.proceed()，会调用到下一个拦截器，这时进入AspectJAroundAdvice</p>
<pre><code>public Object invoke(MethodInvocation mi) throws Throwable {
    if (!(mi instanceof ProxyMethodInvocation)) {
        throw new IllegalStateException(&quot;MethodInvocation is not a Spring ProxyMethodInvocation: &quot; + mi);
    }
    ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;
    ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);
    JoinPointMatch jpm = getJoinPointMatch(pmi);
    return invokeAdviceMethod(pjp, jpm, null, null);
}

protected Object invokeAdviceMethod(JoinPoint jp, JoinPointMatch jpMatch, Object returnValue, Throwable t)
        throws Throwable {
    // argBinding绑定参数
    return invokeAdviceMethodWithGivenArgs(argBinding(jp, jpMatch, returnValue, t));    
}
</code></pre><p>argBinding负责绑定参数，实际就是把JoinPoint作为第一个方法参数。</p>
<pre><code>protected Object[] argBinding(JoinPoint jp, JoinPointMatch jpMatch, Object returnValue, Throwable ex) {
    ...
    int numBound = 0;

    if (this.joinPointArgumentIndex != -1) {
        adviceInvocationArgs[this.joinPointArgumentIndex] = jp;

    }

    return adviceInvocationArgs;
}
</code></pre><p>AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs会调用到AdviceMethod(aspectJAdviceMethod)，就是执行通知</p>
<pre><code>protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {
    return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
}
</code></pre><p>在环绕通知中</p>
<pre><code>    @Around(&quot;...&quot;)
    public Object methodAroundLog(ProceedingJoinPoint joinPoint) throws Throwable {
        Object result = joinPoint.proceed(joinPoint.getArgs());
        return result;
    }
</code></pre><p>由于第一个参数就是JoinPoint，所以joinPoint.proceed(joinPoint.getArgs());`就可以调用下一个拦截器，这样就实现了拦截器链调用</p>

					</div>
					
			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/spring-aop.md" data-title="spring aop源码解析" data-url="https://binecy.coding.me/spring-aop/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'tanke773'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  


</div>
	</div>

	

</div>


		<footer>
			

<!--
<p>
  &copy; 2017 <a href="https://binecy.coding.me"> bin </a>
</p>
-->
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
