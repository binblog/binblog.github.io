	<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>netty启动过程源码简析 | binecy</title>
  <meta name="author" content="bin">
  
  <meta name="description" content="一个小栗子
EventLoopGroup parentGroup = new NioEventLoopGroup();
EventLoopGroup childGroup = new NioEventLoopGroup();
ServerBootstrap b = new ServerBootstr">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="netty启动过程源码简析"/>
  <meta property="og:site_name" content="binecy"/>

  
  
		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="/favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>

 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">binecy</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/about" title="">
                    <i class="fa fa-info-circle"></i>关于
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>netty启动过程源码简析</h2>
					
					<div>
						<span class="post-time">2017-03-02 19:21:47</span>
					</div>	
					

					<div class="article-content">
						<p>一个小栗子</p>
<pre><code>EventLoopGroup parentGroup = new NioEventLoopGroup();
EventLoopGroup childGroup = new NioEventLoopGroup();
ServerBootstrap b = new ServerBootstrap();
b.group(parentGroup, 与childGroup)
    .channel(NioServerSocketChannel.class)
    .childHandler(...);

// Start the server.
ChannelFuture f = b.bind(PORT).sync();

// Wait until the server socket is closed.
f.channel().closeFuture().sync();
</code></pre><p>栗子中创建了    parentGroup和childGroup，<br>parentGroup负责处理请求的accept事件， 类似于reactor模式中的acceptor<br>childGroup负责接收请求的read、write事件，并分发给对应的处理器，类似于reactor模式中的reactor对象。<br><img src="/netty-start/1.png" alt=""></p>
<p><strong>创建NioEventLoopGroup</strong><br>NioEventLoopGroup实现了EventLoopGroup接口，负责对EventLoop进行管理。 NioEventLoopGroup的构造过程主要在MultithreadEventExecutorGroup构造方法中</p>
<pre><code>protected MultithreadEventExecutorGroup(int nThreads, Executor executor,EventExecutorChooserFactory chooserFactory, Object... args) {                                    
    // 执行器
    executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
    children = new EventExecutor[nThreads];
    // 选择器
    chooser = chooserFactory.newChooser(children);    
    // 创建EventLoop    
    for (int i = 0; i &lt; nThreads; i ++) {
        children[i] = newChild(threadFactory, args);
    }
}

protected EventExecutor newChild(  
            ThreadFactory threadFactory, Object... args) throws Exception {  
      return new NioEventLoop(this, threadFactory, (SelectorProvider) args[0]);  
}
</code></pre><p><strong>启动</strong></p>
<pre><code>private ChannelFuture doBind(final SocketAddress localAddress) {
    final ChannelFuture regFuture = initAndRegister();

    if (regFuture.isDone()) {
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        ...
    }
}
</code></pre><p>initAndRegister中创建并注册了Channel。</p>
<pre><code>final ChannelFuture initAndRegister() {
    Channel channel = null;
    channel = channelFactory.newChannel();
    init(channel);

    ChannelFuture regFuture = config().group().register(channel);
}
</code></pre><p><code>channelFactory.newChannel()</code>中的channelFactory为ReflectiveChannelFactory对象，这时通过反射生成NioServerSocketChannel对象（通过ServerBootstrap.channel(NioServerSocketChannel.class)设置）</p>
<p>NioServerSocketChannel是对java.nio.channels.ServerSocketChannel的封装,实现了io.netty.channel.Channel接口。</p>
<p><strong>创建NioServerSocketChannel</strong><br><img src="/netty-start/2.png" alt=""></p>
<pre><code>public NioServerSocketChannel() {
    this(newSocket(DEFAULT_SELECTOR_PROVIDER));
}
</code></pre><p>DEFAULT_SELECTOR_PROVIDER为java.nio.channels.spi.SelectorProvider,<br><code>newSocket(DEFAULT_SELECTOR_PROVIDER)</code>将创建一个ServerSocketChannel。</p>
<pre><code>public NioServerSocketChannel(ServerSocketChannel channel) {
    super(null, channel, SelectionKey.OP_ACCEPT);    
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}

protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    super(parent);
    this.ch = ch;
    // 该readInterestOp即为NioServerSocketChannel构造方法中的SelectionKey.OP_ACCEPT
    this.readInterestOp = readInterestOp;    

    ch.configureBlocking(false);    // 设置channel为非阻塞
}

protected AbstractChannel(Channel parent) {
    this.parent = parent;
    id = newId();
    unsafe = newUnsafe();    // 初始化unsafe
    pipeline = newChannelPipeline();    // 初始化pipeline
}
</code></pre><p>AbstractChannel构造时创建了两个关键的属性：<br>unsafe为NioMessageUnsafe，通过AbstractNioMessageChannel重写的<code>newUnsafe()</code>创建<br>unsafe负责真正的操作，如register，bind，read等操作<br>pipeline则创建了DefaultChannelPipeline</p>
<p><strong>创建pipeline</strong></p>
<pre><code>protected DefaultChannelPipeline(Channel channel) {
    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);
    succeededFuture = new SucceededChannelFuture(channel, null);
    voidPromise =  new VoidChannelPromise(channel, true);

    tail = new TailContext(this);
    head = new HeadContext(this);

    head.next = tail;
    tail.prev = head;
}
</code></pre><p>pipeline是一个链表，链表中的结点为ChannelHandlerContext，ChannelHandlerContext是包含ChannelHandler的上下文。</p>
<p>需要注意，DefaultChannelPipeline创建后，就已经包括了head，tail两个结点。</p>
<p><strong>初始化channel</strong><br>到此，channel已经成功创建，<code>init(channel)</code>将初始化channel</p>
<pre><code>void init(Channel channel) {
    // 初始化options和attr
    ...

    p.addLast(new ChannelInitializer&lt;Channel&gt;() {    // 添加ChannelInitializer handler
            @Override
            public void initChannel(Channel ch) throws Exception {
                final ChannelPipeline pipeline = ch.pipeline();
                ChannelHandler handler = config.handler();

                ch.eventLoop().execute(new Runnable() {
                    @Override
                    public void run() {
                        pipeline.addLast(new ServerBootstrapAcceptor(
                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                    }
                });
            }
        });
}
</code></pre><p>这时添加了一个ChannelInitializer handler了，注意，addLast不是将handler添加到最后结点，而是倒数第二结点，tail总是最后一个结点。</p>
<p><strong>注册channel</strong><br><code>config().group().register(channel)</code>进行了注册操作<br>注意config().group()返回的是parent EventLoopGroup</p>
<p>EventLoop继承自java.util.concurrent.ScheduledExecutorService，是一个任务执行器，可以将任务提交给它，则它来执行。</p>
<p>SingleThreadEventLoop实现了EventLoop，并继承自SingleThreadEventExecutor，Executor封装了任务执行细节。<br>nioEventLoop继承了SingleThreadEventLoop，并封装了java.nio.channels.Selector，响应其中的事件。</p>
<p>注册过程<br>MultithreadEventLoopGroup</p>
<pre><code>public ChannelFuture register(Channel channel) {
    return next().register(channel);    // 通过选择器选择一个合适的EventLoop
}
</code></pre><p>SingleThreadEventLoop</p>
<pre><code>public ChannelFuture register(Channel channel) {
    return register(new DefaultChannelPromise(channel, this));
}

public ChannelFuture register(final ChannelPromise promise) {
    promise.channel().unsafe().register(this, promise);
    return promise;
}
</code></pre><p>上面已经说了，channel中的unsafe对应为AbstractUnsafe，查看其register</p>
<pre><code>public final void register(EventLoop eventLoop, final ChannelPromise promise) {
    ...
    if (eventLoop.inEventLoop()) {
        register0(promise);
    } else {

        eventLoop.execute(new Runnable() {
            @Override
            public void run() {
                register0(promise);
            }
        });
    }
}
</code></pre><p>如果当前线程是eventLoop的执行线程，则直接在当前线程执行<code>register0</code>，否则将提交一个新任务到eventLoop中。</p>
<p>注意：调用<code>eventLoop.execute</code>时，如果eventLoop没有启动，将调用eventLoop。</p>
<pre><code>private void register0(ChannelPromise promise) {
    doRegister();
    ...
    // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
    // user may already fire events through the pipeline in the ChannelFutureListener.
    pipeline.invokeHandlerAddedIfNeeded();

// Only fire a channelActive if the channel has never been registered. This prevents firing
    // multiple channel actives if the channel is deregistered and re-registered.
    pipeline.fireChannelRegistered();

    if (isActive()) {
        if (firstRegistration) {
            pipeline.fireChannelActive();
        } else if (config().isAutoRead()) {
            // This channel was registered before and autoRead() is set. This means we need to begin read
            // again so that we process inbound data.
            //
            // See https://github.com/netty/netty/issues/4805
            beginRead();
        }
    }

}
</code></pre><p><code>doRegister</code>将调用到AbstractNioChannel.doRegister</p>
<pre><code>protected void doRegister() throws Exception {
    selectionKey = javaChannel().register(eventLoop().selector, 0, this);
    return;    
}
</code></pre><p>需要注意，register中的ops参数为0，这时只是把select注册到channel上,将没有监听任何事件。</p>
<p>监听事件在<code>beginRead()</code>方法中实现，该方法将调用到AbstractNioChannel.doBeginRead</p>
<pre><code>protected void doBeginRead() throws Exception {
    ...
    final int interestOps = selectionKey.interestOps();
    if ((interestOps &amp; readInterestOp) == 0) {
        selectionKey.interestOps(interestOps | readInterestOp);
    }
}
</code></pre><p>interestOps为0,readInterestOp在NioServerSocketChannel创建时已经被赋值为SelectionKey.OP_ACCEPT,所以<code>interestOps | readInterestOp</code>为SelectionKey.OP_ACCEPT，这时成功设置事件监听。</p>
<p><strong>绑定端口</strong><br>启动的最后一步，就是绑定端口，在AbstractBootstrap.doBind0中实现</p>
<pre><code>private static void doBind0(
        final ChannelFuture regFuture, final Channel channel,
        final SocketAddress localAddress, final ChannelPromise promise) {

    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up
    // the pipeline in its channelRegistered() implementation.
    channel.eventLoop().execute(new Runnable() {
        @Override
        public void run() {
            if (regFuture.isSuccess()) {
                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
            } else {
                promise.setFailure(regFuture.cause());
            }
        }
    });
}
</code></pre><p>DefaultChannelPipeline.bind</p>
<pre><code>public final ChannelFuture bind(SocketAddress localAddress) {
    return tail.bind(localAddress);
}
</code></pre><p>HeadContext.bind</p>
<pre><code>public ChannelFuture bind(final SocketAddress localAddress, final ChannelPromise promise) {
    final AbstractChannelHandlerContext next = findContextOutbound();
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            next.invokeBind(localAddress, promise);
        } else {
            safeExecute(executor, new Runnable() {
                @Override
                public void run() {
                    next.invokeBind(localAddress, promise);
                }
            }, promise, null);
        }
        return promise;
}
</code></pre><p><code>findContextOutbound()</code>将找到HeadContext，HeadContext.bind</p>
<pre><code>unsafe.bind(localAddress, promise);
</code></pre><p>NioMessageUnsafe.bind将调用外部类的<code>doBind(localAddress)</code>方法，最终调用NioServerSocketChannel.doBind</p>
<pre><code>protected void doBind(SocketAddress localAddress) throws Exception {
    if (PlatformDependent.javaVersion() &gt;= 7) {
        javaChannel().bind(localAddress, config.getBacklog());
    } else {
        javaChannel().socket().bind(localAddress, config.getBacklog());
    }
}
</code></pre><p>到此,启动完成。</p>

					</div>
					
			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  
   <!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="_posts/netty-start.md" data-title="netty启动过程源码简析" data-url="https://binecy.coding.me/netty-start/"></div>
    <!-- 多说评论框 end -->
   <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
    <script type="text/javascript">
    var duoshuoQuery = {short_name:'tanke773'};
      (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
      })();
      </script>
    <!-- 多说公共JS代码 end -->
  


</div>
	</div>

	

</div>


		<footer>
			

<!--
<p>
  &copy; 2017 <a href="https://binecy.coding.me"> bin </a>
</p>
-->
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
